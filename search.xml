<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Note-platform</title>
      <link href="/2024/11/04/Note-platform/"/>
      <url>/2024/11/04/Note-platform/</url>
      
        <content type="html"><![CDATA[<p>直接finetune存在问题，</p><p>数据集构建，</p><p>3docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; export USE_MODELSCOPE_HUB=1</span><br><span class="line"></span><br><span class="line">export CUDA_VISIBLE_DEVICES=1 &amp;&amp; llamafactory-cli webui</span><br><span class="line">http://10.8.21.6:7899/</span><br></pre></td></tr></table></figure><p>docker系统中换源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/apt/sources.list</span><br><span class="line">http://archive.ubuntu.com/ubuntu/</span><br><span class="line">https://mirrors.aliyun.com/ubuntu</span><br><span class="line">pip install oss2 addict </span><br></pre></td></tr></table></figure><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 或 <span class="built_in">cp</span> -r<span class="comment">#复制文件</span></span><br><span class="line"><span class="built_in">mv</span> 旧文件名 新文件名<span class="comment">#重命名文件</span></span><br><span class="line"><span class="built_in">df</span> -h<span class="comment">#查看空间使用情况</span></span><br><span class="line"><span class="built_in">du</span> -sh /path/to/folder<span class="comment">#查看文件夹大小</span></span><br><span class="line">tar -xzvf filename.tar.gz<span class="comment">#解压</span></span><br><span class="line">grep </span><br><span class="line">pip install llamafactory[metrics]==0.7.1 -i https://pypi.mirrors.ustc.edu.cn/simple/ --trusted-host=pypi.mirrors.ustc.edu.cn</span><br><span class="line"></span><br><span class="line"><span class="comment"># screen</span></span><br><span class="line">screen -<span class="built_in">ls</span>          列出当前所有的session</span><br><span class="line">screen -S session   创建一个名为 session的会话</span><br><span class="line">Ctrl+a d            退出当前 screen</span><br><span class="line">screen -r session   进入窗口 session的会话</span><br><span class="line"><span class="built_in">exit</span>                退出并关闭会话,并删除session</span><br><span class="line">screen -S 12345 -X quit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务器性能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi --list-gpus<span class="comment">#查看GPU</span></span><br><span class="line">watch -n 1 nvidia-smi<span class="comment">#实时显示，每1s切换</span></span><br></pre></td></tr></table></figure><p>出现“连接服务器 未能下载vscode服务器 server returned 404”问题</p><p><a href="https://zhuanlan.zhihu.com/p/671718415?utm_id=0&wd=&eqid=87e5498b004a9ff700000002658426b6">https://zhuanlan.zhihu.com/p/671718415?utm_id=0&amp;wd=&amp;eqid=87e5498b004a9ff700000002658426b6</a></p><p>pip暂时换源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xxx</span><br></pre></td></tr></table></figure><p>SSH端口转发</p><p>场景：</p><p>服务器（只有ip和user，使用ssh连接）上的docker中，运行tensorboard。</p><p>希望能在本地访问该tensorboard网站</p><p>操作：</p><p>服务器端：</p><ul><li>保证docker端口映射穿透（docker的端口被映射到宿主机的端口上）</li><li>运行docker中的tensorboard（注意一定要以–bind_all打开，否则即使是在服务器本地也无法访问tensorboard）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir ./ckpt/DangkaTemple/DangkaTemple_date/lightning_logs/version_5 --port 6007 --bind_all</span><br></pre></td></tr></table></figure><p>本地：</p><p>使用shell搭建SSH穿透，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">ssh -L local_port:remote_host:remote_port username@ssh_server</span><br><span class="line"></span><br><span class="line"># 我的</span><br><span class="line">ssh -L 6007:127.0.0.1:6007 root@192.168.242.193 -p 22</span><br></pre></td></tr></table></figure><p>本地打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:6007</span><br></pre></td></tr></table></figure><p>错误解决</p><p>【报错】tensorboard</p><p>使用tensorboard时，不显示图像，报错TypeError: MessageToJson() got an unexpected keyword argument ‘including_default_value_fields’</p><p>版本太高了，降版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall tensorboard</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorboard==2.12.0</span><br></pre></td></tr></table></figure><p>▲14.04安装共享文件夹</p><p># 1.安装VM VirtualBox</p><p># 2.安装Ubuntu</p><p># 3.关于共享文件夹的处理：</p><p>在VM上设置后需要在虚拟机内上方【设备】-》【安装增强功能】</p><p>若此时显示【未能加载虚拟光驱 VBoxsGuestAdditions.iso到虚拟电脑】，进入系统在侧边找到如图加载的虚拟光驱，右击，点击弹出，然后就可正常安装增强功能了。</p><p>然后若无法找到共享文件夹，则打开命令行，输入sudo usermod -a -G vboxsf  xxx(xxx是你当前注册Ubuntu的用户名)并重启虚拟机。</p><p>（将用户添加到多个组）</p><p>然后就可以使用共享文件夹了。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a href="https://www.bilibili.com/video/BV1bA411g7op">https://www.bilibili.com/video/BV1bA411g7op</a></p><p><a href="https://zhuanlan.zhihu.com/p/351541570">https://zhuanlan.zhihu.com/p/351541570</a></p><p>查询所有容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pa -a</span><br></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交互式容器</span><br><span class="line">docker run -it --name=容器名称 镜像名称 /bin/bash</span><br><span class="line">exit</span><br><span class="line">守护式容器</span><br><span class="line">docker run -di --name=容器名称 镜像名称</span><br><span class="line">docker exec -it </span><br></pre></td></tr></table></figure><h3 id="安装出现问题"><a href="#安装出现问题" class="headerlink" title="安装出现问题"></a>安装出现问题</h3><p>在云端配置mmdetection中，遇到WARNING: Running pip as the ‘root’ user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: 12. Virtual Environments and Packages — Python 3.12.0 documentation报错</p><p>要解决”Pip以’root’用户身份运行可能导致权限问题和与系统软件包管理器冲突的警告”，建议您使用虚拟环境。虚拟环境是一种隔离的Python环境，允许您在其中安装和管理软件包，而不会影响系统的其他部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv --help</span><br><span class="line">python3 -m venv mbyvenv</span><br><span class="line">source mbyvenv/bin/activate</span><br><span class="line">pip install package_name</span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure><h3 id="docker启动停止"><a href="#docker启动停止" class="headerlink" title="docker启动停止"></a>docker启动停止</h3><p>不要在服务器上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sy</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br><span class="line">docker start id/name</span><br><span class="line">docker stop/kill id/name</span><br><span class="line">docker exec -it &lt;container_id_or_name&gt; /bin/bash</span><br></pre></td></tr></table></figure><h3 id="常用的创建参数"><a href="#常用的创建参数" class="headerlink" title="常用的创建参数"></a>常用的创建参数</h3><p>注意：所有options要放在靠前面</p><p>Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it &lt;镜像名&gt;:&lt;镜像tag&gt; /bin/bash</span><br><span class="line">docker run -it --name &lt;自定义容器名&gt; --gpus all -v &lt;服务器文件夹路径&gt;:&lt;容器内部自定义路径&gt; -p &lt;服务器端口&gt;:&lt;容器端口&gt; &lt;镜像名&gt;:&lt;镜像tag&gt; /bin/bash</span><br></pre></td></tr></table></figure><ul><li><p><code>-it</code>：<code>i</code> 表示交互模式（interact），<code>t</code> 表示终端模式（terminal），表示创建的容器可以进行命令行交互。</p></li><li><p><code>--name &lt;自定义容器名&gt;</code>：为创建的容器指定名称。建议命名中有 <code>项目名</code>、<code>姓名</code>、<code>环境名</code>三项。姓名是为了区分不同人创建的容器，环境名是因为一个项目可能需要多个不同环境协同工作。</p></li><li><p><code>--gpus all</code>：指定容器可以访问所有 GPU。如果不指定该参数，容器内部将无法使用 GPU 资源。</p></li><li><p><code>-v &lt;服务器文件夹路径&gt;:&lt;容器内部自定义路径&gt;</code>：将服务器上的某个文件夹映射到容器内部。这样做有以下好处：</p><ol><li>可以避免在服务器和容器之间传输大型文件，服务器和容器对该文件夹的操作会同步。</li><li>解耦数据与环境。借助 Docker 镜像的支持，一组数据可以在多种环境下开发，同时避免因环境混乱而需要重新部署数据到另一个容器中。</li></ol></li><li><p><code>-p &lt;服务器端口&gt;:&lt;容器端口&gt;</code>：将容器内部的端口映射到服务器的端口上。当需要通过网络从外部访问容器时（例如 Web 后端），需要指定该参数。</p></li><li><p><code>&lt;镜像名&gt;:&lt;镜像tag&gt;</code>：指定容器基于哪个镜像。可以从 <a href="https://hub.docker.com/">https://hub.docker.com</a> 上查询并下载镜像。</p></li><li><p><code>/bin/bash</code>：启动容器时执行的命令。这里启动了 Bash 终端。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name mby_qwen --gpus all -v /home/mby/test:/test/ gpuci/miniconda-cuda:11.3-devel-ubuntu20.04 /bin/bash</span><br><span class="line"></span><br><span class="line">docker run -it --name mby_qwen2 --gpus all -v /home/mby/test:/test/ qwenllm/qwen:latest /bin/bash</span><br><span class="line"></span><br><span class="line">docker run -it --name mby_qwen --gpus all -v /home/mby/qwen_14b_chat:/qwen/ qwenllm/qwen:latest /bin/bash</span><br><span class="line"></span><br><span class="line">// gpt&gt;data</span><br><span class="line">docker run -it \</span><br><span class="line">--name mby1_gpt4_data \</span><br><span class="line">--gpus all \</span><br><span class="line">-v /home/mby/datatry:/home/datatry \</span><br><span class="line">-v /home/datas/SkyPile-150B:/home/SkyPile-150B:ro \</span><br><span class="line">gpuci/miniconda-cuda:11.3-devel-ubuntu20.04 \</span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">// mby（已关闭）</span><br><span class="line">docker run -it \</span><br><span class="line">--name mby \</span><br><span class="line">--gpus all \</span><br><span class="line">-p 6007:6007 \</span><br><span class="line">-p 9009:9009 \</span><br><span class="line">-v /home/mby/datatry:/home/datatry \</span><br><span class="line">-v /home/datas/SkyPile-150B:/home/SkyPile-150B:ro \</span><br><span class="line">gpuci/miniconda-cuda:11.3-devel-ubuntu20.04 \</span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">// mby2</span><br><span class="line">docker run -it \</span><br><span class="line">--name mby2 \</span><br><span class="line">--gpus all \</span><br><span class="line">-p 6007:6007 \</span><br><span class="line">-p 9009:9009 \</span><br><span class="line">-v /home/mby/datatry:/home/datatry \</span><br><span class="line">-v /home/ZhongYuLM:/home/ZhongYuLM \</span><br><span class="line">-v /home/datas/SkyPile-150B:/home/SkyPile-150B:ro \</span><br><span class="line">gpuci/miniconda-cuda:11.3-devel-ubuntu20.04 \</span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">// 做深度学习大作业使用(已关闭)</span><br><span class="line">docker run -it \</span><br><span class="line">--name mby_clip2 \</span><br><span class="line">--gpus all \</span><br><span class="line">-p 6008:6008 \</span><br><span class="line">-p 9010:9010 \</span><br><span class="line">--shm-size=8g \</span><br><span class="line">-v /home/mby/datatry:/home/datatry \</span><br><span class="line">-v /home/datas/SkyPile-150B:/home/SkyPile-150B:ro \</span><br><span class="line">mby_clip:latest \</span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker commit -a <span class="string">&#x27;mby&#x27;</span> -m <span class="string">&#x27;temp&#x27;</span> eb83d4d43913 mby_clip</span><br><span class="line"></span><br><span class="line">(base) root@localhost:/home<span class="comment"># docker commit -a &#x27;mby&#x27; -m &#x27;temp&#x27; eb83d4d43913 mby_clip</span></span><br><span class="line">sha256:32380fb3979650035bce0f5b7fb49e3c02a6040c146b17d3eeb83b6dcc8ce7c9</span><br><span class="line"></span><br><span class="line"><span class="built_in">df</span> -h | grep shm</span><br><span class="line"></span><br><span class="line">// 微调模型</span><br><span class="line">docker run -it \</span><br><span class="line">--name mby_qwen2 \</span><br><span class="line">--gpus all \</span><br><span class="line">-v /home/mby/test:/test/ \</span><br><span class="line">qwenllm/qwen:latest /bin/bash</span><br></pre></td></tr></table></figure><p>参数详解</p><p><a href="https://blog.csdn.net/wangshuai6707/article/details/132299930">https://blog.csdn.net/wangshuai6707/article/details/132299930</a></p><p>docker run -it –name mby_crop –gpus all -v &#x2F;home&#x2F;mby&#x2F;test:&#x2F;test&#x2F; gpuci&#x2F;miniconda-cuda:11.3-devel-ubuntu20.04 &#x2F;bin&#x2F;bash</p><h2 id="HuggingFace"><a href="#HuggingFace" class="headerlink" title="HuggingFace"></a>HuggingFace</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set HF_MIRROR_URL=https://huggingface.co.cn &amp;&amp; bash /workspace/LLaMA-Factory-main/utils/test_ppo_model/gsm8k.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget https://huggingface.co.cn</span><br><span class="line"></span><br><span class="line">huggingface-cli download bigcode/humanevalpack --repo-type dataset</span><br><span class="line">huggingface-cli scan-cache</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>小众问题：git提交记录太多了，想清空提交记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(1) 创建新分支</span><br><span class="line">git checkout --orphan newBranch</span><br><span class="line">(2) 添加所有文件</span><br><span class="line">git add -A</span><br><span class="line">(3) 提交跟踪过的文件</span><br><span class="line">git commit -am “init commit”</span><br><span class="line">(4) 删除master分支</span><br><span class="line">git branch -D master</span><br><span class="line">(5) 重命名当前分支为master</span><br><span class="line">git branch -m master</span><br><span class="line">(6) 重新指定远端</span><br><span class="line">git remote set-url origin http://xxx</span><br><span class="line">(7)</span><br><span class="line">git push -f origin master</span><br><span class="line"></span><br><span class="line">可选</span><br><span class="line">(8) github的setting中切换default为main，删除main</span><br><span class="line">github会提示，接着进行下面的操作：</span><br><span class="line">git branch -m master main</span><br><span class="line">git fetch origin</span><br><span class="line">git branch -u origin/main main</span><br><span class="line">git remote set-head origin -a</span><br></pre></td></tr></table></figure><h2 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h2><p>★在VirtualBox上安装ubuntu系统（20.04）</p><p>▲安装环境</p><p>想要安装开发工具软件包，以拥有 sudo 权限用户身份或者 root 身份运行下面的命令：</p><p>sudo apt update</p><p>sudo apt install build-essential</p><p>▲共享文件夹</p><p>设置共享文件夹路径（Windows系统的路径，如E:&#x2F;DataSets）和名称（挂载到Ubuntu系统中时候用的名称，如Win_DataSets）；勾选“固定分配”，其他不选。</p><p>sudo apt-get install virtualbox-guest-dkms（再次安装增强功能）</p><p>sudo adduser 用户名 vboxsf</p><p>sudo mkdir ~&#x2F;share</p><p>sudo mount -t vboxsf VMshare ~&#x2F;share</p><p>以上可以保证使用共享文件夹，但坏处在于每次开机都要执行一次这个指令。</p><p>再加上开机自动执行该指令</p><p>（暂未成功）</p><p>1.创建rc-local.service文件</p><p>sudo cp &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;rc-local.service &#x2F;etc&#x2F;systemd&#x2F;system</p><p>然后修改&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;rc-local.service，在文件最下方添加如下两行：</p><p>[Install]  </p><p>WantedBy&#x3D;multi-user.target  </p><p>Alias&#x3D;rc-local.service</p><p>2.创建rc.local文件</p><p>创建&#x2F;etc&#x2F;rc.local，里边写自己想要运行的命令。例：</p><p>#!&#x2F;bin&#x2F;sh</p><p>echo “This is test” &gt; &#x2F;tmp&#x2F;my.log</p><p>exit 0</p><p>给&#x2F;etc&#x2F;rc.local加上可执行权限 </p><p>sudo chmod +x &#x2F;etc&#x2F;rc.local</p><p>3.测试</p><p>重启虚拟机</p><p>启动后可以发现：&#x2F;tmp下已经有了my.log文件，里边内容为：”This is test”。</p><p>systemctl命令</p><p>启动服务</p><p>sudo systemctl start rc-local.service</p><p>查看服务状态</p><p>sudo systemctl status rc-local.service</p><p>▲换源</p><p>sudo mousepad &#x2F;etc&#x2F;apt&#x2F;sources.list</p><p>之后一定要sudo apt update</p><p>清华大学镜像地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p><p>▲添加右键打开终端</p><ol><li>sudo apt-get install nautilus-open-terminal</li><li>nautilus -q</li><li>nautilus &amp;</li></ol><p>▲14.04可以使用的源</p><p>deb <a href="http://old-releases.ubuntu.com/ubuntu">http://old-releases.ubuntu.com/ubuntu</a> precise main universe restricted multiverse</p><p>deb <a href="http://old-releases.ubuntu.com/ubuntu">http://old-releases.ubuntu.com/ubuntu</a> precise-security universe main multiverse restricted</p><p>deb <a href="http://old-releases.ubuntu.com/ubuntu">http://old-releases.ubuntu.com/ubuntu</a> precise-updates universe main multiverse restricted</p><p>deb <a href="http://old-releases.ubuntu.com/ubuntu">http://old-releases.ubuntu.com/ubuntu</a> precise-proposed universe main multiverse restricted</p><p>▲14.04配置网络</p><p>进入etc&#x2F;NetworkManager,找到 Networkmanager.conf文件</p><p>修改使managed&#x3D;true</p><p>cd.. 再cd  network</p><p>主要是修改static变成dhcp</p><p>但顺便配置一下地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The primary network interface</span>  </span><br><span class="line">auto eth0  #表示让网卡开机自动挂载eth0</span><br><span class="line">iface eth0 inet dhcp </span><br><span class="line">address 192.168.56.1  </span><br><span class="line">gateway 192.168.2.254  </span><br><span class="line">netmask 255.255.255.0  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">network 192.168.2.0</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">broadcast 192.168.2.255</span> </span><br></pre></td></tr></table></figure><p>即可联网</p><p>▲E: 您在 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F; 上没有足够的可用空间的解决方法。</p><p>要解决此问题，您可以按照以下步骤操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoclean</span><br></pre></td></tr></table></figure><p>这将删除当前未安装的所有软件包。如果那不能释放足够的空间，请使用<code>sudo apt-get clean</code>。这将清除所有<code>.debs</code>下载和&#x2F;或安装的内容。</p><p>▲切换默认终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --config x-terminal-emulator</span><br></pre></td></tr></table></figure><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>简明教程</p><p><a href="https://mp.weixin.qq.com/s/4rRoWG8PaBNdXwo8rTAklQ">https://mp.weixin.qq.com/s/4rRoWG8PaBNdXwo8rTAklQ</a></p><h3 id="1-anaconda使用"><a href="#1-anaconda使用" class="headerlink" title="1 anaconda使用"></a>1 anaconda使用</h3><p>▲1.1 navigator弹出.cli文件</p><p>navigator一直弹出vscode显示的.cli界面，解决方法是用管理员权限打开，就不会出现这个问题了</p><p>▲1.2 创建与进出虚拟环境（navigator&#x2F;prompt）</p><p>通过命令行创建虚拟环境(直接用navigator可视化创建也可以)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">conda create -n 虚拟环境名字 python=python版本 #创建虚拟环境</span><br><span class="line">conda activate 虚拟环境名字 #进入虚拟环境</span><br><span class="line">conda deactivate #退出虚拟环境</span><br><span class="line">conda remove -n 虚拟环境名字 --all #删除虚拟环境</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看帮助</span><br><span class="line">conda env --help    </span><br><span class="line">#查看已安环境</span><br><span class="line">conda env list                               #列出所有的虚拟环境</span><br><span class="line">conda list --name [虚拟环境名]            #查看指定虚拟环境下的package</span><br><span class="line">conda list --name base    # 查看默认主环境的package</span><br><span class="line">#创建</span><br><span class="line">conda create --name [虚拟环境名] [python的版本] [需要的包]</span><br><span class="line">eg:</span><br><span class="line">conda create --name myenv</span><br><span class="line">conda create --name myenv python=2.7</span><br><span class="line">conda create --name myenv pytohon=2.7 numpy scipy</span><br><span class="line">#克隆</span><br><span class="line">conda create --name [虚拟环境名] --clone [colne的环境]</span><br><span class="line">eg:</span><br><span class="line">conda create --name B --clone A  #创建一个和A环境一样的虚拟环境B</span><br><span class="line">conda create --name test3 --clone test2  # 克隆test2环境并命名为test3</span><br><span class="line">conda create --name pdf2doi --clone base #克隆主环境base并命名为pdf2doi</span><br><span class="line">#删除</span><br><span class="line">conda remove --name [虚拟环境名] -all</span><br><span class="line"># 激活/取消（默认的环境是base）</span><br><span class="line">conda activate [虚拟环境名]</span><br><span class="line">conda deactivate [虚拟环境名]</span><br></pre></td></tr></table></figure><p>▲1.3 以pytorch为例安装包</p><p>navigator的安装会出问题（说是版本不对）</p><p>可以用prompt的powershell（管理员模式）安装</p><p>从官网<a href="https://pytorch.org/%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C">https://pytorch.org/获取命令行</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cpuonly -c pytorch</span><br></pre></td></tr></table></figure><p>进入python3-11环境（conda activate），安装即可，正常会出现三个done，最后done结束安装。</p><p>▲1.4 安装pytorch-cuda</p><p>torch.cuda.is_available()若返回true则显卡可被使用</p><p>▲1.5安装第三方包的时候出错找不到</p><p>使用以下语句</p><p>原理：将<a href="https://so.csdn.net/so/search?q=conda-forge&spm=1001.2101.3001.7020">conda-forge</a>添加到系统默认的channel列表中，简单来说就是增加搜索路径，这样你在执行安装命令的时候就不仅仅在原来的channel目录中搜索，也会在新增的conda-forge channel中查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --append channels conda-forge</span><br></pre></td></tr></table></figure><p>▲1.6 添加源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.aliyun.com/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>▲1.7 pycharm使用anaconda环境</p><p>设置-python解释器-添加一个配置好的anaconda环境</p><p>注意：由于版本问题，不要使用conda环境那个选项，选用第三项“系统解释器”，然后找到环境的exe</p><p>对于环境名称python3-11，有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\\anaconda\envs\python3-11\python.exe</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_45659165/article/details/125851282?ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDgwMTc3P3R5cGU9bGF0ZWx5">https://blog.csdn.net/qq_45659165/article/details/125851282?ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDgwMTc3P3R5cGU9bGF0ZWx5</a></p><p>导出当前环境依赖包信息</p><p>pip freeze &gt; .&#x2F;requirements.txt </p><p>★安装软件包</p><p>在terminal终端，而不是python控制台</p><p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> +自己需要的包</p><h3 id="2-python自动化：pyautogui"><a href="#2-python自动化：pyautogui" class="headerlink" title="2 python自动化：pyautogui"></a>2 python自动化：pyautogui</h3><p>▲2.1GUI 控制功能</p><p>控制鼠标键盘使用的模块为：pyautogui，这个模块操作起鼠标键盘的时候，非常的迅速，而且如果该模块控制了鼠标后，程序比较难关闭，这时我们有两个方法专门针对以上的情况：</p><p>2.1.1 自动 防故障功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.FAILSAFE =False </span><br></pre></td></tr></table></figure><p>默认这项功能为True, 这项功能意味着：当鼠标的指针在屏幕的左上角，程序会报错；目的是为了防止程序无法停止；</p><p>2.1.2 停顿功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.PAUSE = 1 </span><br></pre></td></tr></table></figure><p>意味着所有pyautogui的指令都要暂停一秒；其他指令不会停顿；这样做，可以防止键盘鼠标操作太快；</p><p>▲2.2鼠标操作</p><p>（1）控制鼠标移动</p><p>获得屏幕分辨率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(pyautogui.size())   # 返回所用显示器的分辨率； 输出：Size(width=1920, height=1080)</span><br><span class="line">width,height = pyautogui.size()</span><br><span class="line">print(width,height)  # 1920 1080</span><br></pre></td></tr></table></figure><p>移动鼠标</p><p>移动到指定位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.moveTo(100,300,duration=1)</span><br></pre></td></tr></table></figure><p>将鼠标移动到指定的坐标；duration 的作用是设置移动时间，所有的gui函数都有这个参数，而且都是可选参数；</p><p>按方向移动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.moveRel(100,500,duration=4)   # 第一个参数是左右移动像素值，第二个是上下，</span><br></pre></td></tr></table></figure><p>向右移动100px，向下移动500px, 这个过程持续 1 秒钟；</p><p>获取鼠标位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pyautogui.position())   # 得到当前鼠标位置</span><br></pre></td></tr></table></figure><p>输出：Point(x&#x3D;200, y&#x3D;800)</p><p>（2）控制鼠标点击</p><p>单击鼠标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.click(10,10)   # 鼠标点击指定位置，默认左键</span><br><span class="line">pyautogui.click(10,10,button=&#x27;left&#x27;)  # 单击左键</span><br><span class="line">pyautogui.click(1000,300,button=&#x27;right&#x27;)  # 单击右键</span><br><span class="line">pyautogui.click(1000,300,button=&#x27;middle&#x27;)  # 单击中间</span><br></pre></td></tr></table></figure><p>双击鼠标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.doubleClick(10,10)  # 指定位置，双击左键</span><br><span class="line">pyautogui.rightClick(10,10)   # 指定位置，双击右键</span><br><span class="line">pyautogui.middleClick(10,10)  # 指定位置，双击中键</span><br></pre></td></tr></table></figure><p>点击 &amp; 释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.mouseDown()   # 鼠标按下</span><br><span class="line">pyautogui.mouseUp()    # 鼠标释放</span><br></pre></td></tr></table></figure><p>（3）控制鼠标拖动</p><p>拖动到指定位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.dragTo(100,300,duration=1) </span><br></pre></td></tr></table></figure><p>将鼠标拖动到指定的坐标；duration 的作用是设置移动时间，所有的gui函数都有这个参数，而且都是可选参数；</p><p>按方向拖动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.dragRel(100,500,duration=4)   # 第一个参数是左右移动像素值，第二个是上下，</span><br></pre></td></tr></table></figure><p>向右拖动100px，向下拖动500px, 这个过程持续 1 秒钟；</p><p>（4）控制鼠标滚动</p><p>控制鼠标滚动的函数是scroll()， 传入一个整数的参数，说明向上或向下滚动多少个单位；单位根据操作系统不同而不同；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.scroll(300)  # 向上滚动300个单位；</span><br></pre></td></tr></table></figure><p>▲2.3屏幕处理</p><p>（1）获取屏幕截图</p><p>我们控制鼠标的操作，不能盲目的进行，所以我们需要监控屏幕上的内容，从而决定要不要进行对应的操作， pyautogui 提供了一个方法screenshot()，可以返回一个Pillow的image对象；</p><p>这里有三个常用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">im = pyautogui.screenshot()：返回屏幕的截图，是一个Pillow的image对象</span><br><span class="line">im.getpixel((500, 500))：返回im对象上，（500，500）这一点像素的颜色，是一个RGB元组</span><br><span class="line">pyautogui.pixelMatchesColor(500,500,(12,120,400)) ：是一个对比函数，对比的是屏幕上（500，500）这一点像素的颜色，与所给的元素是否相同；</span><br></pre></td></tr></table></figure><p>保存屏幕截图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = pyautogui.screenshot()</span><br><span class="line">im.save(&#x27;屏幕截图.png&#x27;)</span><br></pre></td></tr></table></figure><p>（2） 识别图像</p><p>首先，我们需要先获得一个屏幕快照，例如我们想要点赞，我们就先把大拇指的图片保存下来；然后使用函数：locateOnScreen(‘zan.png’) ，如果可以找到图片，则返回图片的位置，如：Box(left&#x3D;25, top&#x3D;703, width&#x3D;22, height&#x3D;22)；如果找不到图片，则返回None;<br>如果，屏幕上有多处图片可以匹配，则需要使用locateAllOnScreen(‘zan.png’) ，如果匹配到多个值，则返回一个list，参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pyautogui</span><br><span class="line">pyautogui.PAUSE = 1</span><br><span class="line">#图像识别一个</span><br><span class="line">btm = pyautogui.locateOnScreen(&#x27;zan.png&#x27;)</span><br><span class="line">print(btm)  # Box(left=1280, top=344, width=22, height=22)</span><br><span class="line"></span><br><span class="line">#图像识别多个</span><br><span class="line">btm = pyautogui.locateAllOnScreen(&#x27;zan.png&#x27;)</span><br><span class="line">print(list(btm))  # [Box(left=1280, top=344, width=22, height=22), Box(left=25, top=594, width=22, height=22)]</span><br><span class="line"></span><br><span class="line">pyautogui.center((left, top, width, height)) 返回指定位置的中心点；这样，我们就可以再配合鼠标操作点击找到图片的中心</span><br></pre></td></tr></table></figure><p>▲2.4键盘输入</p><p>（1）键盘输入函数</p><p>pyautogui.keyDown() ： 模拟按键按下；<br>pyautogui.keyUp() ： 模拟按键释放；<br>pyautogui.press() ： # 就是调用keyDown() &amp; keyUp(),模拟一次按键；<br>pyautogui.typewrite(‘this’,0.5) ： 第一参数是输入内容，第二个参数是每个字符间的间隔时间；<br>pyautogui.typewrite([‘T’,’h’,’i’,’s’])：typewrite 还可以传入单字母的列表；</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.keyDown(&#x27;shift&#x27;)    # 按下shift</span><br><span class="line">pyautogui.press(&#x27;4&#x27;)    # 按下 4</span><br><span class="line">pyautogui.keyUp(&#x27;shift&#x27;)   # 释放 shift</span><br></pre></td></tr></table></figure><p>输出： $ ；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.typewrite(&#x27;$$$$&#x27;, 0.5)</span><br></pre></td></tr></table></figure><p>缓慢的输出：</p><p>（2）键盘特殊按键</p><p>有时我们需要输入一些特殊的按键，比如向左的箭头，这些有相对应的键盘字符串表示，例如：</p><p>pyautogui.typewrite([‘T’,’i’,’s’,’left’,’left’,’h’,])   # 输出：This<br>1<br>解释：这里的left就是向左的箭头；诸如此类的键盘字符串，还有很多，参考下表：</p><p>键盘字符串说明<br>enter(或return 或 \n)回车<br>escESC键<br>shiftleft, shiftright左右SHIFT键<br>altleft, altright左右ALT键<br>ctrlleft, ctrlright左右CTRL键<br>tab (\t)TAB键<br>backspace, deleteBACKSPACE 、DELETE键<br>pageup, pagedownPAGE UP 和 PAGE DOWN键<br>home, endHOME 和 END键<br>up, down, left,right箭头键<br>f1, f2, f3…. f12F1…….F12键<br>volumemute, volumedown,volumeup声音变大变小静音（有些键盘没有）<br>pausePAUSE键，暂停键<br>capslockCAPS LOCK 键<br>numlockNUM LOCK 键<br>scrolllockSCROLLLOCK 键<br>insertINSERT键<br>printscreenPRINT SCREEN键<br>winleft, winrightWin键（windows ）<br>commandcommand键（Mac OS X ）<br>optionoption（Mac OS X）</p><p>（3）快捷键</p><p>如果我们需要模拟复制的快捷键 ctrl + c ，如果用前面的方法，则代码为：</p><p>pyautogui.keyDown(‘ctrl’)<br>pyautogui.keyDown(‘c’)<br>pyautogui.keyUp(‘c’)<br>pyautogui.keyUp(‘ctrl’)<br>快捷键的按键与释放顺序非常关键，这时我们可以使用 pyautogui.hotkey()，这个函数可以接受多个参数，按传入顺序按下，再按照相反顺序释放。上述快捷键 ctrl + c ，可以将代码变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyautogui.hotkey(&#x27;ctrl&#x27;,&#x27;c&#x27;)</span><br></pre></td></tr></table></figure><p>▲2.5提示信息框</p><p>（1）提示框&#x2F;警告框</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pyautogui</span><br><span class="line">a = pyautogui.alert(text=&#x27;This is an alert box.&#x27;, title=&#x27;Test&#x27;)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出如下图：点击确定，返回值为‘OK’</p><p>（2）选择框</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pyautogui</span><br><span class="line">a = pyautogui.confirm(&#x27;选择一项&#x27;, buttons=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出如下图：点击B选项，返回值为‘B’</p><p>（3）密码输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pyautogui</span><br><span class="line">a = pyautogui.password(&#x27;Enter password (text will be hidden)&#x27;)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出如下图：输入密码，显示为密文，点击OK，返回值为刚刚输入的值；</p><p>（4）普通输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pyautogui</span><br><span class="line">a = pyautogui.prompt(&#x27;请输入一个数字：&#x27;)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出如下图：显示为明文，点击OK，返回值为刚刚输入的值；</p><h3 id="★3-pytorch使用"><a href="#★3-pytorch使用" class="headerlink" title="★3 pytorch使用"></a>★3 pytorch使用</h3><p>全部转化为tensor格式</p><h3 id="★4-lightning的使用"><a href="#★4-lightning的使用" class="headerlink" title="★4 lightning的使用"></a>★4 lightning的使用</h3><p><a href="https://zhuanlan.zhihu.com/p/659631467">https://zhuanlan.zhihu.com/p/659631467</a></p><h3 id="安装cuda"><a href="#安装cuda" class="headerlink" title="安装cuda"></a>安装cuda</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/601368710">https://zhuanlan.zhihu.com/p/601368710</a></p><p>本机驱动版本：517.47，查询得最高可装CUDA 11.7</p><p>查询NVIDA官网：<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#</a></p><p>安装链接：<a href="https://developer.nvidia.com/cuda-11-7-1-download-archive?target_os=Windows&target_arch=x86_64&target_version=10&target_type=exe_local">https://developer.nvidia.com/cuda-11-7-1-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local</a></p><p>Graphviz安装配置好后无法import的问题</p><p>进入到Prompt中pip install graphviz就可以了！</p><p><a href="https://blog.csdn.net/weixin_45956028/article/details/113621632">https://blog.csdn.net/weixin_45956028/article/details/113621632</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CCSP</title>
      <link href="/2024/10/25/CCSP/"/>
      <url>/2024/10/25/CCSP/</url>
      
        <content type="html"><![CDATA[<p> 小蒟蒻前两天参加了CCSP2024</p><img src="/2024/10/25/CCSP/CCSP-1.png" class="" title="CCSP-2024"><p>最终幸运蹭铜（蹭着本科的边边捞到了铜牌，没有遗憾了）。</p><img src="/2024/10/25/CCSP/CCSP-2.png" class="" title="最终分数板"><h2 id="评价感受"><a href="#评价感受" class="headerlink" title="评价感受"></a>评价感受</h2><p>本来只是来打酱油（蹭吃蹭喝）的，因为自从推免结束后，已经正好一个月没碰代码了，上一次碰代码还是参加某学校的机考。但是编程这个东西很神奇，不管你多久没碰代码，一看到题目就突然会了，还是能比划比划的。于是上来20分钟直接贪心算法（我不会别的算法了），先AC了第一道题。之后又试了试贝壳统计，发现前10个点数据量很小，并且操作简单，完全可以暴力解决，故一番尝试之后先把这题拿了40分。</p><img src="/2024/10/25/CCSP/CCSP-3.png" class="" title="前一个半小时就拿到了140分"><p>此时时间过去了一个半小时，我又看了看数树，发现这道题逻辑很清晰，三个层次的数据点，前两个层次只要把树模拟出来就可以很轻易地得分，故我就先拿到了这55分。此时已经12点过了，比赛过了3小时，拿到了195分。</p><img src="/2024/10/25/CCSP/CCSP-4.png" class="" title="午饭前拿到195分"><p>正好吃一下午饭，收拾收拾心情。午饭没有拍照（没有手机），但感觉还是可以的，盒饭，还发了个香蕉。午饭结束后我感觉数树的后面45分有个旋转，当时潜意识里感觉没那么容易，于是就先放一放。开始开系统题（也就是超级大模拟），这一开不要紧，直接写了4个小时的bitTorent服务器，要求实现接受6个指令并做出反应，我感觉最低的得分门槛大概涵盖了70%的工作量，但只有30分，但一旦实现了这个最低门槛，再往上拿分就比较容易了。很遗憾，我写了四个小时没有写出来，没有通过这个最低门槛。后来看到似乎这个最低门槛还是与未要求的指令有关系，这个就不知道了。中途又对贝壳统计改进了又交了一发还是没有提升。此时已经到了晚上五点半，天黑了。等于是我一个下午一分都没有拿，心态有点炸。打开排行榜一看，发现自己已经掉出了铜奖线，遂没有什么别的想法，开始摆烂。正好又来了盒饭，故事已至此，先吃饭吧。</p><p>边吃饭边看前面的题目，想再捞点分。发现数树的最后一部分其实还好，没有想象的那么难。边吃边想，想的差不多了就看最后一道系统题，发现前两个得分点还是比较简单的。遂定下方针，先把数树拿到，再最后一道系统题捞20分，就是赚了。如果这个策略能成真，那估计就有260，可能有铜奖了。</p><p>饭后敲了半个小时，直接提交，数树AC了，此时已经六点半了，我AC了第二道题。这45分一加，效果很显著，直接跳到了铜奖中间的位置，240分。</p><img src="/2024/10/25/CCSP/CCSP-5.png" class="" title="晚饭后拿到240分"><p>然后做最后一道系统题，本来以为能捞20分的，结果只拿到10分，此时已经七点了，先尝试找bug，找了半个小时没找到，又试试别的题，之后就没有任何进展了。</p><p>临结束的时候交了一发贝壳统计，换了一种思路，当时没立刻出结果，后来看到还是TLE，那就没办法了，就这样吧。事后发现，如果这个拿满，还是可能银牌的，呵呵。</p><img src="/2024/10/25/CCSP/CCSP-6.png" class="" title="结束时拿到250分"><p>全过程跌宕起伏吧，从一开始的无所谓，到发现自己还是有点希望的，再到跌出铜奖线，开始摆烂，然后又绝处逢生，再到最后实在找不出bug了，就这样潦草画上句点。</p><p>总的来说我还是非常幸运的。感谢勇于尝试的自己。</p><h2 id="金银铜奖情况"><a href="#金银铜奖情况" class="headerlink" title="金银铜奖情况"></a>金银铜奖情况</h2><p>金奖靠前ranklist（全都是大佬）</p><p>第一名是在封榜前AK的，真的是非常厉害</p><img src="/2024/10/25/CCSP/CCSP-7.png" class="" title="金奖前几名的得分情况"><p>金奖线（365）</p><img src="/2024/10/25/CCSP/CCSP-8.png" class="" title="金银分界线"><p>银奖线（300）</p><img src="/2024/10/25/CCSP/CCSP-9.png" class="" title="银铜分界线"><p>铜奖线（240靠前）</p><p>只有时间较早拿到240的同学才有铜奖</p><h2 id="题目与解答"><a href="#题目与解答" class="headerlink" title="题目与解答"></a>题目与解答</h2><p>部分题目不会，没答上来。</p><h3 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h3><p>AC代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        q.<span class="built_in">push</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag1,flag2;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;q.top();</span></span><br><span class="line">        <span class="comment">// q.pop();</span></span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (t2&lt;t1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &gt; t2) t2=now+<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> t2+=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (now &gt; t1) t1=now+<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> t1+=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t1&gt;t2) <span class="built_in">swap</span>(t1,t2);</span><br><span class="line">    cout&lt;&lt;t1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;t2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h3><p>40分代码（仅完成1-10数据点）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;=<span class="number">10000</span> &amp;&amp; m&lt;=<span class="number">10000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> op,a,b;</span><br><span class="line">            cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span> (op==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// set&lt;int&gt; s;</span></span><br><span class="line">                <span class="comment">// for (int i=a-1; i&lt;=b-1; i++)</span></span><br><span class="line">                <span class="comment">// &#123;</span></span><br><span class="line">                <span class="comment">//     int now = v[i];</span></span><br><span class="line">                <span class="comment">//     if (s.find(now) == s.end())</span></span><br><span class="line">                <span class="comment">//     &#123;</span></span><br><span class="line">                <span class="comment">//         sum++;</span></span><br><span class="line">                <span class="comment">//         s.insert(now);</span></span><br><span class="line">                <span class="comment">//     &#125;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="type">bool</span> ntemp[<span class="number">20000</span>];</span><br><span class="line">                <span class="built_in">memset</span>(ntemp,<span class="number">0</span>,<span class="built_in">sizeof</span>(ntemp));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=a<span class="number">-1</span>; i&lt;=b<span class="number">-1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> now = v[i];</span><br><span class="line">                    <span class="keyword">if</span> (ntemp[now] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum++;</span><br><span class="line">                        ntemp[now] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v[a<span class="number">-1</span>] = b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>()+a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">        <span class="type">bool</span> ntemp[<span class="number">200000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(ntemp,<span class="number">0</span>,<span class="built_in">sizeof</span>(ntemp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ntemp[v[i]] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ntemp[v[i]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;mp[v[i]].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(mp[v[i]][j]);</span><br><span class="line">                mp[v[i]].<span class="built_in">push_back</span>(mp[v[i]][j]);&#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x : temp) mp[x].<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> op,a,b;</span><br><span class="line">            cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span> (op==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x : mp)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (x.first&gt;=a &amp;&amp; x.first&lt;=b)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span> y : x.second)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (y&gt;=a &amp;&amp; y&lt;=b) count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count /= <span class="number">2</span>;</span><br><span class="line">                    count --;</span><br><span class="line">                    sum+=count;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;b-a+<span class="number">1</span>-sum&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v[a<span class="number">-1</span>] = b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>()+a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h3><p>AC代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findnum</span><span class="params">(vector&lt;node&gt; &amp;list, <span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list[u].child.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[u].data &gt; v) ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list[u].child.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += <span class="built_in">findnum</span>(list,list[u].child[i],v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list[u].data &gt; v) ret += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findmax</span><span class="params">(vector&lt;node&gt; &amp;list, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list[u].child.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        maxnum = <span class="built_in">max</span>(list[u].data, maxnum); </span><br><span class="line">        <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list[u].child.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxnum = <span class="built_in">max</span>(maxnum, <span class="built_in">findmax</span>(list,list[u].child[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxnum, list[u].data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findmin</span><span class="params">(vector&lt;node&gt; &amp;list, <span class="type">int</span> u, <span class="type">int</span>&amp; minvalue, <span class="type">int</span>&amp; minnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list[u].child.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list[u].child.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">findmin</span>(list, list[u].child[i], minvalue, minnum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list[u].data &lt; minvalue)</span><br><span class="line">    &#123;</span><br><span class="line">        minnum = u;</span><br><span class="line">        minvalue = list[u].data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (list[u].data == minvalue &amp;&amp; u&lt;minnum)</span><br><span class="line">    &#123;</span><br><span class="line">        minnum = u;</span><br><span class="line">        minvalue = list[u].data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;node&gt; &amp;list, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list[u].parent == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">rotate</span>(list, list[u].parent);</span><br><span class="line">    <span class="type">int</span> parentnum = list[u].parent;</span><br><span class="line">    <span class="keyword">auto</span> childpos = <span class="built_in">find</span>(list[parentnum].child.<span class="built_in">begin</span>(), list[parentnum].child.<span class="built_in">end</span>(), u);</span><br><span class="line">    list[parentnum].child.<span class="built_in">erase</span>(childpos);</span><br><span class="line">    list[parentnum].parent = u;</span><br><span class="line">    list[u].parent = <span class="number">-1</span>;</span><br><span class="line">    list[u].child.<span class="built_in">push_back</span>(parentnum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;node&gt; list;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node newnode;</span><br><span class="line">        newnode.parent = <span class="number">-1</span>;</span><br><span class="line">        list.<span class="built_in">push_back</span>(newnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        u--;</span><br><span class="line">        v--;</span><br><span class="line">        list[u].child.<span class="built_in">push_back</span>(v);</span><br><span class="line">        list[v].parent = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        list[i].data = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> DEBUG =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;index = &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; value = &quot;</span>&lt;&lt;list[i].data&lt;&lt;<span class="string">&quot; | &quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;list[i].child.<span class="built_in">size</span>(); j++) cout&lt;&lt;list[i].child[j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            u ^= last;</span><br><span class="line">            v ^= last;</span><br><span class="line">            u--;</span><br><span class="line">            last = <span class="built_in">findnum</span>(list,u,v);</span><br><span class="line">            cout&lt;&lt;last&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            u ^= last;</span><br><span class="line">            v ^= last;</span><br><span class="line">            u--;</span><br><span class="line">            list[u].data = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            u ^= last;</span><br><span class="line">            v ^= last;</span><br><span class="line">            u--;</span><br><span class="line">            <span class="type">int</span> now = list.<span class="built_in">size</span>();</span><br><span class="line">            node newnode;</span><br><span class="line">            list.<span class="built_in">push_back</span>(newnode);</span><br><span class="line">            list[now].data = v;</span><br><span class="line">            list[u].child.<span class="built_in">push_back</span>(now);</span><br><span class="line">            list[now].parent = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;u;</span><br><span class="line">            u ^= last;</span><br><span class="line">            u--;</span><br><span class="line">            <span class="type">int</span> parent = list[u].parent;</span><br><span class="line">            list[parent].child.<span class="built_in">erase</span>(<span class="built_in">find</span>(list[parent].child.<span class="built_in">begin</span>(),list[parent].child.<span class="built_in">end</span>(),u));</span><br><span class="line">            list[u].parent = <span class="number">-1</span>;</span><br><span class="line">            last = <span class="built_in">findmax</span>(list,u);</span><br><span class="line">            cout&lt;&lt;last&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;u;</span><br><span class="line">            u ^= last;</span><br><span class="line">            u--;</span><br><span class="line">            <span class="type">int</span> minvalue = <span class="number">9999999</span>;</span><br><span class="line">            <span class="type">int</span> minnum = <span class="number">99999</span>;</span><br><span class="line">            <span class="built_in">findmin</span>(list, u, minvalue, minnum);</span><br><span class="line">            last = minnum + <span class="number">1</span>;</span><br><span class="line">            cout&lt;&lt;last&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            cin&gt;&gt;u;</span><br><span class="line">            u ^= last;</span><br><span class="line">            u--;</span><br><span class="line">            <span class="built_in">rotate</span>(list,u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h3><p>10分代码（只完成数据点1）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CREATE_Proc pid load</span></span><br><span class="line"><span class="comment">// DESTROY_Thread tid</span></span><br><span class="line"><span class="comment">// CREATE_Thread pid tid load</span></span><br><span class="line"><span class="comment">// SCHEDULE_OPT</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; tidref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pnode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> load;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; threadlist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,pnode&gt; plist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="built_in">getline</span>(cin,str);</span><br><span class="line">        stringstream ss;</span><br><span class="line">        ss &lt;&lt; str;</span><br><span class="line">        string op;</span><br><span class="line">        vector&lt;string&gt; envlist;</span><br><span class="line">        ss &gt;&gt; op;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; temp)</span><br><span class="line">        &#123;</span><br><span class="line">            envlist.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;CREATE_Proc&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// CREATE_Proc pid load</span></span><br><span class="line">            <span class="type">int</span> pid = <span class="built_in">stoi</span>(envlist[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> load = <span class="built_in">stoi</span>(envlist[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (plist.<span class="built_in">find</span>(pid) != plist.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            pnode newnode;</span><br><span class="line">            newnode.pid = pid;</span><br><span class="line">            newnode.load = load;</span><br><span class="line">            newnode.threadlist.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(pid,load));</span><br><span class="line">            tidref.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(pid,pid));</span><br><span class="line">            plist.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(pid,newnode));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;CREATE_Thread&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// CREATE_Thread pid tid load</span></span><br><span class="line">            <span class="type">int</span> pid = <span class="built_in">stoi</span>(envlist[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> tid = <span class="built_in">stoi</span>(envlist[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> load = <span class="built_in">stoi</span>(envlist[<span class="number">2</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (plist.<span class="built_in">find</span>(tid) != plist.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> pos = plist.<span class="built_in">find</span>(pid);</span><br><span class="line">            <span class="keyword">if</span> (pos != plist.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                pos-&gt;second.threadlist.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(tid,load));</span><br><span class="line">                tidref.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(tid,pid));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;DESTROY_Thread&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// DESTROY_Thread tid</span></span><br><span class="line">            <span class="type">int</span> tid = <span class="built_in">stoi</span>(envlist[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tidref.<span class="built_in">find</span>(tid) == tidref.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> pid = tidref[tid]; </span><br><span class="line">            plist[pid].threadlist.<span class="built_in">erase</span>(tid);</span><br><span class="line">            tidref.<span class="built_in">erase</span>(tid);</span><br><span class="line">            <span class="keyword">if</span> (plist[pid].threadlist.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                plist.<span class="built_in">erase</span>(pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;SCHEDULE_OPT&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SCHEDULE_OPT</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x : plist)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> y : x.second.threadlist)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;Process (PID): &quot;</span>&lt;&lt;x.first&lt;&lt;<span class="string">&quot; Thread(Tid): &quot;</span>&lt;&lt;y.first&lt;&lt;<span class="string">&quot; Load: &quot;</span>&lt;&lt;y.second&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Contention Cost: 0&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h3><p>题面太长，不放了。这道题足足写了4个小时，但还是0分，很难受。</p><img src="/2024/10/25/CCSP/CCSP-11.png" class="" title="整整写了4个小时"><p>0分代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> my_leecher pos-&gt;second.leecher</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> my_seeder pos-&gt;second.seeder</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DEBUG = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">usernode</span></span><br><span class="line">&#123;</span><br><span class="line">    string peer_id;</span><br><span class="line">    string ip;</span><br><span class="line">    string port;</span><br><span class="line">    <span class="type">int</span> uploaded;</span><br><span class="line">    <span class="type">int</span> downloaded;</span><br><span class="line">    <span class="built_in">usernode</span>(string peer_id, string ip, string port, <span class="type">int</span> uploaded, <span class="type">int</span> downloaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;peer_id = peer_id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ip = ip;</span><br><span class="line">        <span class="keyword">this</span>-&gt;port = port;</span><br><span class="line">        <span class="keyword">this</span>-&gt;uploaded = uploaded;</span><br><span class="line">        <span class="keyword">this</span>-&gt;downloaded = downloaded;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seednode</span></span><br><span class="line">&#123;</span><br><span class="line">    string info_hash;</span><br><span class="line">    string status;</span><br><span class="line">    map&lt;string,usernode&gt; seeder;</span><br><span class="line">    map&lt;string,usernode&gt; leecher;</span><br><span class="line">    <span class="type">int</span> complete;</span><br><span class="line">    <span class="type">int</span> incomplete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;string,seednode&gt; seedlist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_seeder</span><span class="params">(usernode&amp; a, usernode&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.uploaded &gt; b.uploaded) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.uploaded &lt; b.uploaded) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.peer_id &lt; b.peer_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_leecher</span><span class="params">(usernode&amp; a, usernode&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.downloaded &gt; b.downloaded) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.downloaded &lt; b.downloaded) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.peer_id &lt; b.peer_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">add</span><span class="params">(map&lt;string,seednode&gt;&amp; seedlist, vector&lt;string&gt;&amp; envlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string info_hash = envlist[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (seedlist.<span class="built_in">find</span>(info_hash) == seedlist.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        seednode newseed;</span><br><span class="line">        newseed.info_hash = info_hash;</span><br><span class="line">        seedlist.<span class="built_in">insert</span>(&#123;info_hash,newseed&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ERROR: Torrent already exists&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">del</span><span class="params">(map&lt;string,seednode&gt;&amp; seedlist, vector&lt;string&gt;&amp; envlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string info_hash = envlist[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    map&lt;string,seednode&gt;::iterator now = seedlist.<span class="built_in">find</span>(info_hash);</span><br><span class="line">    <span class="keyword">if</span> (now != seedlist.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="comment">// if () in use</span></span><br><span class="line">        <span class="keyword">if</span> (now-&gt;second.status == <span class="string">&quot;FROZEN&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;FROZEN&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            seedlist.<span class="built_in">erase</span>(now);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ERROR: Invalid info_hash&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">annoounce</span><span class="params">(vector&lt;string&gt;&amp; envlist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// announce </span></span><br><span class="line">    <span class="comment">// INFO_HASH=INFO-000000000000002 </span></span><br><span class="line">    <span class="comment">// PEER_ID=PEER-00000000000000D </span></span><br><span class="line">    <span class="comment">// IP=192.168.3.4 </span></span><br><span class="line">    <span class="comment">// PORT=5204 </span></span><br><span class="line">    <span class="comment">// UPLOADED=1200 </span></span><br><span class="line">    <span class="comment">// DOWNLOADED=300 </span></span><br><span class="line">    <span class="comment">// NUMWANT=3 </span></span><br><span class="line">    <span class="comment">// EVENT=completed</span></span><br><span class="line">    string info_hash = envlist[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    string peer_id = envlist[<span class="number">1</span>].<span class="built_in">substr</span>(<span class="number">8</span>,<span class="number">20</span>);</span><br><span class="line">    string ip = envlist[<span class="number">2</span>].<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">    string port = envlist[<span class="number">3</span>].<span class="built_in">substr</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> uploaded = <span class="built_in">stoi</span>(envlist[<span class="number">4</span>].<span class="built_in">substr</span>(<span class="number">9</span>));</span><br><span class="line">    <span class="type">int</span> downloaded = <span class="built_in">stoi</span>(envlist[<span class="number">5</span>].<span class="built_in">substr</span>(<span class="number">11</span>));</span><br><span class="line">    string temp = envlist[<span class="number">6</span>].<span class="built_in">substr</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="type">int</span> numwant;</span><br><span class="line">    <span class="keyword">if</span> (temp==<span class="string">&quot;&quot;</span>) numwant = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">else</span> numwant = <span class="built_in">stoi</span>(envlist[<span class="number">6</span>].<span class="built_in">substr</span>(<span class="number">8</span>));</span><br><span class="line">    string event = envlist[<span class="number">7</span>].<span class="built_in">substr</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if (DEBUG) cout&lt;&lt;&quot;DEBUG*****&quot;&lt;&lt;endl&lt;&lt;info_hash&lt;&lt;endl&lt;&lt;peer_id&lt;&lt;endl&lt;&lt;ip&lt;&lt;endl&lt;&lt;port&lt;&lt;endl&lt;&lt;uploaded&lt;&lt;endl&lt;&lt;downloaded&lt;&lt;endl&lt;&lt;numwant&lt;&lt;endl&lt;&lt;event&lt;&lt;endl&lt;&lt;&quot;*****DEBUG&quot;&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pos = seedlist.<span class="built_in">find</span>(info_hash);</span><br><span class="line">    <span class="keyword">if</span> (pos != seedlist.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//auto my_seeder = pos-&gt;second.seeder;</span></span><br><span class="line">        <span class="keyword">auto</span> seeder_pos = my_seeder.<span class="built_in">find</span>(peer_id);</span><br><span class="line">        <span class="comment">//auto my_leecher = pos-&gt;second.leecher;</span></span><br><span class="line">        <span class="keyword">auto</span> leecher_pos = my_leecher.<span class="built_in">find</span>(peer_id);</span><br><span class="line">        string user_status = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function">usernode <span class="title">newnode</span><span class="params">(peer_id, ip, port, uploaded, downloaded)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) cout&lt;&lt;<span class="string">&quot;AAAAA&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) cout&lt;&lt;<span class="string">&quot;now info_hash:&quot;</span>&lt;&lt;info_hash&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;cout&lt;&lt;<span class="string">&quot;leecher:&quot;</span>; <span class="keyword">for</span> (<span class="keyword">auto</span> x : my_leecher) cout&lt;&lt;x.first&lt;&lt;<span class="string">&quot; &quot;</span>; cout&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;cout&lt;&lt;<span class="string">&quot;seed:&quot;</span>; <span class="keyword">for</span> (<span class="keyword">auto</span> x : my_seeder) cout&lt;&lt;x.first&lt;&lt;<span class="string">&quot; &quot;</span>; cout&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event == <span class="string">&quot;started&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (seeder_pos != my_seeder.<span class="built_in">end</span>()) my_seeder.<span class="built_in">erase</span>(seeder_pos);</span><br><span class="line">            <span class="keyword">if</span> (leecher_pos == my_leecher.<span class="built_in">end</span>()) my_leecher.<span class="built_in">insert</span>(&#123;peer_id,newnode&#125;);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                leecher_pos-&gt;second.downloaded = downloaded;</span><br><span class="line">                leecher_pos-&gt;second.uploaded = uploaded;</span><br><span class="line">            &#125;</span><br><span class="line">            user_status = <span class="string">&quot;leecher&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (event == <span class="string">&quot;completed&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (leecher_pos != my_leecher.<span class="built_in">end</span>()) my_leecher.<span class="built_in">erase</span>(leecher_pos);</span><br><span class="line">            <span class="keyword">if</span> (seeder_pos == my_seeder.<span class="built_in">end</span>()) my_seeder.<span class="built_in">insert</span>(&#123;peer_id,newnode&#125;);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                seeder_pos-&gt;second.downloaded = downloaded;</span><br><span class="line">                seeder_pos-&gt;second.uploaded = uploaded;</span><br><span class="line">            &#125;</span><br><span class="line">            user_status = <span class="string">&quot;seeder&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (event == <span class="string">&quot;stopped&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (seeder_pos != my_seeder.<span class="built_in">end</span>()) my_seeder.<span class="built_in">erase</span>(seeder_pos);</span><br><span class="line">            <span class="keyword">if</span> (leecher_pos != my_leecher.<span class="built_in">end</span>()) my_leecher.<span class="built_in">erase</span>(leecher_pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (event == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> complete = my_seeder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> incomplete = my_leecher.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) cout&lt;&lt;<span class="string">&quot;now info_hash:&quot;</span>&lt;&lt;info_hash&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) cout&lt;&lt;<span class="string">&quot;complete:&quot;</span>&lt;&lt;complete&lt;&lt;endl&lt;&lt;<span class="string">&quot;incomplete:&quot;</span>&lt;&lt;incomplete&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;cout&lt;&lt;<span class="string">&quot;leecher:&quot;</span>; <span class="keyword">for</span> (<span class="keyword">auto</span> x : my_leecher) cout&lt;&lt;x.first&lt;&lt;<span class="string">&quot; &quot;</span>; cout&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;cout&lt;&lt;<span class="string">&quot;seed:&quot;</span>; <span class="keyword">for</span> (<span class="keyword">auto</span> x : my_seeder) cout&lt;&lt;x.first&lt;&lt;<span class="string">&quot; &quot;</span>; cout&lt;&lt;endl;&#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;usernode&gt; peers;</span><br><span class="line">        <span class="keyword">if</span> (user_status == <span class="string">&quot;seeder&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            numwant = <span class="built_in">min</span>(numwant, incomplete);</span><br><span class="line">            vector&lt;usernode&gt; seedervec,leechervec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x : my_leecher) leechervec.<span class="built_in">push_back</span>(x.second);</span><br><span class="line">            <span class="built_in">sort</span>(leechervec.<span class="built_in">begin</span>(),leechervec.<span class="built_in">end</span>(),cmp_leecher);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numwant; i++) peers.<span class="built_in">push_back</span>(leechervec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (user_status == <span class="string">&quot;leecher&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;usernode&gt; seedervec,leechervec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x : my_seeder) seedervec.<span class="built_in">push_back</span>(x.second);</span><br><span class="line">            <span class="built_in">sort</span>(seedervec.<span class="built_in">begin</span>(),seedervec.<span class="built_in">end</span>(),cmp_seeder);</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;seedervec.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                peers.<span class="built_in">push_back</span>(seedervec[i]);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count == numwant) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; numwant)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x : my_leecher) leechervec.<span class="built_in">push_back</span>(x.second);</span><br><span class="line">                <span class="built_in">sort</span>(leechervec.<span class="built_in">begin</span>(),leechervec.<span class="built_in">end</span>(),cmp_leecher);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;leechervec.<span class="built_in">size</span>(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    peers.<span class="built_in">push_back</span>(leechervec[i]);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span> (count == numwant) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;OK: &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;COMPLETE=&quot;</span>&lt;&lt;complete&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;INCOMPLETE=&quot;</span>&lt;&lt;incomplete&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;PEERS=[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;peers.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;peers[i].peer_id&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;peers[i].ip&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;peers[i].port&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != peers.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR: Invalid info_hash&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="comment">// cout.tie(0);</span></span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str))</span><br><span class="line">    &#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        ss &lt;&lt; str;</span><br><span class="line">        string op;</span><br><span class="line">        vector&lt;string&gt; envlist;</span><br><span class="line">        ss &gt;&gt; op;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; temp)</span><br><span class="line">        &#123;</span><br><span class="line">            envlist.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;op&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// for (auto x : envlist) cout&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;announce&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">annoounce</span>(envlist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;add&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">add</span>(seedlist, envlist)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;del&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">del</span>(seedlist, envlist)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 30</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;scrape&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 50</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;run&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 70</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;report&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Note-algorithm</title>
      <link href="/2024/10/18/Note-algorithm/"/>
      <url>/2024/10/18/Note-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="算法备考"><a href="#算法备考" class="headerlink" title="算法备考"></a>算法备考</h1><p>参考博客：</p><ul><li><a href="https://blog.csdn.net/coooode_king/article/details/129467411">https://blog.csdn.net/coooode_king/article/details/129467411</a></li><li><a href="https://blog.csdn.net/Cyan_rose/article/details/103018865">https://blog.csdn.net/Cyan_rose/article/details/103018865</a></li></ul><h2 id="CCF备考技巧"><a href="#CCF备考技巧" class="headerlink" title="CCF备考技巧"></a>CCF备考技巧</h2><p>CSP（计算机软件能力认证考试），主要覆盖大学计算机专业所学习的程序设计，数据结构，算法以及相关的数学基础知识。</p><p>包括但不限于：</p><ul><li>程序设计基础：<br>  逻辑与数学运算，分支循环，过程调用（递归），字符串操作，文件操作，etc.</li><li>数据结构：<br>  线性表（数组，队列，栈，链表），树（堆，排序二叉树），哈希表，集合与映射，图，etc.</li><li>算法与算法设计策略：<br>  排序与查找，枚举，贪心策略，分治策略，递推与递归，动态规划，搜索，图论算法，计算几何，字符串匹配，线段树，随机算法，近似算法, etc.</li></ul><p>考试模式：</p><ul><li>OI机制（分点给分</li><li>4h内完成5道题</li></ul><p>题型大致分布&amp;注意事项：（据一位CSP420分的学姐说</p><ul><li><p>第一题：水题<br>  稍有编程经验，20+-行代码可搓完<br>1.注意细节：<br>  long long<br>  边界<br>  特殊情况<br>2.用文件读入可节省大量时间<br>3.宏定义节省for循环书写用时<br><code>#define _for(i , a , b) for(int i=a; i&lt;b; i++)</code><br>4.声明数组大小时，用const定义的伪常量方便修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1007</span></span><br><span class="line"><span class="type">int</span> Num[N] , Sum[N];</span><br><span class="line"><span class="type">char</span> str[N]</span><br></pre></td></tr></table></figure></li><li><p>第二题：小模拟<br>  处理比较简单的问题，需要梳理简单的逻辑和过程<br>1.多重循环，接近n^2的复杂度。一般是时序题，熟练运用排序、多元数组、STL会有奇效<br>2.必备STL神器<br>string：字符串查找、拼接、花式读入<br>set：自动排序，去重<br>vector：盲开数组的首要选择<br>priority_queue：自定义优先级的队列<br>map：不同类型数据的双向字典</p></li><li><p>第三题：大模拟，字符串处理<br>  处理复杂的问题，涉及字符串的问题居多<br>1.熟练掌握各种输入函数与字符串的处理，DFS, BFS，<br>2.会设计复杂的层次化结构<br>3.题库<br>ZJU：acm.zju.edu.cn<br>PKU：acm.pku.edu.cn&#x2F;JudgeOnline<br>HDU：acm.hdu.edu.cn<br>USACO：train.usaco.org&#x2F;usacogate<br>Codeforces：codeforces.com<br>4.题目不难，只是变态（😄）</p></li><li><p>第四题：算法题<br>  难度中，重点考图论和动规<br>1.熟练掌握最小生成树、最短路径、简单递推<br>2.会强连通分量，欧拉函数，动规优化（四边形优化，etc.<br>3.会将DFS转变为非递归式避免爆栈（80‘-&gt;100’）</p></li><li><p>第五题：算法题<br>  难度高，设计算法面很多，数据量很大，需要堆算法极致优化，很难满分<br>1.熟练掌握各种程序设计算法，以及对时间、空间的优化<br>2.快速coding, debug<br>3.精神状态极佳</p></li></ul><h2 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h2><h3 id="常识-1"><a href="#常识-1" class="headerlink" title="常识"></a>常识</h3><p> long long</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long <span class="comment">//不开long long 见祖宗</span></span></span><br></pre></td></tr></table></figure><p>#define</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF  0x3f3f3f3f; <span class="comment">//无穷大 与10^9同数量级 1061109567</span></span></span><br><span class="line"><span class="comment">// 可以使用memset(array, 0x3f, sizeof(array))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first ;<span class="comment">//结合pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second;</span></span><br></pre></td></tr></table></figure><p>万能头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>时间复杂度： 5*10e8对应1s，10^8-&gt;超过了可能会tle</p><p>空间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组最大开<span class="number">10</span>^<span class="number">7</span></span><br><span class="line">单个<span class="type">int</span>大概能到<span class="number">10</span>^<span class="number">9</span></span><br><span class="line"><span class="number">1.</span>代码中一共开辟了多少byte？ <span class="type">int</span>/<span class="type">char</span>/<span class="type">double</span> =&gt; <span class="number">4</span>/<span class="number">1</span>/<span class="number">8</span> byte</span><br><span class="line"><span class="number">2.1024</span>*<span class="number">1024b</span>yte == <span class="number">1</span>MB , 与题目限制的MB数比较即可。</span><br></pre></td></tr></table></figure><p>循环m</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">循环 n 次与循环 n - <span class="number">1</span> 次</span><br><span class="line">在写 <span class="keyword">while</span> 循环时，如果需要循环 n 次可以这样写：<span class="keyword">while</span>(n--)。</span><br><span class="line">当需要循环 n - <span class="number">1</span> 次时则可以写成：<span class="keyword">while</span>(--n)</span><br></pre></td></tr></table></figure><p>puts</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要输出回车换行时，可以直接使用 <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); 语句。需要包含 <span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> 头文件</span></span><br></pre></td></tr></table></figure><p><code>next_permutation</code> （<strong>全排列</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前排列更改为全排列中的下一个排列。</span></span><br><span class="line"><span class="comment">// 如果当前排列已经是全排列中的最后一个排列（元素完全从大到小排列），函数返回 false 并将排列更改为全排列中的第一个排列（元素完全从小到大排列）；否则，函数返回 true。</span></span><br><span class="line"><span class="comment">// 1 结合 数组</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      cout &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a, a + <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2结合 vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      cout &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全排列要先sort</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据量</p><img src="/2024/10/18/Note-algorithm/algorithm-1.png" class=""><p>常见数换算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">0</span>~<span class="number">2</span>^<span class="number">10</span>:<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">256</span> <span class="number">524</span> <span class="number">1024</span></span><br><span class="line"><span class="number">2</span>^<span class="number">20</span> 约<span class="number">10</span>^<span class="number">6</span> (<span class="number">1048576</span>)</span><br><span class="line"><span class="number">2</span>^<span class="number">16</span> =<span class="number">65536</span></span><br><span class="line"><span class="number">2</span>^<span class="number">15</span> =<span class="number">32768</span></span><br><span class="line"><span class="number">2</span>^<span class="number">63</span> =<span class="number">10</span>^<span class="number">18</span></span><br></pre></td></tr></table></figure><p>打表模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cnt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)</span><br><span class="line">        <span class="built_in">cnt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;data.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=<span class="number">1000</span>;n++)<span class="comment">//计算每个结果</span></span><br><span class="line">&#123;</span><br><span class="line">sum=<span class="number">0</span>;<span class="comment">//初始化计数变量 </span></span><br><span class="line"><span class="built_in">cnt</span>(n);</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="comment">//将结果输出至文件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它小知识</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">循环条件中一定不能用函数，否则会很慢。需要用根号时用i &lt;= n / i;</span><br><span class="line">判断一个数是否为整数：  <span class="keyword">if</span>((<span class="type">int</span>)x==x)  </span><br><span class="line">当需要多次操作数组时需要备份： <span class="built_in">memcpy</span>(backup, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">把数组转化为数： <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i ++) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">多行字符矩阵的快速读入<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123; cin&gt;&gt;s; <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;s.<span class="built_in">length</span>(); j++) &#123; <span class="keyword">if</span>(s[j]==<span class="string">&#x27;A&#x27;</span>) ans++; &#125;</span><br><span class="line">快速幂算法</span><br><span class="line">res = res / i * (i - <span class="number">1</span>) 先写除法再写乘法防止中间结果溢出</span><br></pre></td></tr></table></figure><h3 id="实际运用模板"><a href="#实际运用模板" class="headerlink" title="实际运用模板"></a>实际运用模板</h3><p>判断日期合法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!month || month &gt;= <span class="number">13</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>)) months[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">    <span class="keyword">if</span>(day &gt; months[month] || day &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    months[<span class="number">2</span>] = <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>连续读取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) &#123; ...&#125;</span><br></pre></td></tr></table></figure><p>流同步：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); </span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); </span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>getchar()</p><p><code>std::getline(std::cin, str)</code> 读入字符串直到行尾</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m; </span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">getchar</span>();<span class="comment">//读取换行符 </span></span><br><span class="line">string str,temp; </span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure><p>使用getline进行读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">cin.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s); <span class="comment">// 读取带空格的字符串，整行读取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">不读取空格：<span class="keyword">while</span>(cin &gt;&gt; c) str += c;</span><br></pre></td></tr></table></figure><p>小数位数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>, m);</span><br></pre></td></tr></table></figure><p>进制输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2022</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0xaaa</span>;</span><br><span class="line">cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="错误-调试"><a href="#错误-调试" class="headerlink" title="错误 &amp; 调试"></a>错误 &amp; 调试</h3><p>Segment fault 错误出现的原因</p><ul><li>内存访问越界：访问数组时使用错误的下标，导致数组访问越界；搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符。</li><li>非法指针：使用空指针；新申请指针忘记赋 NULL，也忘记分配空间，直接使用造成非法访问。</li><li>堆栈溢出：数组开的非常大，导致堆栈溢出。</li></ul><p>解决方法<br> 当做题遇到 Segment fault 错误时是不好调代码的，因为通常编译器只会报这个错误，但是不会报出现错误的具体地址。这时候可以使用 exit(0) 函数（正常退出程序）来定位错误出现的地方。配合二分法找到问题地点。</p><p>system(“pause”)</p><h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><p>裴蜀定理 ax+by &#x3D; n * gcd(a,b) x,y是未知量</p><p>求gcd：更相减损法，辗转相除法（STL中的__gcd可以直接求）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引理：给定a，b 若d=<span class="built_in">gcd</span>(a,b)&gt;<span class="number">1</span> 则一定不能凑出最大数</span><br><span class="line">结论：如果 a,ba,b 均是正整数且互质，那么由 ax+by,x≥<span class="number">0</span>,y≥<span class="number">0</span>不能凑出的最大数是(a−<span class="number">1</span>)(b−<span class="number">1</span>)−<span class="number">1</span></span><br></pre></td></tr></table></figure><p>模运算性质</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a * b) % p = (a % p * b % p) % p</span><br></pre></td></tr></table></figure><p>输出正余数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">int</span> <span class="title">get_mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>   <span class="comment">// 求a除以b的正余数</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> (a % b + b) % b;&#125;   </span><br></pre></td></tr></table></figure><p>取整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="built_in">ceil</span>((<span class="type">double</span>)a / b);</span><br></pre></td></tr></table></figure><p>约数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任何一个大于 1 数都能分解为素数幂次方乘积的形式</span><br><span class="line">把一个数N 写成：N = (p1^x1^)(p^x2)(p3^x3)…(pk^xk)，其中pi为质数。则N的约数个数为：(x1+1)(x2+1)(x3+1)…(xk+1)</span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string&gt;"></a>string&gt;</h3><p>s.substr(start_pos, num)</p><p>string流处理（stringstream）</p><p>#include <sstream></p><p>字符串转数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stringstream ss;</span><br><span class="line"><span class="type">int</span> a = <span class="number">50</span>; string b;</span><br><span class="line">ss &lt;&lt; a; ss &gt;&gt; b;</span><br></pre></td></tr></table></figure><p>string &amp; int 互转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// string 转 int:</span></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(s) </span><br><span class="line"><span class="type">long</span> num = <span class="built_in">stol</span>(s);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num = <span class="built_in">stoll</span>(s);</span><br><span class="line"><span class="type">double</span> num = <span class="built_in">stod</span>(s)</span><br><span class="line"><span class="comment">// int 转 string:     </span></span><br><span class="line">string num = <span class="built_in">to_string</span>(num) </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>手写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个数的所有位数提取出来:</span></span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;<span class="type">int</span> t = x % <span class="number">10</span>;x /= <span class="number">10</span>;.....&#125;</span><br><span class="line"><span class="comment">// 将字符串转换为整数:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i ++)</span><br><span class="line">&#123;x = x * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;&#125;</span><br></pre></td></tr></table></figure><p>字符串以空格分隔split</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stringstream ss;</span><br><span class="line">string a =<span class="string">&quot;how old are you , dear ?&quot;</span>;</span><br><span class="line">ss &lt;&lt; a;</span><br><span class="line">string b;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; b) cout &lt;&lt;b&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str =<span class="string">&quot;123456789abcdefghiaklmn&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="comment">//把str看成一个字符串数组</span></span><br><span class="line">        cout&lt;&lt;str[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find函数</span></span><br><span class="line">    <span class="type">int</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;目标&quot;</span>, start_pos); <span class="comment">//找到输出pos,否则输出-1</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;123的位置: &quot;</span>&lt;&lt;str.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：123的位置: 0</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;34在str[2]到str[n-1]中的位置: &quot;</span>&lt;&lt;str.<span class="built_in">find</span>(<span class="string">&quot;34&quot;</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：34在str[2]到str[n-1]中的位置: 2</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ab在str[0]到str[12]中的位置: &quot;</span>&lt;&lt;str.<span class="built_in">rfind</span>(<span class="string">&quot;ab&quot;</span>,<span class="number">12</span>)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：ab在str[0]到str[12]中的位置: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//substr()函数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str[3]及以后的子串:&quot;</span>&lt;&lt;str.<span class="built_in">substr</span>(<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：str[3]及以后的子串:456789abcdefghijklmn</span></span><br><span class="line"><span class="comment">//若小于限制长度则报错</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从str[2]开始的4个字符:&quot;</span>&lt;&lt;str.<span class="built_in">substr</span>(<span class="number">2</span>,<span class="number">4</span>)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：从str[2]开始的4个字符:3456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//find()函数</span></span><br><span class="line">    str.<span class="built_in">replace</span>(str.<span class="built_in">find</span>(<span class="string">&quot;a&quot;</span>), <span class="number">5</span>, <span class="string">&quot;@#&quot;</span>);</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：123456789@#fghiaklmn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//insert()函数</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从2号位置插入: &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：12***3456789@#fghiaklmn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加字符串：append()函数</span></span><br><span class="line">    str.<span class="built_in">append</span>(<span class="string">&quot;$$$&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;在字符串str后面添加字符串:&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：12***3456789@#fghiaklmn$$$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串长度</span></span><br><span class="line">    cout&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;str.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换字符串：swap()函数</span></span><br><span class="line">    string str1=<span class="string">&quot;aaa&quot;</span>,str2=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">    <span class="built_in">swap</span>(str1, str2);</span><br><span class="line">    cout&lt;&lt;str1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;str2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串比较函数：compare()，相等输出0，不等输出1</span></span><br><span class="line">    cout&lt;&lt;str1.<span class="built_in">compare</span>(str2)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(str1==str2) cout &lt;&lt;<span class="string">&quot;==&quot;</span>; <span class="comment">//直接比较也行</span></span><br><span class="line">    <span class="keyword">if</span>(str1!=str2) cout &lt;&lt;<span class="string">&quot;!=&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h3><p>求树的直径</p><p><a href="https://www.cnblogs.com/ljy-endl/p/11612275.html">https://www.cnblogs.com/ljy-endl/p/11612275.html</a></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">fill</span>(&amp;a[<span class="number">0</span>], a + <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="指针与链表"><a href="#指针与链表" class="headerlink" title="指针与链表"></a>指针与链表</h3><p>链表指针节点新建可以这样it-&gt;next &#x3D; new ListNode;</p><p>指针本身可作为bool值，有指针为1，nullptr为0</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p><a href="https://blog.csdn.net/weq2011/article/details/128791426">https://blog.csdn.net/weq2011/article/details/128791426</a></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>以及访问（<a href="https://www.luogu.com.cn/problem/P1827%EF%BC%89">https://www.luogu.com.cn/problem/P1827）</a></p><h3 id="并查集（UnionFind）"><a href="#并查集（UnionFind）" class="headerlink" title="并查集（UnionFind）"></a>并查集（UnionFind）</h3><ul><li>用集合中的某个元素来代表这个集合，则该元素称为此集合的代表元；</li><li>一个集合内的所有元素组织成以代表元为根的树形结构；</li><li>对于每一个元素 x，pre[x] 存放 x 在树形结构中的父亲节点（如果 x 是根节点，则令pre[x] &#x3D; x）；</li><li>对于查找操作，假设需要确定 x 所在的集合，也就是确定集合的代表元。可以沿着pre[x]不断在树形结构中向上移动，直到到达根节点。</li><li>因此，基于这样的特性，并查集的主要用途有以下两点：</li><li>1、维护无向图的连通性（判断两个点是否在同一连通块内，或增加一条边后是否会产生环）；</li><li>2、用在求解最小生成树的Kruskal算法里。</li><li>时间复杂度logn（加上路径压缩和rank优化）</li></ul><p>一般来说，一个并查集对应三个操作：</p><ul><li>初始化（ Init()函数 ）</li><li>查找函数（ Find()函数 ）</li><li>合并集合函数（ Join()函数 ）</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>  N=<span class="number">1005</span><span class="comment">//指定并查集所能包含元素的个数（由题意决定）</span></span><br><span class="line"><span class="type">int</span> pre[N];     <span class="comment">//存储每个结点的前驱结点 </span></span><br><span class="line"><span class="type">int</span> rank[N];    <span class="comment">//树的高度 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span>     <span class="comment">//初始化函数，对录入的 n个结点进行初始化 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        pre[i] = i;     <span class="comment">//每个结点的上级都是自己 </span></span><br><span class="line">        rank[i] = <span class="number">1</span>;    <span class="comment">//每个结点构成的树的高度为 1 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>          <span class="comment">//查找结点 x的根结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x) <span class="keyword">return</span> x;  <span class="comment">//递归出口：x的上级为 x本身，则 x为根结点 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(pre[x]); <span class="comment">//递归查找 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">//改进查找算法：完成路径压缩，将 x的上级直接变为根结点，那么树的高度就会大大降低 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x) <span class="keyword">return</span> x;<span class="comment">//递归出口：x的上级为 x本身，即 x为根结点 </span></span><br><span class="line">    <span class="keyword">return</span> pre[x] = <span class="built_in">find</span>(pre[x]);   <span class="comment">//此代码相当于先找到根结点 rootx，然后 pre[x]=rootx </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>      <span class="comment">//判断两个结点是否连通 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);  <span class="comment">//判断两个结点的根结点（即代表元）是否相同 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);<span class="comment">//寻找 x的代表元</span></span><br><span class="line">    y = <span class="built_in">find</span>(y);<span class="comment">//寻找 y的代表元</span></span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果 x和 y的代表元一致，说明他们共属同一集合，则不需要合并，返回 false，表示合并失败；否则，执行下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(rank[x] &gt; rank[y]) pre[y]=x;<span class="comment">//如果 x的高度大于 y，则令 y的上级为 x</span></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rank[x]==rank[y]) rank[y]++;<span class="comment">//如果 x的高度和 y的高度相同，则令 y的高度加1</span></span><br><span class="line">        pre[x]=y;<span class="comment">//让 x的上级为 y</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回 true，表示合并成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/the_ZED/article/details/105126583">https://blog.csdn.net/the_ZED/article/details/105126583</a></p><p>实现2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFindSet</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFindSet</span>(<span class="type">int</span> n)</span><br><span class="line">        : _ufs(n, <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并集合</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> root1 = <span class="built_in">find_root</span>(x1);</span><br><span class="line">        <span class="type">int</span> root2 = <span class="built_in">find_root</span>(x2);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 改进：默认root1为大集合，判断root2是否大于root1</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(_ufs[root1]) &lt; <span class="built_in">abs</span>(_ufs[root2]))</span><br><span class="line">                <span class="built_in">swap</span>(root1, root2);</span><br><span class="line">            <span class="comment">// root2 -&gt; root1</span></span><br><span class="line">            _ufs[root1] += _ufs[root2];</span><br><span class="line">            _ufs[root2] = root1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找集合的代表元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_root</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> root = x;</span><br><span class="line">        <span class="keyword">while</span> (_ufs[root] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = _ufs[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 改进：路径压缩</span></span><br><span class="line">        <span class="keyword">while</span> (_ufs[x] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 记录父亲节点</span></span><br><span class="line">            <span class="type">int</span> parent = _ufs[x];</span><br><span class="line">            <span class="comment">// 让该节点直接指向root</span></span><br><span class="line">            _ufs[x] = root;</span><br><span class="line">            x = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否在同一个集合中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isinset</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find_root</span>(x1) == <span class="built_in">find_root</span>(x2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算集合个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setsize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : _ufs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; _ufs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最小生成树</p><p>prim算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prime算法</span></span><br><span class="line"><span class="comment">//将城市X标记为visit=true时，就表示该城市加入到集合U，用sum累加记录边的总费用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO 99999999   <span class="comment">//99999999代表两点之间不可达</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visit[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> money[N] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> graph[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initgraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %lld&quot;</span>, &amp;graph[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printgraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %lld&quot;</span>, graph[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> city)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>();</span><br><span class="line"><span class="built_in">printgraph</span>();</span><br><span class="line"><span class="type">int</span> index = city;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;访问节点：&quot;</span> &lt;&lt;index &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="built_in">sizeof</span>(visit));</span><br><span class="line">visit[city] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">money[i] = graph[city][i];<span class="comment">//初始化，每个与城市city间相连的费用存入money，以便后续比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> minor = NO;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((visit[j] == <span class="literal">false</span>) &amp;&amp; money[j] &lt; minor)  <span class="comment">//找到未访问的城市中，与当前最小生成树中的城市间费用最小的城市</span></span><br><span class="line">&#123;</span><br><span class="line">minor = money[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit[index] = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;访问节点：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">sum += minor; <span class="comment">//求总的最低费用</span></span><br><span class="line"><span class="comment">/*这里是一个更新，如果未访问城市与当前城市间的费用更低，就更新money,保存更低的费用*/</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((visit[j] == <span class="literal">false</span>) &amp;&amp; money[j]&gt;graph[index][j])</span><br><span class="line">&#123;</span><br><span class="line">money[j] = graph[index][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> sum;               <span class="comment">//返回总费用最小值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;修路最低总费用为：&quot;</span>&lt;&lt; <span class="built_in">prim</span>(<span class="number">0</span>) &lt;&lt; endl;<span class="comment">//从城市0开始</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kruskal算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kruskal算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 50005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qm 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span>&#123;</span><br><span class="line"><span class="type">int</span> ff, tt, ww;</span><br><span class="line">&#125;c[M &lt;&lt; <span class="number">1</span>];<span class="comment">// 存储边的集合，ff，tt，ww为一条从ff连接到tt的权值为ww的边 </span></span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;<span class="comment">//边的总数 </span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//最小生成树的权值和 </span></span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//并查集 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(<span class="type">const</span> arr &amp; a, <span class="type">const</span> arr &amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.ww &lt; b.ww;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m, n;<span class="comment">//边数量，点数量 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">getfa</span>(f[x]);</span><br><span class="line">&#125;<span class="comment">//并查集，带路径压缩 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">c[++tot].ff = x;</span><br><span class="line">c[tot].tt = y;</span><br><span class="line">c[tot].ww = z;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//新增一条边 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruscal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) f[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="type">int</span> fx = <span class="built_in">getfa</span>(c[i].ff);<span class="comment">//寻找祖先 </span></span><br><span class="line"><span class="type">int</span> fy = <span class="built_in">getfa</span>(c[i].tt);</span><br><span class="line"><span class="keyword">if</span> (fx != fy)&#123;<span class="comment">//不在一个集合，合并加入一条边 </span></span><br><span class="line">f[fx] = fy;</span><br><span class="line">ans += c[i].ww;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;input10.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;output10.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line"><span class="built_in">add</span>(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + m, comp);<span class="comment">//快速排序 </span></span><br><span class="line"><span class="built_in">kruscal</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 单调减队列，保存区间最小值</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; a[q.<span class="built_in">back</span>()] &gt; a[i])</span><br><span class="line">q.<span class="built_in">pop_back</span>();</span><br><span class="line">q.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (i &gt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() &lt;= i - m)</span><br><span class="line">q.<span class="built_in">pop_front</span>();</span><br><span class="line">cout &lt;&lt; a[q.<span class="built_in">front</span>()];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="★STL"><a href="#★STL" class="headerlink" title="★STL"></a>★STL</h3><p>该部分有参考<a href="https://blog.csdn.net/weixin_49486457/article/details/123439229">https://blog.csdn.net/weixin_49486457/article/details/123439229</a></p><p>随机访问迭代器容器：std::vector, std::deque, std::array, std::basic_string<br>双向迭代器容器：std::list, std::set, std::map, std::multiset, std::multimap</p><h4 id="迭代器使用："><a href="#迭代器使用：" class="headerlink" title="迭代器使用："></a>迭代器使用：</h4><ul><li>std::prev() 注意越界问题，可用于vector,dequeue,list,map,set</li><li>std::next() 注意越界问题，</li><li>distance(vec.begin(), vec.end())</li></ul><h4 id=""><a href="#" class="headerlink" title="&lt;vector&gt;"></a><code>&lt;vector&gt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;<span class="comment">//定义一个vector，未初始化，输出》 0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;<span class="comment">//定义一个长度为3的vector，未初始化，输出》0 0 0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>; <span class="comment">//定义一个长度为10，且每个数赋值为3</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b.begin(),b.begin+<span class="number">3</span>)</span></span>;<span class="comment">//将向量b中从下标0 1 2（共三个）的元素赋值给a，a的类型为int型</span></span><br><span class="line"><span class="comment">//从数组中获得初值</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    a.size()<span class="comment">//返回元素个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.resize()<span class="comment">//改变大小，默认赋值，参数count,value</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.reserve()<span class="comment">//预留空间，不改变其当前的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.empty();<span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.front(); <span class="keyword">if</span>(!a.empty())<span class="comment">//返回a的第1个元素,当且仅当存在</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.back(); <span class="keyword">if</span>(!a.empty())<span class="comment">//返回vector的最后一个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.clear();<span class="comment">//清空a中的元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.pop_back();<span class="comment">//删除a向量的最后一个元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.push_back(<span class="number">5</span>);<span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.emplace_back();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;a.push_back(i);&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//三种遍历vector的方法</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.size(); i ++) &#123;cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = a.begin(); i != a.end(); i ++) &#123;cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;<span class="comment">//C++11的新语法</span></span></span></span><br><span class="line"><span class="params"><span class="function">   </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//结合算法erase() reverse()</span></span></span></span><br><span class="line"><span class="params"><span class="function">    #include&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="params"><span class="function">    a.erase(p)<span class="comment">//从a中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能是最后一个元素end()</span></span></span></span><br><span class="line"><span class="params"><span class="function">    a.erase(b,e)<span class="comment">//从a中删除迭代器对b和e所表示的范围中的元素，返回e</span></span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;<span class="type">int</span>&gt; a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">    reverse(a.begin(),a.end());<span class="comment">//a的值为5，4，3，2，1  倒置</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// vector 有重载=，可以直接比较两个vector是否一致              </span></span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;<span class="type">int</span>&gt; sCount(<span class="number">26</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;<span class="type">int</span>&gt; pCount(<span class="number">26</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    pCount[<span class="number">3</span>] = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (sCount == pCount) cout&lt;&lt;<span class="string">&quot;1&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 重要：vector嵌套</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> m = <span class="number">10</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    vector &lt; string &gt; s; </span></span></span><br><span class="line"><span class="params"><span class="function">    vector &lt; vector &lt; string &gt; &gt; hashmap ( m,s ) ;</span></span></span><br></pre></td></tr></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title="&lt;queue&gt; &lt;priority_queue&gt;"></a><code>&lt;queue&gt; &lt;priority_queue&gt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//queue &lt;类型&gt; 变量名  </span></span><br><span class="line"><span class="comment">//priority_queue &lt;类型&gt; 变量名;</span></span><br><span class="line">queue &lt;<span class="type">int</span>&gt; q; <span class="comment">//定义一个名为q队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>&gt; q; <span class="comment">//默认是大根堆</span></span><br><span class="line"><span class="comment">//定义小根堆</span></span><br><span class="line"><span class="comment">//小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名</span></span><br><span class="line"><span class="comment">// priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// queue &amp; priority_queue</span></span><br><span class="line">q.<span class="built_in">size</span>();<span class="comment">// 这个队列的长度</span></span><br><span class="line">q.<span class="built_in">empty</span>();<span class="comment">//用于判断这个队列是否为空，空则返回true，非空则返回false</span></span><br><span class="line">q.<span class="built_in">push</span>(); <span class="comment">//往队尾插入一个元素</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">//队列：把队头弹出  优先队列 ：弹出堆顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// queue</span></span><br><span class="line">q.<span class="built_in">front</span>();<span class="comment">// 返回队头元素</span></span><br><span class="line">q.<span class="built_in">back</span>(); <span class="comment">//返回队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// priority_queue</span></span><br><span class="line">q.<span class="built_in">top</span>();<span class="comment">// 返回堆顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear</span></span><br><span class="line">q = queue &lt;<span class="type">int</span>&gt; ();</span><br></pre></td></tr></table></figure><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="&lt;deque&gt;双端队列"></a><code>&lt;deque&gt;双端队列</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq;<span class="comment">//定义一个int类型的双向队列</span></span><br><span class="line"></span><br><span class="line">dq.<span class="built_in">size</span>(); <span class="comment">//返回这个双端队列的长度,unsigned int</span></span><br><span class="line">dq.<span class="built_in">empty</span>(); <span class="comment">//返回这个队列是否为空，空则返回true，非空则返回false</span></span><br><span class="line">dq.<span class="built_in">clear</span>(); <span class="comment">//清空这个双端队列</span></span><br><span class="line">dq.<span class="built_in">front</span>(); <span class="comment">//返回第一个元素</span></span><br><span class="line">dq.<span class="built_in">back</span>(); <span class="comment">//返回最后一个元素</span></span><br><span class="line">dq.<span class="built_in">push_back</span>(); <span class="comment">//向最后插入一个元素</span></span><br><span class="line">dq.<span class="built_in">pop_back</span>(); <span class="comment">//弹出最后一个元素</span></span><br><span class="line">dq.<span class="built_in">push_front</span>(); <span class="comment">//向队首插入一个元素</span></span><br><span class="line">dq.<span class="built_in">pop_front</span>();<span class="comment">//弹出第一个元素</span></span><br><span class="line">dq.<span class="built_in">begin</span>(); <span class="comment">//双端队列的第0个数</span></span><br><span class="line">dq.<span class="built_in">end</span>(); <span class="comment">//双端队列的最后一个的数的后面一个数</span></span><br></pre></td></tr></table></figure><h4 id="-2"><a href="#-2" class="headerlink" title="&lt;stack&gt;"></a><code>&lt;stack&gt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stack&gt;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">size</span>()<span class="comment">//返回这个栈的长度</span></span><br><span class="line">s.<span class="built_in">push</span>()<span class="comment">//向栈顶插入一个元素</span></span><br><span class="line">s.<span class="built_in">top</span>()<span class="comment">//返回栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>()<span class="comment">//弹出栈顶元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-3"><a href="#-3" class="headerlink" title="&lt;set&gt;"></a><code>&lt;set&gt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; s;<span class="comment">//string 集合</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">// 返回元素个数</span></span><br><span class="line"><span class="built_in">empty</span>(); <span class="comment">//返回set是否是空的</span></span><br><span class="line"><span class="built_in">clear</span>(); <span class="comment">//清空</span></span><br><span class="line"><span class="built_in">begin</span>(); <span class="comment">//第0个数，支持++或--，返回前驱和后继</span></span><br><span class="line"><span class="built_in">end</span>(); <span class="comment">//最后一个的数的后面一个数，支持++或--，返回前驱和后继</span></span><br><span class="line"><span class="built_in">insert</span>(); <span class="comment">//插入一个数</span></span><br><span class="line"><span class="built_in">find</span>(); <span class="comment">//查找一个数</span></span><br><span class="line"><span class="built_in">count</span>(); <span class="comment">//返回某一个数的个数</span></span><br><span class="line"><span class="built_in">erase</span>(x); <span class="comment">//删除索引x  时间复杂度 O(k + logn)</span></span><br><span class="line"><span class="built_in">erase</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());<span class="comment">//删除一个迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>(x); <span class="comment">//返回大于等于x的最小的数的迭代器  核心操作</span></span><br><span class="line"><span class="built_in">upper_bound</span>(x); <span class="comment">//返回大于x的最小的数的迭代器  不存在返回end()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-4"><a href="#-4" class="headerlink" title="&lt;map&gt;"></a><code>&lt;map&gt;</code></h4><p>会按照key的值自动排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">char</span>&gt; m;</span><br><span class="line">m.<span class="built_in">find</span>();</span><br><span class="line">m.<span class="built_in">size</span>();</span><br><span class="line">m.<span class="built_in">insert</span>(&#123;k, v&#125;);</span><br><span class="line">m.<span class="built_in">erase</span>(it);</span><br><span class="line">m.<span class="built_in">erase</span>(key);</span><br><span class="line">m.<span class="built_in">clear</span>();</span><br><span class="line">m.<span class="built_in">count</span>();<span class="comment">// 可以代替find</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>(x); <span class="comment">//返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="built_in">upper_bound</span>(x); <span class="comment">//返回大于x的最小的数的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射操作</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;a;</span><br><span class="line">a[<span class="string">&quot;abc&quot;</span>] = <span class="number">1</span>;<span class="comment">//把字符串&quot;abc&quot; 映射为1</span></span><br><span class="line">cout &lt;&lt; a[<span class="string">&quot;abc&quot;</span>] &lt;&lt; endl; <span class="comment">//查找abc  程序输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;string,<span class="type">int</span>&gt; PSI;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;heihei&quot;</span>,<span class="number">5</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">PSI</span>(<span class="string">&quot;haha&quot;</span>,<span class="number">10</span>));<span class="comment">//简化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : m)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; x.second &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find用法</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">char</span>&gt;::iterator it = m1.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (it!= m1.<span class="built_in">end</span>()) <span class="comment">// 找到了，没找到会返回和end()一样的迭代器值</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用map保存状态，使用移位操作进行状态标记</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> key = ((<span class="type">long</span> <span class="type">long</span>)i &lt;&lt; <span class="number">32</span>) | jump&lt;&lt;<span class="number">1</span> | status;</span><br></pre></td></tr></table></figure><h4 id="-5"><a href="#-5" class="headerlink" title="&lt;pair&gt;"></a><code>&lt;pair&gt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p3;  <span class="comment">// 使用默认构造函数</span></span><br><span class="line">p3 = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1.2</span>);<span class="comment">// 利用make_pair赋值</span></span><br><span class="line">vector&lt; vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt;<span class="comment">// 嵌套：与vector结合【再写个vector结合即可】</span></span><br></pre></td></tr></table></figure><h4 id="-6"><a href="#-6" class="headerlink" title="&lt;string&gt;"></a><code>&lt;string&gt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// 尾插一个字符</span></span><br><span class="line"><span class="comment">// insert(pos,char):在制定的位置pos前插入字符char</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(),<span class="string">&#x27;1&#x27;</span>); <span class="comment">//输出 1a</span></span><br><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">string str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2=<span class="string">&quot;weakhaha&quot;</span>;</span><br><span class="line">str2.<span class="built_in">insert</span>(<span class="number">0</span>,s2,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//将字符串s2从下标为1的e开始数3个字符，分别是eak，插入原串的下标为0的字符h前    </span></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line"><span class="built_in">size</span>() <span class="built_in">length</span>()</span><br><span class="line"><span class="comment">// 都是 返回字母个数</span></span><br><span class="line"><span class="comment">//!!注意他们的类型都是 注：std::string 的成员函数 length() 的返回值类型为 unsigned 类型，因此当 s.length() &lt; t.length() 时，二者相减会得到一个很大的数产生运行时错误，所以相减之前需要先将二者强制类型转换为 int 类型。</span></span><br><span class="line"><span class="built_in">clear</span>() <span class="comment">// 字符串清空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substr</span></span><br><span class="line">tring a = <span class="string">&quot;ac&quot;</span>;</span><br><span class="line">    a += <span class="string">&quot;w&quot;</span>;<span class="comment">//支持比较操作符&gt;,&gt;=,&lt;,&lt;=,==,!=</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">//输出子串a :acw</span></span><br><span class="line"></span><br><span class="line">    a += <span class="string">&quot;ing&quot;</span>;  </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//以字符串数组理解</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">//当第一个数是0 则后一位数:输出从头开始的长度为3的子串</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">//当第一个数是1 则输出下标为1 到下标为3的子串  </span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">9</span>) &lt;&lt; endl;<span class="comment">//如果超出长度范围 则输出原子串</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">1</span>) &lt;&lt; endl; <span class="comment">//从下标为1开始输出</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>) &lt;&lt; endl; <span class="comment">//原子串 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c_str() 返回这个string对应的字符数组的头指针</span></span><br><span class="line">string s = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>()); <span class="comment">//输出 &quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-7"><a href="#-7" class="headerlink" title="&lt;bitset&gt;"></a><code>&lt;bitset&gt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line">bitset&lt;4&gt; bs;　　<span class="comment">//无参构造，长度为４，默认每一位为０</span></span><br><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b</span><span class="params">(<span class="number">12</span>)</span></span>;　　<span class="comment">//长度为８，二进制保存，前面用０补充</span></span><br><span class="line">string s = <span class="string">&quot;100101&quot;</span>; <span class="comment">//01串赋值</span></span><br><span class="line"><span class="function">bitset&lt;10&gt; <span class="title">bs</span><span class="params">(s)</span></span>;　　<span class="comment">//长度为10，前面用０补充</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持操作</span></span><br><span class="line">~取反，&amp;与，|与或，^异或</span><br><span class="line">&gt;&gt;，&lt;&lt;  移动</span><br><span class="line">==，!=</span><br><span class="line">[]   取<span class="number">0</span>/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用函数    </span></span><br><span class="line"><span class="built_in">count</span>(); <span class="comment">//返回1的个数</span></span><br><span class="line"><span class="built_in">any</span>(); <span class="comment">//判断是否至少有一个1</span></span><br><span class="line"><span class="built_in">none</span>(); <span class="comment">//判断是否全为0</span></span><br><span class="line"><span class="built_in">set</span>(); <span class="comment">//把所有位置赋值为1</span></span><br><span class="line"><span class="built_in">set</span>(k,v); <span class="comment">//将第k位变成v</span></span><br><span class="line"><span class="built_in">reset</span>(); <span class="comment">//把所有位变成0</span></span><br><span class="line"><span class="built_in">flip</span>(); <span class="comment">//把所有位取反，等价于~</span></span><br><span class="line"><span class="built_in">flip</span>(k); <span class="comment">//把第k位取反</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-8"><a href="#-8" class="headerlink" title="&lt;algorithm&gt;"></a><code>&lt;algorithm&gt;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找算法</span></span><br><span class="line"><span class="built_in">find</span>();<span class="comment">// 查找序列中第一个与给定值相等的元素的位置。</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), target);</span><br><span class="line"><span class="built_in">find_if</span>();<span class="comment">// 查找序列中第一个满足给定条件的元素的位置。</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i &gt; <span class="number">3</span>; &#125;);</span><br><span class="line"><span class="built_in">adjacent_find</span>();<span class="comment">// 查找序列中相邻的相同元素。</span></span><br><span class="line"><span class="keyword">auto</span> pred = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> b == <span class="number">2</span> * a; &#125;;</span><br><span class="line"><span class="keyword">auto</span> pred = std::<span class="built_in">equal_to</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// pred: 一个二元谓词，用于比较相邻元素，默认为 std::equal_to</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">adjacent_find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), pred);</span><br><span class="line"><span class="built_in">count</span>();<span class="comment">// 计算序列中与给定值相等的元素的个数。</span></span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="built_in">count_if</span>();<span class="comment">// 计算序列中满足给定条件的元素的个数。</span></span><br><span class="line"><span class="keyword">auto</span> pred = [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; &#125;;</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), pred);</span><br><span class="line"><span class="built_in">search</span>();<span class="comment">// 查找序列中另一个序列的第一个出现的位置。</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">search</span>(vec1.<span class="built_in">begin</span>(), vec1.<span class="built_in">end</span>(), vec2.<span class="built_in">begin</span>(), vec2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">search_n</span>();<span class="comment">// 查找序列中给定值出现的第一个位置，并返回该位置和下一个位置之间的所有元素。</span></span><br><span class="line"><span class="comment">// 返回一个迭代器，指向找到子序列的起始位置。如果没有找到，则返回vec1.end()</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">search_n</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), count, value);<span class="comment">// 连续出现count个value</span></span><br><span class="line"><span class="built_in">mismatch</span>();<span class="comment">// 比较两个序列，并返回第一个不相等的元素的位置。</span></span><br><span class="line"><span class="keyword">auto</span> result = std::<span class="built_in">mismatch</span>(vec1.<span class="built_in">begin</span>(), vec1.<span class="built_in">end</span>(), vec2.<span class="built_in">begin</span>(), pred);</span><br><span class="line"><span class="built_in">equal</span>();<span class="comment">// 比较两个序列是否相等。</span></span><br><span class="line"><span class="type">bool</span> isEqual = std::<span class="built_in">equal</span>(vec1.<span class="built_in">begin</span>(), vec1.<span class="built_in">end</span>(), vec2.<span class="built_in">begin</span>(), pred);</span><br><span class="line"><span class="built_in">is_sorted</span>();<span class="comment">// 判断序列是否已经排序。</span></span><br><span class="line"><span class="type">bool</span> isSorted = std::<span class="built_in">is_sorted</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>())</span><br><span class="line"><span class="built_in">binary_search</span>();<span class="comment">// 在排序后的序列中查找给定值的位置。</span></span><br><span class="line"><span class="type">bool</span> is_found = std::<span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), target)</span><br><span class="line"><span class="built_in">lower_bound</span>();<span class="comment">// 返回第一个大于或等于给定值的元素的迭代器。</span></span><br><span class="line"><span class="keyword">auto</span> lb = std::<span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"><span class="built_in">upper_bound</span>();<span class="comment">// 返回第一个大于给定值的元素的迭代器。</span></span><br><span class="line"><span class="keyword">auto</span> ub = std::<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"><span class="built_in">equal_range</span>();<span class="comment">// 返回包含给定值的两个迭代器，其 first 成员是指向第一个等于 value 的元素的迭代器，second 成员是指向第一个大于 value 的元素的迭代器。该函数适用于已排序的序列。</span></span><br><span class="line"><span class="keyword">auto</span> range = std::<span class="built_in">equal_range</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"><span class="keyword">auto</span> range_first = range.first;</span><br><span class="line"><span class="keyword">auto</span> range_second = range.second;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序操作</span></span><br><span class="line"><span class="built_in">sort</span>();<span class="comment">// 对序列进行排序。</span></span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">5</span>,cmp);<span class="comment">//搭配数组  从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="comment">// 自定义sort函数（等同于cmp函数与运算符重载）</span></span><br><span class="line">    <span class="built_in">sort</span>(range, range + n, [&amp;](Range a, Range b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="built_in">stable_sort</span>();<span class="comment">// 对序列进行稳定排序。</span></span><br><span class="line"><span class="built_in">partial_sort</span>();<span class="comment">// 对序列进行部分排序。</span></span><br><span class="line"><span class="built_in">partial_sort_copy</span>();<span class="comment">// 对序列进行部分排序，并将结果复制到另一个序列。</span></span><br><span class="line"><span class="built_in">nth_element</span>();<span class="comment">// 将序列的第 n 个元素放在正确的位置。</span></span><br><span class="line"><span class="built_in">merge</span>();<span class="comment">// 将两个有序序列合并为一个有序序列。</span></span><br><span class="line"><span class="built_in">inplace_merge</span>();<span class="comment">// 在原地将两个有序序列合并为一个有序序列。</span></span><br><span class="line"><span class="built_in">sort_by_key</span>();<span class="comment">// 根据键对序列进行排序。</span></span><br><span class="line"><span class="built_in">stable_sort_by_key</span>();<span class="comment">// 根据键对序列进行稳定排序。</span></span><br><span class="line"><span class="built_in">sort_heap</span>();<span class="comment">// 对堆进行排序。</span></span><br><span class="line"><span class="built_in">make_heap</span>();<span class="comment">// 将序列转换为堆。</span></span><br><span class="line"><span class="built_in">pop_heap</span>();<span class="comment">// 从堆中弹出顶部元素。</span></span><br><span class="line"><span class="built_in">push_heap</span>();<span class="comment">// 将元素插入到堆中。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 修改算法</span></span><br><span class="line"><span class="built_in">copy</span>()：复制一个序列。</span><br><span class="line"><span class="built_in">copy_if</span>()：复制满足给定条件的序列元素。</span><br><span class="line"><span class="built_in">replace</span>()：将序列中指定的元素替换为另一个元素。</span><br><span class="line"><span class="built_in">replace_if</span>()：将序列中满足给定条件的元素替换为另一个元素。</span><br><span class="line"><span class="built_in">fill</span>()：将序列填充为指定值。</span><br><span class="line"><span class="built_in">fill_n</span>()：将序列的前 n 个元素填充为指定值。</span><br><span class="line"><span class="built_in">transform</span>()：将序列中的每个元素转换为另一个值。</span><br><span class="line"><span class="built_in">generate</span>()：将序列中的每个元素生成为一个指定函数的结果。</span><br><span class="line"><span class="built_in">remove</span>()：从序列中删除指定值的元素。</span><br><span class="line"><span class="built_in">remove_if</span>()：从序列中删除满足给定条件的元素。</span><br><span class="line"><span class="built_in">unique</span>()：删除序列中相邻重复的元素。</span><br><span class="line"><span class="built_in">unique_copy</span>()：将序列中相邻重复的元素复制到另一个序列。</span><br><span class="line"><span class="built_in">swap</span>()：交换两个序列。</span><br><span class="line"><span class="built_in">reverse</span>()：反转序列的顺序。</span><br><span class="line"><span class="built_in">rotate</span>()：将序列旋转指定的元素。</span><br><span class="line"><span class="built_in">random_shuffle</span>()：对序列进行随机排序。</span><br><span class="line"><span class="built_in">shuffle</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚合算法</span></span><br><span class="line"><span class="built_in">accumulate</span>()<span class="comment">// 对序列中的元素进行累加。</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">reduce</span>()：对序列中的元素进行归约。</span><br><span class="line"><span class="built_in">inner_product</span>()：计算两个序列的点积。</span><br><span class="line"><span class="built_in">adjacent_difference</span>()：计算序列中相邻元素的差。</span><br><span class="line"><span class="built_in">partial_sum</span>()：计算序列中的部分和。</span><br><span class="line"><span class="built_in">iota</span>()：生成一个从 <span class="number">0</span> 开始的序列。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代算法</span></span><br><span class="line">for_each()：对序列中的每个元素执行一个指定的操作。</span><br><span class="line"><span class="built_in">transform_reduce</span>()：将序列中的元素转换为另一个值，并对结果进行归约。</span><br><span class="line">for_each_n()：对序列的前 n 个元素执行一个指定的操作。</span><br><span class="line"><span class="built_in">generate_n</span>()：生成 n 个元素，并将它们插入到序列中</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span>();<span class="comment">//将两个有序序列合并为一个有序序列</span></span><br><span class="line"><span class="comment">// 二分查找 时间复杂度O(log n)</span></span><br><span class="line"><span class="comment">// binary_search</span></span><br><span class="line"><span class="comment">// binary_search 算法在 [first, last) 范围内执行二分查找，寻找是否存在值等于 val 的元素。如果找到目标元素，则返回 true；否则返回 false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">// lower_bound 返回第一个大于等于target的元素</span></span><br><span class="line"><span class="comment">// upper_bound 返回第一个大于target的元素</span></span><br><span class="line"><span class="type">int</span> l = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target) - nums.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">int</span> r = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target) - nums.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// merge 归并两个有序序列</span></span><br><span class="line"><span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),v2.<span class="built_in">begin</span>(),v2.<span class="built_in">end</span>(),v3.<span class="built_in">begin</span>());<span class="comment">//合并v1和v2到v3</span></span><br><span class="line"><span class="comment">// 判断一序列是否为另一序列的子序列。返回真假</span></span><br><span class="line"><span class="built_in">includes</span>()</span><br><span class="line"><span class="comment">// 集合操作</span></span><br><span class="line">    <span class="built_in">set_union</span>()<span class="comment">// 并集</span></span><br><span class="line">    <span class="built_in">set_intersection</span>()<span class="comment">// 交集</span></span><br><span class="line">    <span class="built_in">set_difference</span>()<span class="comment">// 差集</span></span><br><span class="line">    <span class="built_in">set_symmetric_difference</span>()<span class="comment">// 对称差集（并-交）</span></span><br><span class="line">    <span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(c, c.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// 堆操作</span></span><br><span class="line">    <span class="built_in">push_heap</span>()</span><br><span class="line">    <span class="built_in">pop_heap</span>()</span><br><span class="line">    <span class="built_in">make_heap</span>()</span><br><span class="line">    <span class="built_in">sort_heap</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// __gcd 最大公约数</span></span><br><span class="line"><span class="type">int</span> k=__gcd(n,m);<span class="comment">//最大公约数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n * m / k); <span class="comment">//最小公倍数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(a,b);<span class="comment">//返回最大值</span></span><br><span class="line"><span class="built_in">min</span>(a,b);<span class="comment">//返回最小值</span></span><br><span class="line"><span class="built_in">swap</span>(a,b);<span class="comment">//交换a和b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span> (v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),v2.<span class="built_in">begin</span>());<span class="comment">//v1复制给v2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());<span class="comment">//v的值为5，4，3，2，1  倒置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find</span></span><br><span class="line"><span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，</span></span><br><span class="line"><span class="comment">//若存在返回其在向量中的位置</span></span><br><span class="line"><span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br><span class="line">std::vector&lt;std::string&gt; myvector&#123; <span class="string">&quot;www&quot;</span>, <span class="string">&quot;baidu&quot;</span>, <span class="string">&quot;com&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="string">&quot;com&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;no result.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find</span></span><br><span class="line"><span class="comment">// 在容器或范围中查找相邻的重复元素，并返回指向第一对重复元素的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span> <span class="params">(ForwardIterator first, ForwardIterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// count</span></span><br><span class="line"><span class="comment">// count 算法用于计算范围 [first, last) 中值等于 val 的元素个数，并返回这个计数值。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></span><br><span class="line"><span class="function">  <span class="title">count</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 count 统计值为 2 的元素个数</span></span><br><span class="line"><span class="type">int</span> numTwos = std::<span class="built_in">count</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;值为 2 的元素出现次数为: &quot;</span> &lt;&lt; numTwos &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// erase</span></span><br><span class="line"><span class="comment">//从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end()</span></span><br><span class="line">c.<span class="built_in">erase</span>(p)</span><br><span class="line"><span class="comment">//从c中删除迭代器对b和e所表示的范围中的元素，返回e</span></span><br><span class="line">c.<span class="built_in">erase</span>(b,e)</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 自定义比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(age) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p) <span class="type">const</span> <span class="comment">// 注意此处要声明为 const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Age == p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Person&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> num = std::<span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;年龄为 35 的人数为： &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和-差分"><a href="#前缀和-差分" class="headerlink" title="前缀和 &amp; 差分"></a>前缀和 &amp; 差分</h3><p>▲一维前缀和</p><p>对于数组a[1], a[2], a[3], a[4], …… a[n]</p><p>前缀和数组 （即数列Sn）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">s[i] = s[i<span class="number">-1</span>] + a[i]</span><br></pre></td></tr></table></figure><p>异或也有加的性质，也可以用于前缀和</p><p>▲二维前缀和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum[i][j] = </span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]+a[<span class="number">1</span>][<span class="number">2</span>]+a[<span class="number">1</span>][<span class="number">3</span>]+…+a[<span class="number">1</span>][j]</span><br><span class="line">+a[<span class="number">2</span>][<span class="number">1</span>]+a[<span class="number">2</span>][<span class="number">2</span>]+a[<span class="number">2</span>][<span class="number">3</span>]+…+a[<span class="number">2</span>][j]</span><br><span class="line">+……</span><br><span class="line">+a[i][<span class="number">1</span>]+a[i][<span class="number">2</span>]+a[i][<span class="number">3</span>]+…+a[i][j]</span><br></pre></td></tr></table></figure><p>计算公式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum[i][j] = sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j]</span><br><span class="line">子矩阵的和 = s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>▲差分数组（d[k]&#x3D;a[k]-a[k-1]）</p><p>即 a[k] &#x3D; d[1]+d[2]+d[3]+……+d[k]</p><p>对[left,right]都加v，相当于</p><p>d[left] +&#x3D; v;</p><p> d[right + 1] -&#x3D; v;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int left, right;</span><br><span class="line">        cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line">        d[left] += v;</span><br><span class="line">        d[right + 1] -= v;</span><br><span class="line">    &#125;</span><br><span class="line">还原</span><br><span class="line">int additive = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        additive += d[i];</span><br><span class="line">        query[i] = additive;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.lanqiao.cn/problems/2128/learning/">https://www.lanqiao.cn/problems/2128/learning/</a></p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>单调性？ 二段性？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &lt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.lanqiao.cn/problems/2145/learning/">https://www.lanqiao.cn/problems/2145/learning/</a></p><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> base = a;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">0x1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ans *= base;</span><br><span class="line">            ans %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= base;</span><br><span class="line">        base %= p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="越界"><a href="#越界" class="headerlink" title="越界"></a>越界</h3><p>相乘结果输出1410065408，超越int界</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>▲不相交区间问题（或称为区间调度问题、活动安排问题）<br>  给定一些区间（活动），每个区间有左端点和右端点（开始时间和终止时间），要求找到最多的不相交区间（活动）。<br>  以下按“活动安排问题”来解释。<br>  这个问题的目的是求最多活动数量，所以那种持续时间长的活动不受欢迎，受欢迎的是尽快结束的、持续时间短的活动。<br>  考虑以下3种贪心策略：<br>  1）按最早开始时间贪心：先选最早开始的活动a，当a结束后，再选下一个最早开始的活动。这种策略不好，因为它没有考虑活动的持续时间。假如a一直不结束，那么其他活动就不能开始。<br>  2）最早结束时间：先选最早结束的活动a，a结束后，再选下一个最早结束的活动。这种策略是合理的。越早结束的活动，越能腾出后续时间容纳更多的活动。<br>  3）用时最少：先选时间最短的活动a，再选不冲突的下一个最短活动。这个策略似乎也可行，但是很容易找到反例，证明这个策略不正确。<br>  下图的例子，<br>  用“策略1）最早开始时间”，选3；<br>  用“策略2）最早结束时间”，选1、2、5、6；<br>  用“策略3）用时最少”，选4、1、2。<br>  策略2）的结果是最好的。<br>总结活动安排问题的贪心策略：先按活动的结束时间（区间右端点）排序，然后每次选结束最早的活动，并保证选择的活动不重叠。</p><p>▲区间合并问题</p><p>给定若干个区间，合并所有重叠的区间，并返回不重叠的区间个数。</p><p>贪心策略：按区间左端点排序，然后逐一枚举每个区间，合并相交的区间。<br>  定义不重叠的区间个数（答案）为ans。设当前正在合并的区间的最右端点为end，枚举到第i个区间[Li, Ri]时：<br>  若Li≤end，说明与第i区间相交，需要合并，ans不变，更新end &#x3D; max(end, Ri)。<br>  若Li &gt; end，说明与第i区间不相交，ans加1，更新 end &#x3D; max(end, Ri)。区间覆盖问题</p><p>▲区间覆盖问题</p><p>给定一个目标大区间，和一些小区间，问最少选择多少小区间，可以覆盖大区间。<br>  贪心策略：尽量找出右端点更远的小区间。<br>  操作步骤：先对小区间的左端点排序，然后依次枚举每个小区间，在所有能覆盖当前目标区间右端点的区间之中，选择右端点最大的区间。</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans *= a;  <span class="comment">//如果n的当前末位为1，ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><h1 id="C-面向对象补充"><a href="#C-面向对象补充" class="headerlink" title="C++面向对象补充"></a>C++面向对象补充</h1><p>中山大学计算机学院考察面向对象的基础代码能力，故总结。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">classname</span> (<span class="type">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p><p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">double</span> width;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="type">double</span> length;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">( <span class="type">double</span> wid )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承、基类、派生类、多继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span>&#123; width = w; &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span>&#123; height = h; &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;</span><br><span class="line">      <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintCost</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCost</span><span class="params">(<span class="type">int</span> area)</span></span>&#123; <span class="keyword">return</span> area * <span class="number">70</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> (width * height); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="type">int</span> area;</span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ans</span></span><br><span class="line"><span class="comment">// Total area: 35</span></span><br><span class="line"><span class="comment">// Total paint cost: $2450</span></span><br></pre></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>  f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   printData pd;</span><br><span class="line">   <span class="comment">// 输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// 输出浮点数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line">   <span class="comment">// 输出字符串</span></span><br><span class="line">   <span class="type">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> feet;             <span class="comment">// 0 到无穷</span></span><br><span class="line">      <span class="type">int</span> inches;           <span class="comment">// 0 到 12</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 所需的构造函数</span></span><br><span class="line">      <span class="built_in">Distance</span>()&#123;</span><br><span class="line">         feet = <span class="number">0</span>;</span><br><span class="line">         inches = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Distance</span>(<span class="type">int</span> f, <span class="type">int</span> i)&#123;</span><br><span class="line">         feet = f;</span><br><span class="line">         inches = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 显示距离的方法</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">displayDistance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;F: &quot;</span> &lt;&lt; feet &lt;&lt; <span class="string">&quot; I:&quot;</span> &lt;&lt; inches &lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重载负运算符（ - ）</span></span><br><span class="line">      Distance <span class="keyword">operator</span>- ()  </span><br><span class="line">      &#123;</span><br><span class="line">         feet = -feet;</span><br><span class="line">         inches = -inches;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Distance</span>(feet, inches);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 重载小于运算符（ &lt; ）</span></span><br><span class="line">      <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Distance&amp; d)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(feet &lt; d.feet)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(feet == d.feet &amp;&amp; inches &lt; d.inches)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Distance <span class="title">D1</span><span class="params">(<span class="number">11</span>, <span class="number">10</span>)</span>, <span class="title">D2</span><span class="params">(<span class="number">-5</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">   -D1;                     <span class="comment">// 取相反数</span></span><br><span class="line">   D1.<span class="built_in">displayDistance</span>();    <span class="comment">// 距离 D1</span></span><br><span class="line">   -D2;                     <span class="comment">// 取相反数</span></span><br><span class="line">   D2.<span class="built_in">displayDistance</span>();    <span class="comment">// 距离 D2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( D1 &lt; D2 )</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;D1 is less than D2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;D2 is less than D1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ans</span></span><br><span class="line"><span class="comment">// F: -11 I:-10</span></span><br><span class="line"><span class="comment">// F: 5 I:-11</span></span><br><span class="line"><span class="comment">// D2 is less than D1</span></span><br></pre></td></tr></table></figure><h3 id="二元运算符重载"><a href="#二元运算符重载" class="headerlink" title="二元运算符重载"></a>二元运算符重载</h3><p>类内： Box operator+(const Box&amp;);</p><p>类外： Box operator+(const Box&amp;, const Box&amp;);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">( <span class="type">double</span> len )</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setBreadth</span><span class="params">( <span class="type">double</span> bre )</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">( <span class="type">double</span> hei )</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class="line">      Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = <span class="keyword">this</span>-&gt;length + b.length;</span><br><span class="line">         box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">         <span class="keyword">return</span> box;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Box Box1;                <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">   Box Box2;                <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">   Box Box3;                <span class="comment">// 声明 Box3，类型为 Box</span></span><br><span class="line">   <span class="type">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 把体积存储在该变量中</span></span><br><span class="line">   <span class="comment">// Box1 详述</span></span><br><span class="line">   Box1.<span class="built_in">setLength</span>(<span class="number">6.0</span>); </span><br><span class="line">   Box1.<span class="built_in">setBreadth</span>(<span class="number">7.0</span>); </span><br><span class="line">   Box1.<span class="built_in">setHeight</span>(<span class="number">5.0</span>);</span><br><span class="line">   <span class="comment">// Box2 详述</span></span><br><span class="line">   Box2.<span class="built_in">setLength</span>(<span class="number">12.0</span>); </span><br><span class="line">   Box2.<span class="built_in">setBreadth</span>(<span class="number">13.0</span>); </span><br><span class="line">   Box2.<span class="built_in">setHeight</span>(<span class="number">10.0</span>);</span><br><span class="line">   <span class="comment">// Box1 的体积</span></span><br><span class="line">   volume = Box1.<span class="built_in">getVolume</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box1 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">   <span class="comment">// Box2 的体积</span></span><br><span class="line">   volume = Box2.<span class="built_in">getVolume</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box2 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">   <span class="comment">// 把两个对象相加，得到 Box3</span></span><br><span class="line">   Box3 = Box1 + Box2;</span><br><span class="line">   <span class="comment">// Box3 的体积</span></span><br><span class="line">   volume = Box3.<span class="built_in">getVolume</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Volume of Box3 : &quot;</span> &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ans</span></span><br><span class="line"><span class="comment">// Volume of Box1 : 210</span></span><br><span class="line"><span class="comment">// Volume of Box2 : 1560</span></span><br><span class="line"><span class="comment">// Volume of Box3 : 5400</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p><p>纯虚函数：</p><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p><p>&#x3D; 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改之前的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 修改过后的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// pure virtual function</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Rectangle</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Triangle</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改之前的ans</span></span><br><span class="line"><span class="comment">// Parent class area :</span></span><br><span class="line"><span class="comment">// Parent class area :</span></span><br><span class="line"><span class="comment">// 修改之后的ans</span></span><br><span class="line"><span class="comment">// Rectangle class area :</span></span><br><span class="line"><span class="comment">// Triangle class area :</span></span><br></pre></td></tr></table></figure><h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><h2 id="高精度板子"><a href="#高精度板子" class="headerlink" title="高精度板子"></a>高精度板子</h2><p>plus</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;vector&lt;<span class="type">int</span>&gt; b,c;</span><br><span class="line">    string f,g;</span><br><span class="line">    cin&gt;&gt;f&gt;&gt;g;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=f.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=f[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=g.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=g[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        b.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()||i&lt;b.<span class="built_in">size</span>();++i)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;a.<span class="built_in">size</span>())t+=a[i];</span><br><span class="line">         <span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>())t+=b[i];</span><br><span class="line">         c.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">         t=t/<span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(t!=<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         c.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        n++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>minus</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; n, vector&lt;<span class="type">int</span>&gt;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n.<span class="built_in">size</span>() != m.<span class="built_in">size</span>())<span class="keyword">return</span> n.<span class="built_in">size</span>() &gt; m.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (n[i] != m[i])<span class="keyword">return</span> n[i] &gt; m[i];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;c; <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">t = a[i] - t;</span><br><span class="line"><span class="keyword">if</span> (i&lt;b.<span class="built_in">size</span>())t -= b[i];</span><br><span class="line">c.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (t &lt; <span class="number">0</span>)t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c.<span class="built_in">back</span>() == <span class="number">0</span>)c.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a, b, C;</span><br><span class="line">string A, B;</span><br><span class="line">cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(A[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = B.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)b.<span class="built_in">push_back</span>(B[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(a, b))</span><br><span class="line">C = <span class="built_in">sub</span>(a, b);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">C = <span class="built_in">sub</span>(b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">cout &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>multiply</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cheng</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span>&amp; B)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;c; <span class="type">long</span> <span class="type">long</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>())t += A[i] * B;</span><br><span class="line">c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t = t / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">string A;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">cin &gt;&gt; A &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(A[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">cheng</span>(a, b);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">cout &lt;&lt; c[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>div</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cu</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span>&amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        t=A[i]+t*<span class="number">10</span>;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t/B);</span><br><span class="line">        t=t%B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;c.<span class="built_in">back</span>()==<span class="number">0</span>)c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    string A;<span class="type">int</span> b;</span><br><span class="line">    cin&gt;&gt;A&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(A[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> c=<span class="built_in">cu</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=c.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        cout&lt;&lt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>resources</title>
      <link href="/2024/10/15/%E8%B5%84%E6%BA%90/"/>
      <url>/2024/10/15/%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h1><p>整理一些保研时用到的资源</p><p>信息与资讯</p><p><a href="https://github.com/CS-BAOYAN/CSSummerCamp2024">绿群-夏令营</a></p><p><a href="https://github.com/CS-BAOYAN/CSYuTuiMian2024">绿群-预推免</a></p><p><a href="https://csrankings.org/#/index?all&us">CSrankings-学校强弱排序</a></p><p>知识性</p><p><a href="https://csdiy.wiki/">CSDIY-CS求生指南</a></p><p><a href="https://cs-baoyan.github.io/CSBasicKnowledge/">CSBasicKnowledge</a></p><p><a href="https://y-s-organization.gitbook.io/hnu-cs-baoyan">HNU-CS-BAOYAN</a></p><p>刷题</p><p><a href="https://noobdream.com//">N诺-计算机保研考研刷题用</a></p><p><a href="https://leetcode.cn/">力扣-机考刷题网站</a></p><p><a href="https://www.luogu.com.cn/">洛谷-机考刷题网站</a></p><p><a href="https://blog.csdn.net/qq_52384627/article/details/120548489">总结-ACWing基础课程题单</a></p><p><a href="https://zhuanlan.zhihu.com/p/615923570">非常好用的文书模版</a></p><p><a href="https://github.com/stellarkey/912_project/tree/master">912_project-清华大学计算机保研考研工程</a></p><p><a href="https://www.zhihu.com/column/c_1748756039305220097">知乎博客-清华大学计算机保研考研机试</a></p><p><a href="https://www.liuchuo.net/222-2">一个书籍推荐列表</a></p><p><a href="http://cas.web.hnu.edu.cn/">HNU-web-vpn-校外也能访问校内资源</a></p><p><a href="https://www.d2l.ai/">D2L-深度学习入门</a></p><p><a href=""></a></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>这个夏天，我与保研</title>
      <link href="/2024/09/29/Bao-Yan/"/>
      <url>/2024/09/29/Bao-Yan/</url>
      
        <content type="html"><![CDATA[<h1 id="浅记我的保研"><a href="#浅记我的保研" class="headerlink" title="浅记我的保研"></a>浅记我的保研</h1><p>谨以此帖记录近三个月以来的见闻，为这三年的努力画上一个圆满的句号。</p><p>【由于跟院校签了协议，所以有些地方不能写出来，如果你确实想去报考这个院校的话，请私下跟我联系，或者之后可能会单独出一个帖子讲这些题目】</p><p>之后会出一篇文章专门讲我觉得该如何准备推免，本文主要是我本人的个人经历，所以可能没有那么多系统性的干货。</p><h2 id="广告与资源"><a href="#广告与资源" class="headerlink" title="广告与资源"></a>广告与资源</h2><p>【重要】必须要重点推荐绿群QQ（吃水不忘挖井人）：943826679</p><p>【另外】如果你是HNUers，欢迎加入HNU小绿群：439182875</p><p>【再次】如果你是HNUers，这里有本校专用的资源：<a href="https://y-s-organization.gitbook.io/hnu-cs-baoyan">HNU保研</a></p><h2 id="本人定位"><a href="#本人定位" class="headerlink" title="本人定位"></a>本人定位</h2><ul><li>末九cs rk1&#x2F;140+ （推免遴选rk3，故可能会有冲突）</li><li>成绩：92+（具体的分数不重要，主要还是看rk）</li><li>英语：CET4：600+；CET6:：600+</li><li>编程：CSP：前6%</li><li>奖学金：连续两年国奖（最终是连续三年国奖）</li><li>竞赛获奖：有数模、数竞、蓝桥杯水奖</li><li>科研项目：两个水项目，无科研产出</li></ul><p>目标：清北可尝试即可，华五计院&#x2F;学硕优先，华五软可接受，华五专硕可接受，浙软南软低优先，华五弱组&#x2F;坑导可接受。中九计院、中九软院次之。本校保底。不接受任何直博。随情况再调整。</p><p>夏令营目标：拿下中山作为保底</p><p>预推免目标：冲刺华五，尝试清北</p><h2 id="最终去向"><a href="#最终去向" class="headerlink" title="最终去向"></a>最终去向</h2><img src="/2024/09/29/Bao-Yan/baoyan-1.png" class="" title="最终去向"><h2 id="情况总览"><a href="#情况总览" class="headerlink" title="情况总览"></a>情况总览</h2><p>参营院校</p><table><thead><tr><th>院校</th><th>入营</th><th>优营效力</th><th>结果</th><th>实际获得</th><th>操作</th></tr></thead><tbody><tr><td>同济电院</td><td>夏令营入营</td><td>仅排序</td><td>优营40+&#x2F;92</td><td>学硕offer</td><td>928放弃</td></tr><tr><td>成电计院</td><td>夏令营入营</td><td>双选后铁offer</td><td>优营40+&#x2F;100</td><td>学硕offer</td><td>905放弃</td></tr><tr><td>人大信院</td><td>夏令营入营</td><td>仅排序</td><td>优营30+&#x2F;72</td><td>wl（929补到）</td><td>929-11点补到&#x2F;放弃</td></tr><tr><td>上交电院</td><td>夏令营入营</td><td>仅排序</td><td>优营100+&#x2F;123</td><td>wl（929补到）</td><td>919放弃</td></tr><tr><td>中山计院</td><td>夏令营入营</td><td>铁offer</td><td>优营30+&#x2F;400+</td><td>学硕offer</td><td>926放弃</td></tr><tr><td>国防科大计院</td><td>夏令营入营</td><td>仅排序</td><td>优营170&#x2F;467</td><td>硕士offer</td><td>904放弃</td></tr><tr><td>南大计院</td><td>预推免入营</td><td>铁offer</td><td>预推免批次wl</td><td>wl（927补到专硕offer）</td><td>929接受复试，拒绝录取</td></tr><tr><td>清华软院</td><td>预推免入营</td><td>铁offer</td><td>初步录取</td><td>专硕offer</td><td>最终去向</td></tr><tr><td>浙大工院</td><td>预推免候补入营</td><td>铁offer</td><td>总批次wl前10</td><td>wl（929实际补到）</td><td>928未填系统，默认放弃</td></tr><tr><td>湖大信院</td><td>预推免入营</td><td>铁offer</td><td>预推免批次前5（offer）</td><td>学硕offer</td><td>928未填系统，默认放弃</td></tr></tbody></table><p>考虑院校</p><p>（空格处表示没有考虑或没有交集，情况包含了一些自己打听获取到的信息）</p><p>一般为高校的计算机学院、软件学院、AI学院（一般为新成立），或是电院（常见于上海的学校，上交同济等）</p><table><thead><tr><th>层次</th><th>院校</th><th>夏令营</th><th>预推免</th><th>情况</th></tr></thead><tbody><tr><td>清北</td><td>清华叉院</td><td></td><td>不开</td><td>计科最高bar，自认为实力不符</td></tr><tr><td></td><td>清华计系</td><td>不发offer</td><td></td><td>计科最高bar，自认为实力不符</td></tr><tr><td></td><td>清华AI</td><td></td><td>不开</td><td>24年新开的学院，bar未知，但清华的title+AI相关，估计bar很高，没敢报</td></tr><tr><td></td><td>清华软院</td><td></td><td>入营优营</td><td>之前本校有学长学姐的去向，遂尝试，也是我的最终去向</td></tr><tr><td></td><td>清深计科</td><td></td><td>未过初筛</td><td>我错过时间未投递。本专业持有rk1投递，优营，据说只发19个优营，含金量非常高。</td></tr><tr><td></td><td>清深AI</td><td>未过初筛</td><td>未投递</td><td>本专业持有rk1投递，均未通过</td></tr><tr><td></td><td>清深大数据</td><td>未过初筛</td><td>未过初筛</td><td>本专业持有rk1投递，均未通过</td></tr><tr><td></td><td>北大叉院</td><td></td><td></td><td>计科最高bar，自认为实力不符</td></tr><tr><td></td><td>北大计院</td><td></td><td></td><td>计科最高bar，自认为实力不符</td></tr><tr><td></td><td>北大AI</td><td></td><td></td><td>21年成立，同样由于title+AI，估计bar很高，没敢报</td></tr><tr><td></td><td>北深信工</td><td></td><td></td><td>弱com，需要联系导师，遂未报</td></tr><tr><td></td><td>北大软微</td><td>初筛过，论文筛寄</td><td></td><td>bar比较高。6.20晚给通知要读论文，特意避开了最卷的方向，但6.28没收到进一步邮件，被默拒</td></tr><tr><td>华五</td><td>南大计院</td><td>初筛过，线上机考寄</td><td>初筛过，线上机考过，最终wl</td><td>线上机考考研难度，对专业课要求极高。本年夏令营本专业放到rk3，；预推免的bar更低，更容易拿优营或者前排wl（仅仅是本次，不可以认为一直是），但优营很少（100人发10offer左右）</td></tr><tr><td></td><td>南大AI</td><td>未过初筛</td><td></td><td>似乎bar较高，机考考核算法+机器学习python实现。本专业持有rk1投递，教务打电话询问，后称“没关系的”，均未通过</td></tr><tr><td></td><td>南大软院</td><td>过初筛</td><td>放弃</td><td>南软夏令营会发offer，但预推免offer数量就很少了（70人发5offer）。夏令营时和人大信院&#x2F;成电冲突，遂放弃；预推免时与南计冲突，只可去一个，遂放弃。听说预推免全员wl，很抽象</td></tr><tr><td></td><td>南大智科（苏州）</td><td>放弃</td><td>放弃</td><td>难度大，似乎50人左右入营发不到15个优营，本校入营同学未获得优营。夏令营时与南软冲突，放弃；预推免时与南计冲突，只可去一个，放弃</td></tr><tr><td></td><td>复旦计院</td><td>未过初筛</td><td>未过初筛</td><td>bar极高，本专业只放核心rk1入营，本校其他专业的rk1最终候补到了学硕，身边其他人都没过。我被双杀，离谱。</td></tr><tr><td></td><td>复旦大数据</td><td></td><td></td><td>bar较高。复旦只可投递一个，冲突。本专业持有rk1入营且优营。</td></tr><tr><td></td><td>复旦类脑</td><td></td><td></td><td>bar未知。复旦只可投递一个，冲突。其他专业有rk1得到优营但放弃。</td></tr><tr><td></td><td>上交电院（计算机系）</td><td>入营且wl</td><td>不开</td><td>bar极高，本校只放1人入营。上交很重视机考，我机考炸了，故wl。机考100分+面试100分，有斩杀线，低于120分斩杀，高于120分全进候补。今年据说鸽到蛮后面。52学硕+20专硕，但我位次95+的同学补到了专硕。</td></tr><tr><td></td><td>上交电院（软件）</td><td>冲突</td><td></td><td>bar较高，比计算机系低一些，放本专业和软件rk1入营。据说要读论文，机试非常难。有斩杀线，第一天机考低于20分直接不予面试。</td></tr><tr><td></td><td>上交AI院</td><td></td><td></td><td>bar极高，第一年开，只放985纯计科rk1（华五多放几个）进。但很容易优营。机试非常简单，据说还有很社死的做游戏环节。有斩杀线，低于120被斩杀。我看到wl只有6人，知道必被鸽穿，果然927被鸽穿。</td></tr><tr><td></td><td>浙大计院</td><td>只开直博</td><td></td><td>直博弱com，夏令营做项目，重视科研。硕士只开预推免且只有面试，929当天几乎鸽穿。（位次倒数的同学929中午左右补到了但已经去了别的地方）</td></tr><tr><td></td><td>浙大软院</td><td>入营放弃</td><td></td><td>在浙江宁波。夏令营发优营和卓越营员（不等于offer），预推免听说机考今年有近乎三分之一的满分，一百多人。929没被鸽穿。</td></tr><tr><td></td><td>浙大工院</td><td></td><td>候补入营+wl</td><td>bar比较迷，我是候补入营的，一开始没放我进去。夏令营&#x2F;预推免只能进一个。只有面试，我在候补靠前，929当天能补到。</td></tr><tr><td></td><td>浙大大数据</td><td></td><td></td><td>在浙江海宁，没想去。</td></tr><tr><td></td><td>中科大计院（11系）</td><td>不可兼报</td><td></td><td>bar基本能放到rk3。应该能进，但是没投递（因为联系了6系的实验室，故投递了6系）</td></tr><tr><td></td><td>中科大信院（6系）</td><td>未过初筛</td><td>未过初筛</td><td>bar很高。只放了计科核心rk1入营。后来学长说计科去是类似跨专业，故只掐尖。</td></tr><tr><td></td><td>中科大AI与大数据</td><td>不可兼报</td><td></td><td>bar应该很高，只放了智能专业rk1入营。而且要双选才有效，本校同学未双选优营失效。</td></tr><tr><td></td><td>中科大先研院</td><td>不可兼报</td><td></td><td>未详细了解</td></tr><tr><td></td><td>中科大苏高院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>人大高瓴</td><td></td><td>不开</td><td>bar很高，本校无人入营。注意人大高瓴学硕&#x2F;直博三个赛道，且不可随意变更。</td></tr><tr><td></td><td>人大信院</td><td>wl</td><td>不开</td><td>bar很高，本校学硕入营1人，专硕入营2人。专硕929中午候补到，据说当天鸽到50+，几乎鸽穿。注意人大信院学硕&#x2F;专硕&#x2F;直博三个赛道，且不可随意变更。</td></tr><tr><td>C9</td><td>哈工深计院</td><td>未过初筛</td><td>放弃</td><td>bar很高，夏令营本校无人入营。夏令营只放40人入营，教务称“生源质量很好”，预推免开了三批，显然被鸽穿。预推免放我进入，但与南计冲突，拒绝。</td></tr><tr><td></td><td>哈工本计院</td><td></td><td></td><td>bar还行，好像筛985生源。未投递，不想去北方（虽然最后还是去了北方的学校）</td></tr><tr><td></td><td>哈工威计院</td><td></td><td></td><td>bar不高，计科有rk10+入营。我未投递，感觉优先级低于本校。</td></tr><tr><td></td><td>西交计院</td><td>宣讲营</td><td></td><td>bar不高，本校rk10+都可。弱com，与老师谈好即可，预推免走形式即可。</td></tr><tr><td></td><td>西交软院</td><td></td><td></td><td>bar不高，985都可。弱com，钱塘潮每年名场面贡献指定。</td></tr><tr><td>985</td><td>同济电院</td><td>优营</td><td></td><td>bar极高，只放rk1，人称“小复旦”，优营率高且稳，适合高rk用来保底</td></tr><tr><td></td><td>同济软院</td><td></td><td></td><td>bar很高，本校有人入营。但夏令营优营无效力，直通预推免</td></tr><tr><td></td><td>同济无人系统中心</td><td></td><td></td><td>bar未知。出的太晚，我已报电院</td></tr><tr><td></td><td>北航计院</td><td>宣讲营</td><td>929面试</td><td>bar还可，今年本校很多上岸北航的同学。</td></tr><tr><td></td><td>武大计院</td><td>入营放弃</td><td></td><td>bar较高，本专业有优营。机考和面试并重。我与sjtu冲突，放弃，优营率很高。</td></tr><tr><td></td><td>武大国重</td><td></td><td></td><td>bar尚可，本专业低rk最终去向。优营率较低，据说本校无人夏令营优营。</td></tr><tr><td></td><td>华科计院</td><td>只招直博</td><td></td><td>bar较低，预推免时基本上本校都可以去。929被鸽穿，晚上还在招人。我已有同济优营，不想去武汉，故未报。</td></tr><tr><td></td><td>华科AI院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>东南电院</td><td>只有8月末夏令营+预推免</td><td></td><td>bar不高，本校有同学最终去向。我已有同济优营，故未报。</td></tr><tr><td></td><td>中山计院</td><td>优营</td><td></td><td>bar不高，本专业基本放到rk10，最终本专业夏令营去了10人。夏令营优先级大于预推免，由于年年鸽穿，故候补基本上等于offer。今年929又被鸽穿，夏令营拿候补都能补到。</td></tr><tr><td></td><td>电科计院</td><td>优营</td><td></td><td>夏令营发100优营，预推免发100优营。据说分组打分差异大。成都离家太远，故没想去这里发展。</td></tr><tr><td></td><td>南开计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>南开软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>南开AI院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>天大计院</td><td></td><td></td><td>天大杯xcpc邀请赛，大海营，有线上机考，通过方可去线下，听说优营效力没那么高</td></tr><tr><td></td><td>北理计院</td><td></td><td></td><td>听说都是内部消化了</td></tr><tr><td></td><td>北理叉院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>山大计&#x2F;AI院</td><td>宣讲</td><td></td><td>未详细了解</td></tr><tr><td></td><td>山大软院</td><td>宣讲</td><td></td><td>未详细了解</td></tr><tr><td></td><td>山大数据科学</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>华东师大计院</td><td>未入营</td><td></td><td>bar神奇。我作为本校唯一rk1未入营，据说要联系导师才可入营。</td></tr><tr><td></td><td>华东师大软院</td><td>未入营</td><td></td><td>bar极高，本校rk1入营，以rk3投递未入营。</td></tr><tr><td></td><td>华东师大数据科学与工程学院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>厦大信院</td><td>未入营</td><td></td><td>bar很迷。唯一rk1投递未入营（总不能是oq了吧），似乎要联系导师（但是老师都不回复）</td></tr><tr><td></td><td>厦大AI院</td><td></td><td></td><td>bar很迷。需要厦大老师推荐信（但是老师都不回复）</td></tr><tr><td></td><td>中南计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>北师AI院</td><td></td><td></td><td>bar很低。感觉可以旅游营，但是太累了，不想再去一次北京了，遂没报。</td></tr><tr><td></td><td>西工计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>西工软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>川大计院</td><td></td><td></td><td>行程硬控5天，太难受，遂没报。只有一个线下机考两个小时，</td></tr><tr><td></td><td>川大国重</td><td></td><td></td><td>bar不高。入营20人，约招8人，后来发现其实可以投着试试的，挺可惜。本校有人去了这个，应该拿到了优营。</td></tr><tr><td></td><td>华南理工软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>东北计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>东北软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>吉大计院</td><td></td><td></td><td>夏令营第一个开，被很多人拿来练手。</td></tr><tr><td></td><td>吉大软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>吉大AI院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>重大计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>重大卓工</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>大工计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>大工软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>湖大信息</td><td>入营放弃</td><td>优营</td><td>今年不提供本校保底，甚至把本校在预推免靠前的同学放在候补。若未及时点击确认不保证录取。</td></tr><tr><td></td><td>国防科大计院</td><td>优营</td><td></td><td>bar不高，rk10左右也能去。夏令营分两批次，按分数合并。估计也能鸽穿。</td></tr><tr><td>211</td><td>北邮计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>北邮AI</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>西电</td><td></td><td></td><td>未详细了解</td></tr><tr><td>研究院所</td><td>中科院计算所</td><td></td><td></td><td>bar很高。未报名，感觉不配</td></tr><tr><td></td><td>中科院自动化所</td><td>入营放弃</td><td></td><td>bar很高。入营，紫东初阳大模型研究中心推荐我入营的，该中心2022年成立。当时太累了放弃了。</td></tr><tr><td></td><td>中科院软件所</td><td></td><td></td><td>未入营，感觉只招软件，同校软件很多入的，应该是筛软件了</td></tr><tr><td></td><td>中科院信工所</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>中科院深先所</td><td></td><td></td><td>未详细了解。被称为“神仙所”。</td></tr><tr><td></td><td>中科院杭高院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>中科院上高院</td><td></td><td></td><td>未详细了解</td></tr></tbody></table><h2 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h2><p>总结：基本符合预期，拿下了中九的保底offer。为预推免冲华五奠定了良好的基础。</p><h3 id="6-28-同济电院"><a href="#6-28-同济电院" class="headerlink" title="6.28 同济电院"></a>6.28 同济电院</h3><p>时间线：</p><ul><li>6.28 报到</li><li>6.29 机试+笔试+专业英语</li><li>6.30 面试+面试英语</li><li>7.5 优营结果公示，有优营</li><li>9.10 告知老师放弃，老师说愿意等我再考虑一下（感谢老师！）</li><li>后续：告知老师确认放弃，得到老师的祝福（老师人真的好好）</li></ul><p>入营情况&amp;优营效力：</p><ul><li>（官方说法）：6月28日至30日，我院第十三届全国优秀大学生暑期学校在嘉定校区圆满举行。本次暑期学校共有230所高校的3166名学生报名，经过专家组筛选，451名学子从全国75所国内重点高校中脱颖而出，包括哈尔滨工业大学、西安交通大学、西北工业大学、厦门大学、中南大学、四川大学、南开大学、山东大学、东北大学、东南大学、北京理工大学、华南理工大学等知名高校。（然而没有本校）</li><li>入营的bar比较高，感觉末九只放各专业rk1进（不限定计科），本专业rk3未入营，本校只放计科、信安、软件rk1共3人入营。入营还搞了一个很长的候补队列。</li><li>入营即offer，只是把入营者进行了一个排序。计算机科学与技术入营92学硕30专硕，全部给了优营。</li></ul><p>考核：</p><p>机试40分+笔试60分+面试150分+专业英语50分+面试英语50分</p><p>机试（40分，1.5小时）纯送分题</p><ul><li>10分，给字符串，要求按照规定格式输出，for循环即可解决。</li><li>15分，数独寻找冲突，分别找出行列宫的第一个冲突的地址，for循环即可解决。</li><li>15分，打印数字三角形，若打表机试部分0分处理，必须使用递归完成。递归即可。</li></ul><p>笔试（60分专业课+50分专业英语，总共1.5小时，完全来不及）：</p><p>专业课（完整考察408，均有考到，《王道》难度，不少原题）20选择10填空10判断4大题，大题5分一题其余1分一题。</p><ul><li>数据结构大题考察求从树根到某点S的路径，典型的数据结构考研题。</li><li>OS大题考察写PV，经典的爸爸妈妈儿子女儿句子苹果问题。但是我好像写的不太对。</li><li>计组大题考察微指令，全空着了。</li><li>计网大题给一个MAC数据报，要求还原MAC源地址，IP地址，TCP的具体状态码（ACK&#x2F;FIN&#x2F;SYN这些，多选），最可能是哪种IP协议（ICMP&#x2F;DHCP等），抽象，考研题都会给格式结构的，这直接要求默出来。这道题也是空着了。</li></ul><p>专业英语（新闻报道类文章20分+论文原文30分，分别是4道题目和3道题目）</p><ul><li>新闻报道类大概是讲了一个科学家很喜欢看论文，最后一年看了八百多篇论文，问她怎么开始喜欢看论文的，等等细节问题，感觉像高中的细节搜索题，最后有个开放问题问读论文有什么好处。</li><li>论文是关于大模型幻觉的。直接问论文的motivation，作者的方法，以及为什么这个方法能excel。感觉就是最基本的阅读英文论文的报告。</li><li>主要时间太紧了，根本没来得及看全原文，只能瞎写一些上交了，但看到同学基本都写满了，还分点写的，心里很不是滋味，当天晚上心里很难受。</li></ul><p>面试（150分专业综合+50分英文面试，不同组考核的差别较大）</p><ul><li>please introduce yourself in two minutes.</li><li>你如何看待人与人之间的“边界感”，如果你在组会上发现更好的方法，是否要当场给同学指出来（这位同学不太希望被当场指出）。</li><li>讲讲项目，深入探讨，感觉可能有点问穿了。包括项目细节（细节确实可以看出来有没有认真参与）。事后查阅了电院官网，发现这位老师（还是面试组长）就是做这个方面的，属于是小方向上的同行，运气真好，这都能遇上。不过可能老师照顾我，属于是没有继续问，给我留了点面子。</li><li>CSDN博主，是做综述性的工作，还是创新性的工作（回答是综述性的工作，主要在做总结与分享）</li><li>这时候基本在消磨时间了：优秀学生干部，都干了啥（感觉我说太多了，组长老师有点愣，下次说一项就可以了）</li><li>联系老师了没有？回答联系了某老师，对某实验室比较感兴趣。（后来才知道该老师的助理教授就在下面坐着）</li><li>问这个方向跟我本科经历不太契合？回答泛深度学习方向都可以研究，可以往导师的方向上靠，和研究导师指定的方向，我说我的兴趣主要集中在深度学习的大模型方向和计算机视觉方向，这两个我都可以做。</li></ul><p>流水日记：</p><ul><li>6.28 从杭州出发，晚上到达上海，转地铁转了好久才到嘉定，有学长在酒店大堂等待我们并给我们发参营用品。有一件衣服（很大气，用料很好，可以经常穿），一本笔记本，一个很好看的同济大学的帆布袋，一支笔还有一沓餐券（狠狠夸奖同济的餐食，中餐晚餐餐券25元，早餐餐券8元，真的好吃的不得了）。同济的酒店定在格林豪泰，两人一间，我跟同校信安的同学一起住。晚上下雨，前往同济校园稍微转了转，但是吃饭的时候食堂已经关了，遂随便解决了一下。同济的校园很大，有一个护城河一样的河流。有很多高楼，有一个很大的操场，很有校园氛围。</li><li>6.29 早上开营仪式+参观实验室。开营仪式水过去了，实验室只参观了两个感兴趣的。看了一个在地下室的偏雷达探测的实验室，然后看了一个类脑研究的实验室。下午机试+笔试。机试难度太低了，基本上直接AC了，我对于数独那道题理解一开始有点偏差，多花了点时间，考场很多人就直接离开了。笔试难度尚可，但是时间太少了。我先做的英语第一篇，再做专业课，最后补做英语第二篇。英语第二篇没有完卷。然后整个晚上都处于一种抑郁的状态。考完后跟同学一起逛了校园，今天晴天，夏日的微风轻拂过，再加上黄昏的夕阳，同济的校园显得很美。但我当时感觉这个笔试的发挥不一定能来了，所以心里无限感伤。当时心里挺难受的，渴望，但又感觉大势已去，有种说不出来的感觉。</li><li>6.30 早上面试，我在比较靠前的位置，本来以为能在中午吃饭之前面试的，结果了正好到我的时候老师就去吃饭了。这意味着我是下午第一个接受面试的，一想到老师酒足饭饱之后精神焕发来拷打我，就不寒而栗。我没吃中饭，因为吃饱饭之后人容易发昏。多出来的这半个小时左右的时间我跑到了四楼去自己跟自己说话，从头演练了一遍可能被问到的问题然后自己回答，包括英语问题都演练了一遍。然后面试总体比较顺利，面试完后回到食堂好好地吃了一顿。离开的时间同济又是大雨，我匆匆忙忙地坐着嘉松线离开了嘉定。感觉对于同济，真是非常的喜欢。</li><li>7.5 早上在人大信院报道时看到，优营中间。</li><li>7.6 晚上手动排序了一下，共92个优营，排位40+，中偏前。总共112人，发了92个优营，真的是80%优营率。</li><li>7.4 老师联系我，问是否确定之后来，我说想试试上交，老师表示理解。</li><li>感觉同济是最值得投递的学校，对于rk1非常友好，是一个很稳很稳的保底选择，有了同济的优营之后，我在参加其他学校的夏令营的时候心态上都比较稳，有助于更好的发挥。</li></ul><img src="/2024/09/29/Bao-Yan/baoyan-tongji2.png" class="" title="同济大学"><img src="/2024/09/29/Bao-Yan/baoyan-tongji1.png" class="" title="同济大学夏令营发放的礼包"><img src="/2024/09/29/Bao-Yan/baoyan-tongji3.png" class="" title="同济电院欢迎参加夏令营同学们"><img src="/2024/09/29/Bao-Yan/baoyan-tongji4.png" class="" title="同济发的餐券，很大气，能吃的很饱"><img src="/2024/09/29/Bao-Yan/baoyan-tongji5.png" class="" title="同济的饭菜非常好吃"><h3 id="7-3-成电计院"><a href="#7-3-成电计院" class="headerlink" title="7.3 成电计院"></a>7.3 成电计院</h3><p>时间线：</p><ul><li>7.3 报到</li><li>7.4 面试</li><li>7.5 结果：在人大信院考完机考之后考笔试之前看到，优营。晚上数了一下40+&#x2F;100的位置。</li></ul><p>总评价：抽象，只有7.4的一场面试，有主持人，主持人会引导面试过程进行。</p><p>另外：成电取得优营之后还要联系老师并通过老师的考核，这样才能找到自己心仪的老师。</p><p>面试：</p><ul><li>（1）三分钟自我介绍，可以中文或者英语（据说用英语会更有好处，故我选择用英语进行介绍）</li><li>（2）英语问答：</li><li><ul><li>why do you choose 成电 university？（很难绷，我都把UESTC的英文全称拼全了，老师给我来了个成电University）</li><li>how many dream schools do you have？（前面我自我介绍里提到成电has always been my dream school，老师跟这个杠上了，之后的英语问题都围绕这个展开）</li><li>do you apply 华五 or 北京的学校？（自然是我对成电一心一意，my only love，老师都没绷住，笑了）</li><li>what’s your advantage?（瞎扯一些）</li></ul></li><li>（3）专业问题：运气比较好，抽到了简单的算法题，刚好会回答。 （算法）数轴上有n个区间（li, ri），选择尽量多的区间，使得这些区间两两不相交。</li><li>（4）简历问题：</li><li><ul><li>主要拷打了我其中的一个项目，附加拷打了另一个项目。（提问这个的老师很不耐烦，闭着眼睛似乎在想别的事情）</li><li>CSDN博主：你做了几年了？你如何回复他人的提问。</li></ul></li><li>时间还有一分钟结束，主持人说如果我没有补充，就可以出去了。</li></ul><p>总体感觉：</p><p>成电是我经历的最不像夏令营的一个学校，它完全可以直接称为是一个“面试”，核心部分也就只是一场面试而已。但是成电是一个很好的学校，校园景色也十分优美，作为我的第二站，真的很有校园氛围的感觉（除了本校，都有校园氛围感doge）。</p><img src="/2024/09/29/Bao-Yan/baoyan-uestc-1.png" class="" title="在住的地方远眺成电全景"><img src="/2024/09/29/Bao-Yan/baoyan-uestc-2.png" class="" title="等候室，这个教室很新，我很喜欢"><img src="/2024/09/29/Bao-Yan/baoyan-uestc-3.png" class="" title="成电校园景色一角，建筑各有特色"><img src="/2024/09/29/Bao-Yan/baoyan-uestc-4.png" class="" title="成电结束后，一晚上直飞北京，挑战的就是一个极限"><h3 id="7-5-人大信院"><a href="#7-5-人大信院" class="headerlink" title="7.5 人大信院"></a>7.5 人大信院</h3><p>时间线：</p><ul><li>7.5 报到，机考</li><li>7.6 面试</li><li>7.7 坐动车离开北京</li></ul><p>优营效力：入营130，到场86，优营71，只排序不定性（即不发优营&#x2F;offer&#x2F;候补等）</p><p>7.4晚上21：30从成都双流飞北京大兴，睡下已经1:00了。7.5早上7点起床，换乘3趟地铁到海淀黄庄下，到人大信院报道。7.5中午开营然后下午马上机试笔试，7.6早上面试，先集体群面，全部群面完之后再单面。</p><p>补充：人大提供住宿，这一点对于中关村附近非常重要，一晚上300多的住宿真的扛不住。然后还附赠的是人大的入校权限，预约几乎不可能成功的。</p><p>考核要求：数据结构与算法（80分）+程序设计机考（20分，支持C&#x2F;C++&#x2F;Python【python只支持最基本库】）专业课及综合素质面试（150分）英语口试（50分）</p><p>【占比20分】机考（1小时3道题，时间很赶）：</p><ul><li>（1）收集雨滴问题：几个挡板中拿出两个来，能聚集最多的水。暴力80分。【这道题是LeetCode上经典的问题，但当时我没练，所以只会暴力骗分】</li><li>（2）大模拟：实现高考的赋分制，还要查询。主要逻辑都写出来了，拿了50分，没有敲一分一段对应的，时间来不及了。</li><li>（3）称重问题，n个砝码，每种分别重x[i]，每种有y[i]个，问有多少种可能的情况。暴力30分。</li></ul><p>【占比80分】笔试（1.5小时，时间太宽裕）：</p><p>【由于保密协议，略过】考察了基础408问题，很简单，稍微过一遍408的数据结构就能全部答上来。</p><p>面试：</p><p>群面：</p><ul><li>（1）怎么看待gpt对于研究生阶段学习的意义？（好处、坏处）</li><li>（2）如果研究生阶段你研究的课题真的无法开展，真不会，该怎么办？</li><li>（3）遗漏</li><li>（4）数据隐私与数据需求的矛盾，怎么去平衡？（即现在企业中需要用户的数据去训练模型，但是用户的数据隐私性很重要，你怎么看待这个问题）</li><li>每个问题最多3人回答，共9人，第一轮必须每人回答一次。总共15分钟，时间够到问了4个问题，我只回答了第二个问题，但是我是第一个回答的，后面两个人基本是在重复我的论点。</li></ul><p>单面：</p><p>（只有10分钟，感觉时间确实太短了。本来是两天面试，但是全部压缩到一天，导致本来能面15分钟现在只能面试10分钟）</p><p>上来直接抽信封，我选的9号。可能之前成电抽题运气太好了，这次题目都不太会回答。</p><p>【占比50分】英语：</p><ul><li>（1）对于Sora、GPT等大模型，你怎么看待？（这个感觉跟群面时候的题目是一样的）我回答的可以便利研究工作，让我们聚焦精力在有必要的研究上。（感觉回答不够丰富）</li><li>（2）专业问题：system software 和 application software的区别？（刚听到有点懵逼）应该问的是系统软件和用户软件有什么区别。我回答system software runs in system level, which connects hardware and application software 并且处理I&#x2F;O operations 等。然后 application software runs above system software, which connects system software and user 并且把user的意图传递给system。（感觉我基本能讲清楚，就是英文表达不太顺畅）</li><li>感觉英文问题总体回答还算正常，但是比较磕磕绊绊，显得不太熟练，与四六级双600有很强的对比。</li></ul><p>【占比150分】专业</p><ul><li>专业真的一团糟</li><li>（）解释数据结构中的堆结构？然后问堆的应用？我说堆是用二叉树实现的，然后有小根堆和大根堆。但是我不知道为什么脑子一抽，提了一句红黑树，后来又给自己否定了。说堆可以运用在希望获得从小到大序列或从大到小序列的场景。（后来查到优先级队列、topk问题、排序等都是应用场景，当时都没答上来）</li><li>（）解释前缀编码和哈夫曼树？我说我不知道前缀编码（后来知道是哈夫曼树是前缀编码的具体实现）。然后哈夫曼树我解释了，是根据词频，词频较大的优先编码。</li><li>（）解释单源最短路径dijkstra算法？dijkstra算法是否能运用在外卖领域？这里我的回答是很大的败笔。我先在解释dijkstra算法，但是解释了一会儿，后面的老师说这道题的问题在能否运用到外卖领域。我脑子抽了，我直接回了一句，“不是要先解释dijkstra算法嘛”，因为根据我的理解，我确实听到了老师的问题是先解释dijkstra算法再问能否运用到外卖领域。然后老师让我继续，这老师应该是提醒我重点不要偏了，给我机会我没把握住。后面我快速解释了dijkstra，然后说可以运用到外卖领域上。然后我脑子又抽了一下，说但是我认为可以用A*算法去优化这个。</li><li>然后另一个老师就问我，你认为为什么<code>A*</code>算法可以比单源最短路径有更好的效果。我说如果引导函数提供得当的话，<code>A*</code>算法会更具有优势。老师继续深入问我具体在哪方面呢，因为算法对比肯定要有一个统一的标准，不能用额外的东西来提供优势。我没有给出进一步回答，只是重复了引导函数的优势。老师继续问我从时间复杂度上或者空间复杂度上怎么体现出优化，<code>A*</code>算法能达到多少，dijkstra算法是多少。我回答dijkstra算法如果不经过堆优化的话，是<code>(|V|+|E|)log|V|</code>，<code>A*</code>算法我不太清楚。但是我认为单源最短路径只是针对静态的，而A*算法可以随时根据目标进行调整，毕竟外卖是一个动态的过程。此时老师还想继续问，但是时间到了，老师马上停止提问了。</li><li>我感觉专业课一团糟，我表现的像一个没有深入思考的人。而且这些问题都是较简单的问题，我答成这个样子，真的很说不过去。还有脑子抽了，太急了。后来跟其他人交流了解到如果不会，其实可以直接跟老师说不会，这样就可以听到后面的问题，有更多的机会展示自己。然后其他人都问到简历了，我的专业课时间太久了，所以简历都没有面到，真的很烦，感觉很好的一次机会就因为我的不理智浪费掉了。</li></ul><p>美丽的RUC校园：</p><img src="/2024/09/29/Bao-Yan/baoyan-ruc-2.png" class="" title="明德楼前的标志性校徽"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-3.png" class="" title="中国人民大学！"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-4.png" class="" title="世纪馆，以及体育场"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-14.png" class="" title="党办的大学，让党放心"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-5.png" class="" title="I love RUC ！"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-9.png" class="" title="雄伟的明德楼（绿群的群友都在说明德楼前一堆鸽子hhh）"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-10.png" class="" title="崇德楼，与明德楼各有特色"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-7.png" class="" title="RUC提供给夏令营同学的宿舍，很温馨"><p>北京的其他地方：</p><img src="/2024/09/29/Bao-Yan/baoyan-ruc-11.png" class="" title="夏日午后的海淀路，这个路牌画风好像动漫里那种感觉"><p>既在北京，没理由不朝圣清北。但是来之前都在准备复试，没有预约门票，显然是没法进去的。</p><img src="/2024/09/29/Bao-Yan/baoyan-ruc-12.png" class="" title="借用一个流行说法：京城双日凌空-天下第一文宗-未名琳琅阁"><p>当时还不知道，与清华的缘分在后面还有，只是抱着朝圣的心态，觐见了每一个学子的梦想。没法进到二校门，只能在西门口草草拍了一张照片，以证明我来过。</p><img src="/2024/09/29/Bao-Yan/baoyan-ruc-13.png" class="" title="借用一个流行说法：京城双日凌空-天下第一武宗-清泉春晖殿"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-6.png" class="" title="大兴国际机场，当年高考八省联考模拟的数学题也是亲眼见到了"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-1.png" class="" title="海淀黄庄地铁站，听闻已久的卷王中心"><img src="/2024/09/29/Bao-Yan/baoyan-ruc-8.png" class="" title="中关村的双向八车道地下隧道"><h3 id="7-10-上交电院计系"><a href="#7-10-上交电院计系" class="headerlink" title="7.10 上交电院计系"></a>7.10 上交电院计系</h3><p>时间线：</p><ul><li>7.9 动车前往上海</li><li>7.10 机考</li><li>7.11 面试</li><li>9.10 放弃直硕优秀生源</li></ul><p>总体评价：好不容易有几个赏识我的老师，却配上一个差地不能再差的机考成绩。</p><p>机考：</p><p>上交电院的机考是我见过难度最高的，主要在于每道题都只给一段时间做，做完了也只能等着，没做完时间到了之后就没法回来做了。这样就没法对时间进行重分配以拿到更高的分数，对于能否一遍把代码逻辑完全写对、以及现场debug是一个很严重的挑战。你需要把代码写地又快又好。机考不允许携带任何资料。</p><p>机考环境是使用头哥平台，这个平台很抽象，它有些错误不会报错，如果有问题，它就直接不显示输出了，这让我没办法进行debug，所以第二题就没有调出来。再加上时间很紧迫，故整个过程心态很炸裂，结束后我知道基本上没戏了，遂在电院旁的湖边跟同学打了一个小时的电话，遗憾这一次上交之行。</p><p>由于【保密要求】我不得泄露试题，我只能大概泛泛讲讲内容。</p><p>机考试题：</p><ul><li>第一题：类似于单源最短路径加上一个附加的条件，做一些改动。</li><li>第二题：对一些节点进行判断，能否成树，若能那么树根是谁。</li><li>第三题：大模拟，实现一个Linux的文件系统的部分功能。</li></ul><img src="/2024/09/29/Bao-Yan/baoyan-sjtu-1.png" class="" title="机考规则"><p>面试：</p><p>给老师提交了材料之后，老师说，你做个自我介绍吧。 自我介绍 具体问了项目，具体是什么。我做了什么工作。我们团队有几个人，我承担了什么工作。</p><p>没有问另一个项目。</p><p>英文问题：问了一个transformer有关的问题，和一个基础的日常问题。</p><p>英文问题结束之后继续拷打transformer与大模型相关的问题（我的简历上有写到）</p><p>BERT模型相比于transformer模型有什么不同之处？BERT模型的预训练任务（两个，准备过） 自注意力机制的“自”体现在哪里？我说QKV矩阵。老师问我QKV矩阵是什么，我说从序列中和权重相乘得到。老师又问这个权重，我说是可训练的。</p><p>最后老师说看我当过CSDN技术博主，问我windows（后来又说问c++的vector）中线性表是用顺序表还是链表实现（这有什么关联），我犹豫了一会儿，说用顺序表实现。老师又问如果让你回到计算机刚开始时，你会用顺序表还是链表实现，我犹豫了一会儿，说用链表吧。我到最后都不知道这是在问什么。</p><p>面试结束之后有不止一个导师加我微信，询问我是否有意愿了解他们的方向。从老师反馈来看我的面试应该是非常好的，只是可惜机考实在太差了，这样看应该是无缘了。</p><p>【2024.10.18补充】上交最后录取学硕52专硕20，实际最终录取到优秀生源排序最后三位为96，99和119（121.8分）。优秀生源总共123人，所以实际上是快穿了。实际上我如果什么都不做，在929当天会被录取为最后一个专硕。也许这就是命运的轨迹吧。</p><img src="/2024/09/29/Bao-Yan/baoyan-sjtu-8.png" class="" title="上交的校园环境真的太优美了，是梦想中的学校的样子"><img src="/2024/09/29/Bao-Yan/baoyan-sjtu-2.png" class="" title="上交电院——永远的家"><img src="/2024/09/29/Bao-Yan/baoyan-sjtu-3.png" class="" title="I love SJTU"><img src="/2024/09/29/Bao-Yan/baoyan-sjtu-4.png" class="" title="上海交大！真是高考时做梦都没能想过的梦想"><img src="/2024/09/29/Bao-Yan/baoyan-sjtu-5.png" class="" title="上交的教室——让每个学生更加优秀！"><img src="/2024/09/29/Bao-Yan/baoyan-sjtu-6.png" class="" title="上交的饭菜（甚至没有本校的好吃）"><img src="/2024/09/29/Bao-Yan/baoyan-sjtu-7.png" class="" title="前往广州中山——也是坐上了原神专机啦"><h3 id="7-12-中山计院"><a href="#7-12-中山计院" class="headerlink" title="7.12 中山计院"></a>7.12 中山计院</h3><p>时间线：</p><ul><li>7.11 飞机前往广州</li><li>7.12 上午模拟机考，下午机考</li><li>7.13 早上开营仪式，下午参观导师实验室+参观超算中心</li><li>7.14 面试</li><li>7.16 中午出优营结果</li><li>7.17 离开广州</li><li>9.26 向limei确认放弃</li></ul><p>7.12 上午机考模拟，下午机考</p><p>机考内容有 程序设计+数据结构+模拟+算法</p><p>我机考大概是576。共10道题，满分1000分，我做出来4道题（链表实现、并查集、类继承、模拟）。记忆化递归51分，这个是因为超时了。有一个逆序对的25分。然后骗分30+30+30+20（长度太长，截断了，没法打表）。</p><p>机考过编译10分，过标准样例20分，随机测评70分。而且标准样例和随机样例的预期结果和实际结果都是可以看的（因为长度原因超过而被截断的看不了），所以可以骗部分分。</p><p>绿群群友贡献的题目详情：</p><ul><li>前三题考c++多态，继承，深拷贝</li><li>第四题：简单的记忆化搜索，楼层高H，给定D天，住户1在一楼，住户2在H楼，求D天后用户1到达h1，用户2到达h2的所有可能方案</li><li>第五题：简单dfs或者并查集，给定无向图，判断其中两点是否连通</li><li>第六题：给定两个字符串A和B，是否存在唯一映射使得A能变成B，简单双哈希表秒了</li><li>第七题：最小交换次数，给定只含有[]两种字符的字符串，求出最小交换次数使得一个[总与]匹配，最初以为是dp，其实简单贪心就行了，计算不匹配的]括号数量，因为每次变换至多让两对括号重新匹配，那就用括号数除2向上取整就行了</li><li>第八题：简单模拟，图中有蜡烛，障碍，空点，蜡烛只能照亮所在行和列的空点，蜡烛的光可以被障碍遮挡，求未被照亮的空点数量</li><li>第九题：城市编号1-n，每个城市有一个美丽值（int），他们之间有一些双向道路连接（可达），人从城市1出发，总的美丽值等于他经过的城市的美丽值的异或，求他能获得的最大美丽值</li><li>第十题：给定序列A,B,S，和一些可用的变换，求怎么变换AB使得A是S的子序列，而B不是S的子序列</li></ul><p>总结：</p><p>（1）程序设计考了面向对象的深拷贝、类继承</p><p>考查形式大概是工程文件，然后给你看一部分的实现或者都不给你看，让你实现构造函数、析构函数、拷贝构造函数等，或者是把类写出来。我拿了类继承的分，</p><p>（2）数据结构考了链表的实现、并查集</p><p>链表的实现：给这个链表的头指针和一个值num，保证首节点没有删除操作，要求实现一个函数，删除该序列中所有val比该值num大的节点。</p><p>并查集：给出节点的连通性，求问s节点和d节点是否联通。深搜50分，改用简单并查集（未用路径压缩）即可100分。</p><p>（3）模拟比较简单</p><p>给一个字符矩阵，O表示蜡烛，点表示空地，#表示墙，烛光不能穿墙。问烛光扩散后，有几个位置还是空格。</p><p>（4）算法考了记忆化递归、序列什么的</p><p>记忆化递归：一栋楼有两个住户，每天住户可以往上搬一层，或者不动，或者往下搬一层。第0天时两位住户分别住在第1层和第h层，问使得第d天时两位住户分别住在第h1层和第h2层的方案数有多少个。</p><p>序列：一组中括号序列，且左中括号和右中括号的数量相等，均为总数的一半，可以交换任意两个序号对应的括号，问能使得序列的括号合法的最少交换次数。</p><p>7.13 早上开营仪式，下午参观导师实验室+参观超算中心，和两个稳中山的同学共6人一起吃了个晚饭，拍了合照。</p><p>下午进老师实验室，有很好的学长跟我们聊天，讲了在中山生活的感悟，然后老师来跟我们交流，讲了实验室的配置（应该是不缺卡），毕业的条件，放实习的条件等。然后谈了谈他做的方向（应该是有4个方向，基本都是关于CV方向的，里面的小方向，我都挺感兴趣的）。然后老师说，如果真想来sysu，基本都能录上。然后有同学让老师认认我们的脸，多打几分，哈哈。老师说明天他不参与面试。</p><p>7.14 面试：我是计X组，第一天早上第X位参与面试。</p><p>严格计时，满12分钟就结束。有的组会对各部分计时。</p><p>坐在门口等候，前一位出来就进门。两张桌子拼在一起，面试老师坐在对面，也有一个坐在你这边，你前面有个电脑，你的PPT已经被预先放在那里了，你可以用鼠标点击打开PPT与前后切换。总体氛围很宽松，像小组讨论一样。我们组的情况是只有主面老师在提问，其它老师在摆烂或发呆。</p><p>流程是先从信封中抽取英文材料。英文材料大概六七行的样子，科普类短篇或者是新闻报道，专业性不是很强，但可能会有几个专业名词比较陌生。要求先阅读一遍，再翻译。听说有的组会打断，不知道是因为时间到了还是英语实在太broken了。我抽到的是一段关于百度的阿波罗无人车或者是无人出租车，没太搞懂。有简单介绍，然后是人们关于它的顾虑，像一篇科普类新闻。我没有被打断，个别词没读太顺，但英语底子还好，总体比较顺畅。翻译自我感觉也是还可以。也有人抽到5G等，评价是难度不一。</p><p>然后是讲PPT，我就直接大大咧咧地从前往后讲。一开始我以为计时器是对我PPT进行计时的，所以讲PPT就快了一点。我PPT主要介绍了一个项目，其余都是略讲。然后跟老师说如果感兴趣的话之后再提问我（后来想想胆子真是大，有种倒反天罡的美感）。没被打断，直接讲完了。</p><p>讲完PPT之后，主面老师开始问我问题。出乎意料的是，老师没有问项目，似乎对我当助教的经历比较感兴趣。问我助教都干些什么，我说验收实验、讲解试卷、日常答疑等。然后老师又问我们计算机系统课程是不是比较偏软件的？我说是的，我们比较偏硬件的课程主要在计算机体系结构里完成。老师问我都做过哪些？我说我们每个人都要完成一个五级流水线。这个时候老师突然欣慰，脸上笑容更加洋溢了，我心里就感觉不好，果不其然，老师开始很欣慰地拷打专业课了，在这等着我呢。老师问流水线是哪五级？我说IF、ID、MEM、EXE、WB。老师接着问，有哪些因素影响流水线继续推进？我当时没反应过来，就答的预测失败，会使得流水线需要停滞甚至回退。然后老师试图引导我回答更多的原因。我突然想起来那三个因素：结构冲突，数据冲突和控制冲突。然后老师问我控制冲突跟我之前回答的那个是什么关系。我回答应该是包含关系。老师突然笑了，说应该就是一样的。我也笑了，说有点考虑不全面。</p><p>老师继续问我之前的项目，我就把PPT调回去讲了一下那个项目。然后老师比较关心的是我有没有对算法做一些改进。我有点懵了，就说可能在处理数据的代码上有一些改进。这里表现的不太好。老师问是不是把模型缩小了，我说没有缩小模型。</p><p>然后闹钟响了，应该是时间到了，老师就让我出去了。我说谢谢老师，跟你们交流很愉快（这句也有点不知好歹了，有倒反天罡的美感）。然后我就滚出去了。</p><p>滚出去之后，找还没面试的同学交流了一下面试的形势，同时给他们一些信心。我是我们学校10个人中第一个面试的，也是最后分数最高的。中山的面试我感觉酣畅淋漓，可能是之前面试到现在否极泰来了。感觉老师们都挺好的，交流确实很舒服。可能是运气比较好，老师没拷打我数学。听说我们学校别的同学有被拷打线性代数、概率论等。我面试完之后一个最大的遗憾就是没有将本校更进一步向SYSU的老师们展示，感觉我还是做不到游刃有余地切换，还是有一些胆小哈哈。</p><p>不过此时我已经有同济的优营了，来中山其实就是来玩玩，主要跟同学们聚一聚，感觉在一个陌生的地方跟同学们一起玩还是挺有趣的。</p><p>中山我感觉还是有点背景面的意思，我们学校rk靠前的同学得分就是会偏高，甚至4个优营3个都是rk1。提前联系导师对于面试分数没有太大的优势。</p><p>7.15 中午和来参营的共10人拍了合照，下午离开参观了沙面，晚上参观永庆坊。</p><p>7.16 下午参观广东省博物馆，远看广州塔，在广州图书馆休息。晚上补了早茶，和舍友吃了16份广式甜点，很满足。</p><p>7.17 飞机离开广州，飞杭州萧山。广州地铁真的是地狱。我在车陂南站等了大约5趟地铁，全是人，根本上不去。后来来了一辆完全空的地铁，直接人全部挤上去就充满了，后面还有人没上来，早高峰的广州地铁真是太恐怖了。</p><p>优营情况：效率很高，7.16中午出优营结果。</p><p>总结感悟：</p><p>前一天的机试没有太看，老师没有提起来，据说考太低可能会被问。感觉面试还是有点看背景，三位rk1的排位都很靠前，如果没有rk可能得项目非常好才能弥补。中山还是比较整体地去评判一个人的。提前联系导师似乎对于面试结果没有影响，不会因为老师关照就多打分。</p><img src="/2024/09/29/Bao-Yan/baoyan-sysu-1.png" class="" title="到广州的晚上已经是23：05了，侥幸坐上了倒数第二趟车"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-2.png" class="" title="国立中山大学（这里是中山大学的北门）后来本专业来的10位同学在这里合照"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-3.png" class="" title="这一层是计算机学院的同学所在的地方，也是我之后去中山的同学的工位所在地"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-4.png" class="" title="SYSU的计算机学院"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-5.png" class="" title="I love SYSU！ 食堂太好吃了"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-6.png" class="" title="似乎是椰子树？好大的校园！"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-7.png" class="" title="我们机考的地方"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-8.png" class="" title="中山大学！"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-9.png" class="" title="中山大学宽敞的地下通道，连接生活区与学习区（这个时候就要看看本校建了好久但还没好的地道了）"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-10.png" class="" title="真的感觉景致很美很美"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-11.png" class="" title="有一种漫画里的感觉，云真的很低很低！"><img src="/2024/09/29/Bao-Yan/baoyan-sysu-12.png" class="" title="中山的餐票补助，真够爽吃！体验感非常好！"><h3 id="8-26-国防科大计院"><a href="#8-26-国防科大计院" class="headerlink" title="8.26 国防科大计院"></a>8.26 国防科大计院</h3><p>时间线：</p><ul><li>8.26 晚上坐地铁到世界之窗旁边报到</li><li>8.27 清早合影，然后一天的学术讲座</li><li>8.28 早上体检，下午参观</li><li>8.29 早上面试，下午心理测试</li><li>8.30 离开，坐地铁回</li><li>9.4 出结果</li></ul><p>面试：</p><p>【这个我好像也签过保密协议，所以有些不能细说】</p><p>面试分为综合面试和政治考核。</p><ul><li>英文自我介绍：抽英文问题，5选1。老师读的不是很清楚，好像是问将来一段时间你觉得哪个计算机领域会发展比较好，好像是这样。我说多模态和大语言模型会比较好，因为数据很多，要用这些数据来做预测或任务。</li><li>中文自我介绍：</li><li>项目问题：<ul><li>有没有去申请专利或者有论文的产出。</li><li>在预训练过程中如何解决灾难性遗忘问题。（没答上来，老师换问在预训练阶段你做了什么，我说使用全参微调）</li></ul></li><li>其他还面试了哪些学校，如何做选择？那你有没有联系的导师？其他学校有没有联系的导师？（感觉很在意我是不是鸽子）</li><li>老师没有我们的个人信息，没有简历（不知道能不能自己准备简历递上去，我没带简历），所以所有都只能依靠自己说出来，对于工作的表述是一个很严峻的挑战。提问很随性，很符合我对于推免面试的想象。</li></ul><p>政治考核：</p><ul><li>与党有关的知识（不便细说）</li><li>一分钟介绍家庭情况。</li><li>有什么特长，不能是爱好。</li></ul><p>评价：</p><p>全程包吃包住，但是体检要自己花钱，报销路费（这个没用上）。主要还是锻炼了自己，用来刷经验的。从一开始就没打算来。但是确实发现了自己项目中的不足部分，后来回去重新复习了一下。</p><p>最终位次：排名170&#x2F;467（夏令营1+夏令营2）</p><p>由于国防科大很多地方都涉密，所以没有拍照片。只是拍了一些公开的部分。</p><img src="/2024/09/29/Bao-Yan/baoyan-nudt-1.png" class="" title="国防科大夏令营"><img src="/2024/09/29/Bao-Yan/baoyan-nudt-2.png" class="" title="每餐饭都是自助餐，真的爽吃了好多，都变胖了"><img src="/2024/09/29/Bao-Yan/baoyan-nudt-3.png" class="" title="国防科大的入营礼包，很有夏令营的感觉"><img src="/2024/09/29/Bao-Yan/baoyan-nudt-4.png" class="" title="和本校同学合住的酒店"><img src="/2024/09/29/Bao-Yan/baoyan-nudt-5.png" class="" title="体检真的好贵啊"><img src="/2024/09/29/Bao-Yan/baoyan-nudt-6.png" class="" title="国防科大的图书馆！"><img src="/2024/09/29/Bao-Yan/baoyan-nudt-7.png" class="" title="图书馆外景"><h3 id="夏令营总结与回顾"><a href="#夏令营总结与回顾" class="headerlink" title="夏令营总结与回顾"></a>夏令营总结与回顾</h3><ul><li>不够自信，清计院没有去尝试。</li><li>非核心rk1夏令营还是比较受限的，复旦（核心rk1入营）、sjtu-ai（核心rk1入营，我以为bar很高，真的bar很高）。</li><li>信息差：ustc-6系没入：计科投递ustc-6系属于跨专业，这个关键信息没有把握住。</li><li>408：没有复习好，南大计院机试直接寄，同济也受到了影响。</li><li>机试：没有复习好，上交的机试得分太低，但凡第二题能Ac出来，结果会很大不同。</li><li>预推免还是要更加敢想敢为一些</li></ul><h2 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h2><p>预期目标：计划报复旦计院、浙大工院、南大计院、尝试清北，尽量捞一个学硕或者专硕的稳offer，目标为华五的硕offer。</p><h3 id="9-13-南大计院"><a href="#9-13-南大计院" class="headerlink" title="9.13 南大计院"></a>9.13 南大计院</h3><p>预推免的难度明显比夏令营难度下调了，很多都是基础的408知识。</p><p>时间线：</p><ul><li>9.8 线上机考</li><li>9.9 出了机考结果，获得了线下资格。</li><li>9.12 下午坐动车出发前往南京南，晚上住在南大仙林南门不远处。</li><li>9.13 上午面试，下午2点到4点机考。9.13晚就睡了4个小时。</li><li>9.14 早上7：30高铁回长沙。约11点高铁上收到邮件，候补。打电话问，在预推免waitlist前20，午后打电话确认在前15。老师说有机会能补上。预计25日将夏令营和预推免waitlist合并，按权重考虑，算法没说。据说也有机考280的wl，也有280的学硕，也有210的专硕。</li><li>同学wl前10在9.26下午候补到专硕</li><li>我wl10-15在9.27早上候补到专硕</li><li>929当天南大cs几乎被鸽穿，据说夏令营的wl120-130都能补到专硕，离谱啊离谱，南大你养了一大群鸽子。</li></ul><p>线下情况</p><p>直硕7组，直博1组。每组大约15人，有人没来，大约硕士可能不到100人这个样子。看了一眼本组的生源，有几个南大的，也有一些211的，包括苏州大学的等，排名也有差异，不都是第一这种，也有很多前十的。总体来说感觉还是放松了很多。</p><p>面试</p><p>【重要情报】明年想推免去南大的同学们注意哈，南大开始往科研上靠了，不再单纯依赖408，今年预推免的时候教务老师跟我们说了，明年的考核项会新增一项“科研素养”，直接计入分数。同时结合今年面试经验来看，确实有同学全程都是科研项目，很少408的内容。</p><p>小会议室，3个老师，全程录音录像。中间的老师比较年轻，两边的老师有点老。双盲，老师不知道我的名字和任何信息，只知道我的编号。</p><p>【注意：我的面试不是典型的南大408拷打面试内容】</p><p>【由于不是常规的408拷打，这个应该算老师的即兴提问，分享该部分经验应该没有违反保密规则】</p><p>【南大一般纯靠打专业课，但是到我这里，由于我自己的引导，老师开始对我的项目感兴趣，然后全程在听我的项目，难绷】</p><ul><li>中文：介绍自己近期遇到比较难的问题以及如何解决的？我就顺势把我的第一个项目介绍进去了。然后老师听的也挺感兴趣，就接着问下去了。</li><li>老师问这个项目是在高校做的还是在企业做的。其实应该回答这是校企合作的项目，但是我说在本校实验室里做的，就是高校做的。</li><li>中文：还有做过其他项目吗：我自己主动说了很长时间，然后老师对我的项目中部分感兴趣的地方深入问。</li><li>xxx，在你项目中有什么作用？</li><li>为什么用Qwen不用Llama（旁边的老师替我回答了说是中文语料）</li><li>我说如何获取数据，分析数据，以及呈现数据是比较重要的。老师问获取数据比较感兴趣。我说利用开源数据集，因为企业很多数据集都是封闭的，不免费公开。所以怎么从开源数据集中拿到自己想要的东西很重要。</li><li>你之后打算做什么？我回答NLP，之前联系了某老师的组。老师说这和我之前的项目没什么关联？中文和英文的tokenizer的区别是现在业内研究比较重要的问题。我说这个在本科阶段没有太多的了解。我说对齐也是比较重要的问题。</li><li>英文：介绍quick_sort以及它的时间复杂度。</li></ul><p>另外：有同学问到TCP、最小生成树、遍历数组时按行优先遍历更好还是按列优先遍历更好（空间局部性）、一阶谓词逻辑的英文介绍、SQL的英文介绍等。感觉随机性很大，每个组的情况都不尽相同。</p><p>我是属于一开始老师问的第一个问题时，我就把话题转到了我的项目上，然后老师对我的项目也比较感兴趣，就顺着往下问了，所以全程没有拷打专业课。从这里可以看出来，有的时候还是要稍微机灵一点，把话题往自己的项目上去引导，往自己熟悉的地方去引导，会有更好的结果。全过程我应该还是比较自信的，但是缺点是说话的时候没看着老师的眼睛。</p><p>总体应该不是压力面，同学出来都感觉跟老师聊的挺不错的。希望我能有个比较好的结果。</p><p>机考</p><p>3道题，最终得分20+100+75&#x3D;195，英文题面</p><p>【我签了保密协议，这里的机考题不能透露出来，只能稍微描述，如果确实想进一步了解，可以进一步探讨】</p><p>第1题：多维矩阵乘法</p><ul><li>高维矩阵相乘</li><li>一上来就这道题，没有任何思路，看了15分钟之后跳过了，最后解决了一个数据点，拿了20分。</li></ul><p>第2题：base32编码（简单模拟题，大家基本都做出来了）</p><ul><li>百度上应该有这种编码技术，把句子里的英文字母按照ASCII码逐个转化为八位二进制数，然后连起来，若长度不为5的倍数就加0补齐。然后把这一长串按照5位一切分，再由二进制向字符哈希映射即可，最后如果结果不是8的倍数，就加&#x3D;补齐。</li><li>获取ASCII码：对于char c使用int(c)，这里有点考计算机基础知识了。</li><li>需要自己实现由string二进制数转为十进制数以及ASCII码的生成（十进制数转到string二进制数），应该有现成的库，但我没想到。</li></ul><p>第3题：string golf（数据比较水，纯暴力有75分）</p><ul><li>给了很多定义：</li><li>【我就把这里略去了，不讲，有需要的同学自己找到我吧】</li><li>给定support集和reject集，问同时满足的长度最长的字符串是什么，保证答案唯一，即不会出现长度相同但多个满足题意的情况。</li><li>数据规模：每个set里个数＜20，每个字符串长度＜200，（很友好的数据，故一上来就想到用暴力求解）</li><li>数据子任务：30%数据保证没有通配符.和+（实际上我完全没做这里的处理也过了75%）</li></ul><p>评价：英文题面虽然没有带来太多的理解难度，但是一上来看到的时候心理压力还是非常大。第一道题15分钟没有任何思路真的很难受。但是发现第二道题很简单之后迅速花了大概40分钟敲出来（最近代码生疏了，边做边输出结果验证各个步骤，所以慢了），但是compile error了一次，改了一下交了就拿到了第一个100分，心情大定。然后做第3题，本来打算敲个暴力拿到30分，但是花了30分钟敲出来之后，意料之外骗到了75分，心情又好起来了。最后大概剩下半个小时，第一题想拿点突破但是没有结果，最后我想到可以用dfs来模拟每个维度的不同数值做累加，但是时间已经来不及了，最终没有做出结果来。所以感觉还是有很多的遗憾，因为我知道这次简单，大家应该都能做的比较好，所以我不一定具备优势了。</p><p>下面是南大行程中的一些图片。</p><img src="/2024/09/29/Bao-Yan/baoyan-nju-3.png" class="" title="前一天晚上到达南大时拍的南大外景，这是我第二次在这个角度看，上一次是高考前"><img src="/2024/09/29/Bao-Yan/baoyan-nju-9.png" class="" title="I love NJU ！"><img src="/2024/09/29/Bao-Yan/baoyan-nju-2.png" class="" title="计算机学院院楼，参加面试的地方"><img src="/2024/09/29/Bao-Yan/baoyan-nju-4.png" class="" title="这里是参加机考的地方"><img src="/2024/09/29/Bao-Yan/baoyan-nju-7.png" class="" title="你好，NJU！"><img src="/2024/09/29/Bao-Yan/baoyan-nju-10.png" class="" title="我最爱的NJU！"><img src="/2024/09/29/Bao-Yan/baoyan-nju-1.png" class="" title="机考在NJU在线OJ系统上进行，能实时给出反馈"><img src="/2024/09/29/Bao-Yan/baoyan-nju-5.png" class="" title="和初中相识的同学登上NJU的后山，不得不惊叹NJU的景色是真的很美很美"><img src="/2024/09/29/Bao-Yan/baoyan-nju-6.png" class="" title="NJU的食堂，可惜没吃上这里的午饭"><img src="/2024/09/29/Bao-Yan/baoyan-nju-8.png" class="" title="晚上上一届来到NJU的学长请我和同学吃了一餐晚饭，这个食堂真的太好吃了"><h3 id="9-17-清华软院"><a href="#9-17-清华软院" class="headerlink" title="9.17 清华软院"></a>9.17 清华软院</h3><p>时间线：</p><ul><li>9.5 收到通知，获得线下综合考核资格并告知了考核时间与方法</li><li>9.12 收到通知，未能通过清深初筛</li><li>9.16 坐飞机从长沙出发，前往北京</li><li>9.17 早上资格审查，下午2点到6点机考</li><li>9.18 早上面试，晚上坐过夜火车离开北京</li><li>9.18 晚上约8点，在地铁上收到了拟录取</li></ul><p>资格审查：</p><ul><li>需要进行人脸比对，要求跟上传的证件照相似度达到80%。建议一定拍个像一点的。到我的时候由于我证件照是大一时候的照片，这几年已经有点不像了。老师非常好心地帮我验证了好多次，每次都差一点，在78%左右。我不断地把自己往照片上拟合，挤出笑脸hhh。万幸最终验证通过了，如果验证不通过可能要写保证书。</li></ul><p>机试：</p><p>【我忘记自己有没有签保密协议了，题目就先不公开了】</p><p>早上有2小时的模拟机考，可以自己试试机房的环境，以及摸索系统。</p><p>OJ赛制，提交及时反馈，每题最多32次提交，取最高分。开卷，允许携带纸质资料。</p><p>环境：NOI虚拟机，网页OJ，本地有Vscode，无dev等集成环境。需要手动使用命令行g++编译并运行。</p><ul><li>第一题：阿瓦隆。题目难度约为CSP第1题至第2题难度。我考试开始后13分钟提交并拿满。</li><li>第二题：网络。我的解题思路：数据分层比较明显，只使用并查集优化的kruskal算法可以拿到33+19&#x3D;52分。是没办法过②④两点的。盲猜数据点连接之后应该全为联通图，所以②点直接输出ans&#x3D;n+m-1，就拿到了这27分，这个比较难想到，数据点也恰好很看运气。最后21分没有去尝试，直接放弃。此时考试过去一个半小时，已经拿到179分。</li><li>第三题：边双。我的解题思路：写了一个dfs的模拟，并把限制条件全部模拟出来，但是没法解决自环问题（成环之后会反复走这个环，没法出来，造成递归无法结束），最终这道题没有做出来，也没有拿全任何一个数据点的分数，使用有深度的递归（即到某个深度强制结束递归）的方法骗到5分，通过微调这个深度骗到10分，再改进无进展。时间耗尽，结束。后来在绿群听说直接输出所有权值加和（即默认所有节点都可访问一遍）可以得10分，不知道跟我这里的这10分是不是一样的，没再深究。第一个数据点有20分（规定n&lt;&#x3D;20）。</li></ul><p>评价：我的最终成绩为接近200分。结束之后绿群里看到大部分人为100+（33+19）&#x3D;152分，即第一题和第二题只使用并查集的kruskal算法。少部分人从第三题拿到了10分或20分。所以我估计中位水平在170分左右。同时这次有许多满分300分，我了解的就至少有4个以上。最后出结果的时候看到很多152分的就没有录取。</p><p>面试：</p><p>共4组，76个同学。基本上会把一个学校的同学拆到不同组去。每组连续面5个同学，老师休息一次。每个同学20分钟，全程严格计时，各部分也是严格计时。</p><p>先对着PPT讲自我介绍（5-7分钟）：会严格卡时间，这里一定要控制好时间。我在项目上花费了太多的时间，所以最后没讲完，老师让我快点往后过一遍。这个整体表现真的很不好，千万要注意。</p><p>然后老师对PPT里感兴趣的内容提问，问题很广泛，基本上像聊天面，聊到哪里就问什么，无迹可寻。</p><p>固定的几个问题：</p><ul><li>英文问题：感觉像是负责该问题的老师随机结合你的项目提问。</li><li>政治问题：你是党员吗？我回答我是预备党员。提问这个的老师被其他老师打断了，就没再继续问了。我还听见其他有问近期的时事的，时政的。感觉这个也是很随机。</li><li>专业课问题：看老师喜欢哪个学科，逮着猛猛薅。我这个老师很喜欢编译原理，于是问我编译原理。第一个问题我大概能理解，第二个问题我没有太理解，我就说我不太会。其他考场有被问到数据库的问题，一个考场估计就问一个科目。（大家答的都不太好，专业课确实太难绷了，很难复习）</li></ul><p>压力的部分：</p><ul><li>你这个项目有什么实际意义呢（我以为是项目太水了被穿了，后来发现几乎每个同学都被问到了）</li><li>请你用一句话表明你的项目怎么体现出你的科研能力（这句也是每个同学都被问到了）</li></ul><p>我这个场地的老师有点压力面，但是其他考场的老师据说很聊天面。</p><p>下面的图片按照时间顺序放吧</p><img src="/2024/09/29/Bao-Yan/baoyan-thu-16.png" class="" title="前一天坐上飞往北京的飞机，那两天南边江浙一带有台风，所幸北边没有影响"><img src="/2024/09/29/Bao-Yan/baoyan-thu-8.png" class="" title="靠在窗边，我看着下面的城市，顿时明白了“星罗棋布”是什么意思，如果让我换个比喻，我会觉得很像电路板，原来中国有这么多人"><img src="/2024/09/29/Bao-Yan/baoyan-thu-9.png" class="" title="晚上住宿在“者行孙”，这个看着像“自闭小屋”，能深切体会到“北漂”的不易，即使是这个，住一晚都要120块钱，正常旅馆至少得要300块，真的太贵了"><img src="/2024/09/29/Bao-Yan/baoyan-thu-1.png" class="" title="晚上陪同学去打印资料时经过了“知乎”的总部，很小的一栋，很惊讶与诧异，同时感慨果然是北京，平时只能在网上看到的东西都成为了现实"><img src="/2024/09/29/Bao-Yan/baoyan-thu-5.png" class="" title="早上打车去参加资格审查的路上看到了“飞书”的总部，感慨与昨晚相似，但对自己今日的行程多了一份期待"><img src="/2024/09/29/Bao-Yan/baoyan-thu-3.png" class="" title="终于到了清华的门口，最高学府给人的震撼是扑面而来、难以言喻的。现在大概还没到8点，所以人很少，但是保安很多而且很负责，每个人都要核验身份证才能进去，这又再一次增加了肃穆感"><img src="/2024/09/29/Bao-Yan/baoyan-thu-12.png" class="" title="从门口进去，一路直行来到的是东主楼，右边就是软件学院了，这栋建筑给我一种很庄严的感觉。同时早上的晨光洒在身上，这个氛围感很绝妙，我真的很想留在这里"><img src="/2024/09/29/Bao-Yan/baoyan-thu-14.png" class="" title="清华的二校门，弥补了暑假时没能进来参观打卡的遗憾，跟同学在这里拍了合照"><img src="/2024/09/29/Bao-Yan/baoyan-thu-10.png" class="" title="软件学院的门口"><img src="/2024/09/29/Bao-Yan/baoyan-thu-15.png" class="" title="清华大学软件学院！"><img src="/2024/09/29/Bao-Yan/baoyan-thu-7.png" class="" title="晚些时候到另外一栋楼参观了传说中的“贵系”！"><img src="/2024/09/29/Bao-Yan/baoyan-thu-13.png" class="" title="清华的校徽"><img src="/2024/09/29/Bao-Yan/baoyan-thu-11.png" class="" title="路上随拍的长椅，我都不敢想在这里坐上一整天该有多轻松多惬意"><img src="/2024/09/29/Bao-Yan/baoyan-thu-6.png" class="" title="面试结束后一起聚餐吃的川菜"><img src="/2024/09/29/Bao-Yan/baoyan-thu-2.png" class="" title="去年来清华的学长请我吃的晚餐，果然是最高学府的食堂，真的太好吃了！"><img src="/2024/09/29/Bao-Yan/baoyan-thu-17.png" class="" title="晚上在离开去火车站的地铁上收到了系统上发生变动的消息，心里很激动"><img src="/2024/09/29/Bao-Yan/baoyan-thu-4.png" class="" title="火车经过武汉长江大桥，已经到次日清晨了，再次看到长江，内心感慨万千"><h3 id="9-21-浙大工院"><a href="#9-21-浙大工院" class="headerlink" title="9.21 浙大工院"></a>9.21 浙大工院</h3><p>时间线：</p><ul><li>9.16 正常入营公布，未能入营，打电话问教务，被告知未入营</li><li>9.18 清软面试结束后，中午吃饭时，被电话告知候补入营</li><li>9.20 从长沙出发返回杭州</li><li>9.21 早上前往拱墅面试，下午陪同学逛西湖</li><li>9.23 晚上钉钉拉一个拟录取群，告知处于wl-9（共录取30人）</li><li>9.27 晚 wl-6，前面3人放弃</li><li>9.28 没有填报，相当于放弃了录取资格</li><li>9.29 晚上回去翻了钉钉群，至少鸽了15个，我应该能补到的。算了，有清软了，就不去浙大了。</li></ul><p>面试：</p><p>英语自我介绍，然后讲自己的PPT，之后考官提问，会抽一个专业问题。</p><p>主要是在对我着重提及的项目提问，我还是比较能应对自如的。</p><p>专业问题：抽到的是程序设计的，好像是继承的时候，如果父类函数加virtual但是子类函数不加virtual，能不能实现多态。当时脑抽，说不能实现。被老师质疑有没有学过程序设计。后来反应过来是能实现，有点尴尬。</p><p>政治问题 ：对待法轮功的态度，坚决反对。</p><p>下午陪同学逛了逛西湖。</p><img src="/2024/09/29/Bao-Yan/baoyan-zju-1.png" class="" title="果然浙大能代表浙江"><img src="/2024/09/29/Bao-Yan/baoyan-zju-2.png" class="" title="工程师学院的入口"><img src="/2024/09/29/Bao-Yan/baoyan-zju-3.png" class="" title="浙大工程师学院的引导做的非常好，省去了我找路的时间"><img src="/2024/09/29/Bao-Yan/baoyan-zju-5.png" class="" title="还受到了标语的欢迎，受宠若惊"><img src="/2024/09/29/Bao-Yan/baoyan-zju-4.png" class="" title="西湖的三潭印月，我还是第一次见到hhh"><h3 id="9-22-湖大信院"><a href="#9-22-湖大信院" class="headerlink" title="9.22 湖大信院"></a>9.22 湖大信院</h3><p>时间线：</p><ul><li>9.19 晚上邮件告知入营</li><li>9.21 晚上邮件告知面试分组</li><li>9.22 早上开始面试，排在第19位，下午1点面到。</li><li>9.26 下午出结果，有个稳保底了。</li></ul><p>面试：</p><p>不知道为什么今年面试在线上进行，很奇怪。但我也因此有机会参与。</p><p>先进候考室待着，到我面试的时候直接老师的摄像头就开了，一个房间大概五六个老师。</p><p>比较不好的体验主要有几点：（1）没有人提前告知你现在面试到第几个了，全程在等待，也不知道什么时候开始面试。（2）线上面试很难听清楚老师在说什么，那边感觉回音很重。</p><ul><li>先做自我英文介绍。</li><li>然后老师问我本科阶段有没有做过的科研和项目。我说我有PPT，老师说就简单回答一下就可以。我就简单回答了，然后稍微描述了一下细节。</li><li>老师对我做CSDN博主感兴趣，问我感兴趣的论文是什么。我说ICML的一篇论文，然后稍微讲了一下原理。</li><li>老师问我跟的哪个本校老师。</li><li>老师问我还有什么其他的offer，我说了拿到的几个。</li><li>老师最感兴趣的还是为什么我要来预推免，感觉是明牌鸽子。我老实说了想拿个本校的保障。</li><li>老师问我还有什么想问的，我说暂时没有了。</li></ul><p>全程就6分钟左右，就结束了。感觉老师知道我不会来了，就有点聊天的意思。我的最后一场预推免面试就这样结束了。</p><h2 id="929当天"><a href="#929当天" class="headerlink" title="929当天"></a>929当天</h2><p>手上已经把其他学校都释放完了，留了一个强com的南大作为保底以防特殊情况，一个清华其实也是铁offer，还剩下一个空置防止特殊情况（我还是比较求稳的）。填写了一个清华，一个南大。</p><p>根据往年的经验，清华会比较晚发，去年中午12点开系统的话是下午6点才发待录取。今年早上9点开系统，下午2点发的待录取，时间上提前了一个小时。一般如果等清华会错过其他绝大部分学校的待录取，故我的心里其实也是很慌的。</p><p>早上10点左右，南大和清华都发了复试通知。</p><img src="/2024/09/29/Bao-Yan/baoyan-2.png" class="" title="接受了南大和清华的复试通知"><p>11：30，南大打电话给我妈（我写的座机电话），问到底点不点，不点就要撤回了。很巧的是我在一分钟前刚刚点了拒绝键，因为显然不可能一直等下去。最终拒绝了南大，把这个机会让给有缘人。</p><img src="/2024/09/29/Bao-Yan/baoyan-3.png" class="" title="拒绝了南大的待录取"><p>清华向来发的比较晚，最终在下午13：56的时候发了拟录取，点击接收，保研就结束了。</p><img src="/2024/09/29/Bao-Yan/baoyan-4.png" class="" title="接受了清华的录取，拒绝了南大录取"><p>这应该就是尘埃落定了吧，其实真的到了928，内心的激动已经荡然无存了，就好像喜欢了一个人很久，最后终于把结婚证办了，大概这种感觉？当然这也是一个没经历过的事情。我只想好好的睡一觉。</p><p>今年929更是保研春晚，许许多多的学校被鸽穿，很多看似遥不可及的学校一下子就随地可捡，许许多多的闹剧和喜剧同步上演，真就是保研人独属的春晚。不论这三个月你有多劳累，笑一笑感觉又能好起来。</p><p>绿群广播的鸽穿情报（实际上差点穿的学校更多，已经穿的学校也不止这些）：</p><blockquote><p>根据群u情报，目前鸽穿的（有误的和待增加的都可以说一下）seu cs&#x2F;网安&#x2F;蒙纳士，ustc-先研&#x2F;自动化，浙计专-机器人，北理珠，sysu-cs&#x2F;se，sdu-cs&#x2F;se，hust-cs，sjtu-ai，buaa-类脑，hitwh-cs，nudt-cs，bit-cs，ruc-苏州</p></blockquote><p>有的学校被鸽穿了就老实了。</p><img src="/2024/09/29/Bao-Yan/baoyan-7.png" class="" title="图片来源于绿群"><p>有的学校下午3点还在招人（穿透了）</p><img src="/2024/09/29/Bao-Yan/baoyan-11.png" class="" title="图片来源于绿群"><p>绿群的群友们在一起听歌，从《鸽子》到《好运来》，几十个人一起听了一晚上的歌，还在听，难绷。</p><img src="/2024/09/29/Bao-Yan/baoyan-6.png" class="" title="绿群群友在听歌"><img src="/2024/09/29/Bao-Yan/baoyan-5.png" class="" title="绿群群友在听歌"><p>绿群聊了好久的主人公迎来了结局，《东五》也是后继有人了。（应该是html前端改的字，太难绷了）</p><img src="/2024/09/29/Bao-Yan/baoyan-8.png" class="" title="图片来源于绿群，若造成不好影响，请联系我删除，很抱歉给您带来不好的影响"><p>小红书上更有人整活，把这个做成一盒药。只能说是很好的反应了保研人这一路上几经崩溃的经历，最后的待录取药到病除的神奇疗效。</p><img src="/2024/09/29/Bao-Yan/baoyan-9.png" class="" title="图片来源于小红书，若侵权请联系我删除"><img src="/2024/09/29/Bao-Yan/baoyan-10.png" class="" title="图片来源于小红书，若侵权请联系我删除"><p>最后再放一下绿群的祖传的保研圣经，现在应该是三圣经了。</p><p>所谓圣经，就是讲述了一些重要的道理。其中原版圣经劝等劝赌劝等鸽子飞，黑化版阐述了等鸽子从而没学上的下场。</p><p>绿群保研圣经：</p><img src="/2024/09/29/Bao-Yan/baoyan-12.png" class="" title="绿群保研圣经"><p>绿群保研黑圣经：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1．年年如此，底层逻辑没变的，赌博是对勇敢者的教训</span><br><span class="line">2．少部分人就是忍得住，敢赌鸽子飞，结果一个offer没有后悔一辈子</span><br><span class="line">3．保研资格就是你最大的筹码，大家都是三个志愿，踏踏实实才能胜利，20岁就赌，后半生怎么办？</span><br><span class="line">4.9月28日就开保研系统，一天就足够占满大部分导师坑位了，只有风险没有收益</span><br><span class="line">5．自己心里有个高度的呀，拿命赌个学校，珍惜三年努力的机会吗？</span><br><span class="line">6．预推免形式差才要珍惜，就像人跑的时候，要先学会走</span><br><span class="line">7，现在 offer 越少越是紧张，要是别人厉害能拿多个学校offer，剩下的都是残羹剩饭。别人越努力，我越紧张，机会是留给踏实者的。</span><br><span class="line">8.9月28之后，大局已定，没有offer的人都会出局，现实就如此残酷，就看你踏不踏实，找个班上还是读研，就是看你的踏实。</span><br></pre></td></tr></table></figure><p>绿群保研恋爱版圣经：</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>还没准备就已开始，还没有感触就已结束。</p><p>我保研的结束，实际上在19号晚接受清软offer时。那一刻，我在北京的地铁上，匆匆转三条地铁线路赶往北京西站，然后坐过夜的火车回长沙。此前在曾住过的酒店澡堂洗了澡，因此头发还湿湿的。深夜约是九点，地铁上已经没有太多的人了，估计也是下班的苦命人。微信企业邮箱收到了一条邮件，点开发现是清华系统提示状态有变化。内心有一阵激动，但结合之前面试的情况，我觉得还是不太可能。抱着想让自己死心的想法，同时还有一种迫切期待得到结果的冲动，我从背包里掏出电脑，连上手机热点，然后点开系统，然后发现了是否确认“初步录取”。这一刻，我心里其实没有太大的波澜。这三个月以来，我经历过绝望，经历过纠结，经历过各种各样状况百出的局面，心里已经麻木了。大有种看开想开的感觉。我其实没有那种三年努力终于得到回报的那种爽感与快感，更多的是一种水到渠成、自然而然的宿命感。我感觉自己是被命运推着来到了这个结局，但如果命运途中发生了一点微小的改变呢，也许会有很不同的结果。但我还是很庆幸，能以这个作为结束，是我最喜欢的硕士offer，虽然是我不敢想的学校。我用手机给妈妈打了一个电话，告知她我不用继续往下走了，因为清华能录上。电话那头先是一阵沉默，然后是哽咽，母亲需要时间消化这个消息。</p><p>诚然，这几个月以来我过的实在不容易。而作为应该是我保研征途中最难的这一场，我居然没有时间做太多准备。除了在南大的机考，我近期并没有练过机试；同样，除了国防科大和南大这两场，距离夏令营的5场面试也过去了很久，我的面试状态已经有了很下滑的趋势，实际上我面试状态的顶峰应该在中山那时。我的精力都用在了别的事情上。因此，除了宿命，我想不出别的理由来解释这个结果。不过好在是以这里结束，这是我能接受的结局，也是我能走出最好的结局。万幸的是，这唯一的机会，被我死死地抓住了。曾有朋友对我说，你要一而再再而三地救自己于水火之中，因为能拯救你自己的，只有你自己，没有别人。我真的很感谢这份幸运，以及之前为这份幸运做出的一切努力。</p><p>保研的目标，是在大一就定下的。高考时我历次模考基本有南大的水准，物理爆冷最后来了本科的学校。之前听说同专业有高中母校来本科母校最后去上交直博的事例，我一直摆在心中当做追随的目标。而清华的title可以完美覆盖上交的title，同时读硕也是我既定的路线。因此这个结局是唯一破局的方法，也是我唯一能接受的结局。我很幸运地得到了它。</p><p>回望这三个月，从6月末离开长沙前往同济这第一个夏令营开始，到9月末本校的最后一个线上营结束，正好十个营，这是否正好对应着十全十美呢，我不知道。我所记得的是，夏令营时七月上半旬的旅行：坐飞机从成都凌晨抵达北京，上交面试完赶着公交到机场坐飞机飞向广州，然后再赶着倒数第二班地铁前往广州体育西路，此时已经过零点，没有地铁了，只能打车前往中山大学附近……这是一个人的旅程，是自己给自己的修行。但是在旅程中，总有可爱的同学陪伴。很巧的是，凡是住宿，都是本校的同学，这给了我安全感……</p><p>之前的经验贴说，保研的过程，也可以领略不同城市的风景。诚然如此，但是我终究是没有心情游玩的。我只是对不同城市有了更加形象的认识。我见识过北京郊区晚上的静谧，北京地铁海淀黄庄站的人流匆匆，广州不眠的夜晚与灯光，成都雨后的夜晚，上海随处可见的繁华，杭州如画美丽的西湖，长沙回程的路在去漫展时走过……有的城市我是第一次前往，有的城市我曾经去过，还有的城市我已经待了很久了……</p><p>我很喜欢上海，曾把复旦专硕作为自己锚定的结局。但是复旦终究与我无缘，两次拒绝我入营。我喜欢上海交大，因为这是米哈游发源的地方，同样也是我高考时想都不敢想的学校，但终究硕士不够格、直博不想读。我喜欢同济大学，同济大学也是我高考时高攀不起的学校，但拿到了优营之后，又有了其他的想法，最终放弃。最后想起来，也许我与上海在这一阶段，暂时无缘了，希望以后在工作的时候能有缘分吧。</p><p>A橙学长曾经说过，“保研，是一个不断认清自己的过程”。诚哉斯言。我从最初觉得同济就是很好的去处，到拿到南大的硕，再到拿到清华的硕。每一步的前进，都是我从不敢想象的，都是我从没有料到的，都是突破自身认知极限的。我不是一个很有自信的人，因此总是按照下限去定目标，在一次次得到了正面的反馈后，我才意识到，哦，原来我能够到这么远。诚然，保研也是一个探究自己极限的过程。有些事情，不去试，永远不知道自己能不能成；有些路，不去走，永远不知道自己能走多远；有些机会，不去拿，永远不知道自己能不能拿到。因此，只有不断尝试，不断探求自己能力的极限，才会不后悔，才会“尽吾志也而不能至者，可以无悔矣”。这一点我要感谢我的母亲，是她鼓励我去尝试所有可能的路径，我在清华机考前，自我怀疑过，“我都不知道我来这里干什么”，是我母亲一直坚持认为我要尝试所有可以尝试的机会，不留下后悔。</p><p>真的到了最后的最后的时候，确定了自己的去向之后，我开始关注身边的朋友们：隔壁专业的第一，在928早上候补到了复旦热门方向的学硕；隔壁另一个专业的第一，在927早上得到了复旦预推免的专硕；一起面试浙大的本校同学决定放弃浙大候补去本校的直博；一起去南大预推免的本校同学最终候补到了南大，我也最终候补到了南大……这一切的一切好似我追的番剧最终有了圆满的结局，又像失落的拼图一块一块都拼了起来。大家都有了自己满意的去处，有点像童话里的美好大结局。</p><p>保研是一个很漫长的过程，真正的战争从大一就开始了。这三个月（7、8、9）的夏令营和预推免，只是检验三年成果的一个契机。友情、亲情、师生情、运气、能力、机遇、奇遇、状态、临场发挥、身体健康……每一个因素都可能被放大为决定因素，每一个因素都在每个维度影响着最终的结果。保研是一个巨大的不定方程，你不可能将所有变量纳入考虑，比你能力强的某一个同学采取了什么样的填报策略，又发挥如何，题目是不是合他的胃口，是不是合你的胃口，wl前面的同学是不是因为有了更好的去处而放弃了offer给我让出了位置……这样的变量多到无法想象。我能做的，只有尽量把自己可以影响甚至决定的因素做到最好，然后静待结果。有时候，会发现即使我能做的全部拉到最好，我能干预的仍然是有限的。这个时候，能做事的，就只有命运的回响了。</p><p>至此，我们的故事结束了，而从今以后，就是你的故事了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个夏天，我与保研</title>
      <link href="/2024/09/29/Bao-Yan-2/"/>
      <url>/2024/09/29/Bao-Yan-2/</url>
      
        <content type="html"><![CDATA[<h1 id="浅记我的保研"><a href="#浅记我的保研" class="headerlink" title="浅记我的保研"></a>浅记我的保研</h1><p>谨以此帖记录近三个月以来的见闻，为这三年的努力画上一个圆满的句号。</p><p>【由于跟院校签了协议，所以有些地方不能写出来，如果你确实想去报考这个院校的话，请私下跟我联系，或者之后可能会单独出一个帖子讲这些题目】</p><p>之后会出一篇文章专门讲我觉得该如何准备推免，本文主要是我本人的个人经历，所以可能没有那么多系统性的干货。</p><p>【置顶】由于许多学校都签了保密协议，故在未入学之前，我不会放出任何复试考核相关的内容。本经验贴被重新复核过一遍，并删除了所有敏感的内容。预计2025年之后可能放出。</p><h2 id="广告与资源"><a href="#广告与资源" class="headerlink" title="广告与资源"></a>广告与资源</h2><p>【重要】必须要重点推荐绿群QQ（吃水不忘挖井人）：943826679</p><p>【另外】如果你是HNUers，欢迎加入HNU小绿群：439182875</p><p>【再次】如果你是HNUers，这里有本校专用的资源：<a href="https://y-s-organization.gitbook.io/hnu-cs-baoyan">HNU保研</a></p><h2 id="本人定位"><a href="#本人定位" class="headerlink" title="本人定位"></a>本人定位</h2><ul><li>末九cs rk1&#x2F;140+ （推免遴选rk3，故可能会有冲突）</li><li>成绩：92+（具体的分数不重要，主要还是看rk）</li><li>英语：CET4：600+；CET6:：600+</li><li>编程：CSP：前6%</li><li>奖学金：连续两年国奖（最终是连续三年国奖）</li><li>竞赛获奖：有数模、数竞、蓝桥杯水奖</li><li>科研项目：两个水项目，无科研产出</li></ul><p>目标：清北可尝试即可，华五计院&#x2F;学硕优先，华五软可接受，华五专硕可接受，浙软南软低优先，华五弱组&#x2F;坑导可接受。中九计院、中九软院次之。本校保底。不接受任何直博。随情况再调整。</p><p>夏令营目标：拿下中山作为保底</p><p>预推免目标：冲刺华五，尝试清北</p><h2 id="最终去向"><a href="#最终去向" class="headerlink" title="最终去向"></a>最终去向</h2><p><img src="/Bao-Yan/baoyan-1.png" alt="最终去向"></p><h2 id="情况总览"><a href="#情况总览" class="headerlink" title="情况总览"></a>情况总览</h2><p>参营院校</p><table><thead><tr><th>院校</th><th>入营</th><th>优营效力</th><th>结果</th><th>实际获得</th><th>操作</th></tr></thead><tbody><tr><td>同济电院</td><td>夏令营入营</td><td>仅排序</td><td>优营40+&#x2F;92</td><td>学硕offer</td><td>928放弃</td></tr><tr><td>成电计院</td><td>夏令营入营</td><td>双选后铁offer</td><td>优营40+&#x2F;100</td><td>学硕offer</td><td>905放弃</td></tr><tr><td>人大信院</td><td>夏令营入营</td><td>仅排序</td><td>优营30+&#x2F;72</td><td>wl（929补到）</td><td>929-11点补到&#x2F;放弃</td></tr><tr><td>上交电院</td><td>夏令营入营</td><td>仅排序</td><td>优营100+&#x2F;123</td><td>wl（929补到）</td><td>919放弃</td></tr><tr><td>中山计院</td><td>夏令营入营</td><td>铁offer</td><td>优营30+&#x2F;400+</td><td>学硕offer</td><td>926放弃</td></tr><tr><td>国防科大计院</td><td>夏令营入营</td><td>仅排序</td><td>优营170&#x2F;467</td><td>硕士offer</td><td>904放弃</td></tr><tr><td>南大计院</td><td>预推免入营</td><td>铁offer</td><td>预推免批次wl</td><td>wl（927补到专硕offer）</td><td>929接受复试，拒绝录取</td></tr><tr><td>清华软院</td><td>预推免入营</td><td>铁offer</td><td>初步录取</td><td>专硕offer</td><td>最终去向</td></tr><tr><td>浙大工院</td><td>预推免候补入营</td><td>铁offer</td><td>总批次wl前10</td><td>wl（929实际补到）</td><td>928未填系统，默认放弃</td></tr><tr><td>湖大信院</td><td>预推免入营</td><td>铁offer</td><td>预推免批次前5（offer）</td><td>学硕offer</td><td>928未填系统，默认放弃</td></tr></tbody></table><p>考虑院校</p><p>（空格处表示没有考虑或没有交集，情况包含了一些自己打听获取到的信息）</p><p>一般为高校的计算机学院、软件学院、AI学院（一般为新成立），或是电院（常见于上海的学校，上交同济等）</p><table><thead><tr><th>层次</th><th>院校</th><th>夏令营</th><th>预推免</th><th>情况</th></tr></thead><tbody><tr><td>清北</td><td>清华叉院</td><td></td><td>不开</td><td>计科最高bar，自认为实力不符</td></tr><tr><td></td><td>清华计系</td><td>不发offer</td><td></td><td>计科最高bar，自认为实力不符</td></tr><tr><td></td><td>清华AI</td><td></td><td>不开</td><td>24年新开的学院，bar未知，但清华的title+AI相关，估计bar很高，没敢报</td></tr><tr><td></td><td>清华软院</td><td></td><td>入营优营</td><td>之前本校有学长学姐的去向，遂尝试，也是我的最终去向</td></tr><tr><td></td><td>清深计科</td><td></td><td>未过初筛</td><td>我错过时间未投递。本专业持有rk1投递，优营，据说只发19个优营，含金量非常高。</td></tr><tr><td></td><td>清深AI</td><td>未过初筛</td><td>未投递</td><td>本专业持有rk1投递，均未通过</td></tr><tr><td></td><td>清深大数据</td><td>未过初筛</td><td>未过初筛</td><td>本专业持有rk1投递，均未通过</td></tr><tr><td></td><td>北大叉院</td><td></td><td></td><td>计科最高bar，自认为实力不符</td></tr><tr><td></td><td>北大计院</td><td></td><td></td><td>计科最高bar，自认为实力不符</td></tr><tr><td></td><td>北大AI</td><td></td><td></td><td>21年成立，同样由于title+AI，估计bar很高，没敢报</td></tr><tr><td></td><td>北深信工</td><td></td><td></td><td>弱com，需要联系导师，遂未报</td></tr><tr><td></td><td>北大软微</td><td>初筛过，论文筛寄</td><td></td><td>bar比较高。6.20晚给通知要读论文，特意避开了最卷的方向，但6.28没收到进一步邮件，被默拒</td></tr><tr><td>华五</td><td>南大计院</td><td>初筛过，线上机考寄</td><td>初筛过，线上机考过，最终wl</td><td>线上机考考研难度，对专业课要求极高。本年夏令营本专业放到rk3，；预推免的bar更低，更容易拿优营或者前排wl（仅仅是本次，不可以认为一直是），但优营很少（100人发10offer左右）</td></tr><tr><td></td><td>南大AI</td><td>未过初筛</td><td></td><td>似乎bar较高，机考考核算法+机器学习python实现。本专业持有rk1投递，教务打电话询问，后称“没关系的”，均未通过</td></tr><tr><td></td><td>南大软院</td><td>过初筛</td><td>放弃</td><td>南软夏令营会发offer，但预推免offer数量就很少了（70人发5offer）。夏令营时和人大信院&#x2F;成电冲突，遂放弃；预推免时与南计冲突，只可去一个，遂放弃。听说预推免全员wl，很抽象</td></tr><tr><td></td><td>南大智科（苏州）</td><td>放弃</td><td>放弃</td><td>难度大，似乎50人左右入营发不到15个优营，本校入营同学未获得优营。夏令营时与南软冲突，放弃；预推免时与南计冲突，只可去一个，放弃</td></tr><tr><td></td><td>复旦计院</td><td>未过初筛</td><td>未过初筛</td><td>bar极高，本专业只放核心rk1入营，本校其他专业的rk1最终候补到了学硕，身边其他人都没过。我被双杀，离谱。</td></tr><tr><td></td><td>复旦大数据</td><td></td><td></td><td>bar较高。复旦只可投递一个，冲突。本专业持有rk1入营且优营。</td></tr><tr><td></td><td>复旦类脑</td><td></td><td></td><td>bar未知。复旦只可投递一个，冲突。其他专业有rk1得到优营但放弃。</td></tr><tr><td></td><td>上交电院（计算机系）</td><td>入营且wl</td><td>不开</td><td>bar极高，本校只放1人入营。上交很重视机考，我机考炸了，故wl。机考100分+面试100分，有斩杀线，低于120分斩杀，高于120分全进候补。今年据说鸽到蛮后面。52学硕+20专硕，但我位次95+的同学补到了专硕。</td></tr><tr><td></td><td>上交电院（软件）</td><td>冲突</td><td></td><td>bar较高，比计算机系低一些，放本专业和软件rk1入营。据说要读论文，机试非常难。有斩杀线，第一天机考低于20分直接不予面试。</td></tr><tr><td></td><td>上交AI院</td><td></td><td></td><td>bar极高，第一年开，只放985纯计科rk1（华五多放几个）进。但很容易优营。机试非常简单，据说还有很社死的做游戏环节。有斩杀线，低于120被斩杀。我看到wl只有6人，知道必被鸽穿，果然927被鸽穿。</td></tr><tr><td></td><td>浙大计院</td><td>只开直博</td><td></td><td>直博弱com，夏令营做项目，重视科研。硕士只开预推免且只有面试，929当天几乎鸽穿。（位次倒数的同学929中午左右补到了但已经去了别的地方）</td></tr><tr><td></td><td>浙大软院</td><td>入营放弃</td><td></td><td>在浙江宁波。夏令营发优营和卓越营员（不等于offer），预推免听说机考今年有近乎三分之一的满分，一百多人。929没被鸽穿。</td></tr><tr><td></td><td>浙大工院</td><td></td><td>候补入营+wl</td><td>bar比较迷，我是候补入营的，一开始没放我进去。夏令营&#x2F;预推免只能进一个。只有面试，我在候补靠前，929当天能补到。</td></tr><tr><td></td><td>浙大大数据</td><td></td><td></td><td>在浙江海宁，没想去。</td></tr><tr><td></td><td>中科大计院（11系）</td><td>不可兼报</td><td></td><td>bar基本能放到rk3。应该能进，但是没投递（因为联系了6系的实验室，故投递了6系）</td></tr><tr><td></td><td>中科大信院（6系）</td><td>未过初筛</td><td>未过初筛</td><td>bar很高。只放了计科核心rk1入营。后来学长说计科去是类似跨专业，故只掐尖。</td></tr><tr><td></td><td>中科大AI与大数据</td><td>不可兼报</td><td></td><td>bar应该很高，只放了智能专业rk1入营。而且要双选才有效，本校同学未双选优营失效。</td></tr><tr><td></td><td>中科大先研院</td><td>不可兼报</td><td></td><td>未详细了解</td></tr><tr><td></td><td>中科大苏高院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>人大高瓴</td><td></td><td>不开</td><td>bar很高，本校无人入营。注意人大高瓴学硕&#x2F;直博三个赛道，且不可随意变更。</td></tr><tr><td></td><td>人大信院</td><td>wl</td><td>不开</td><td>bar很高，本校学硕入营1人，专硕入营2人。专硕929中午候补到，据说当天鸽到50+，几乎鸽穿。注意人大信院学硕&#x2F;专硕&#x2F;直博三个赛道，且不可随意变更。</td></tr><tr><td>C9</td><td>哈工深计院</td><td>未过初筛</td><td>放弃</td><td>bar很高，夏令营本校无人入营。夏令营只放40人入营，教务称“生源质量很好”，预推免开了三批，显然被鸽穿。预推免放我进入，但与南计冲突，拒绝。</td></tr><tr><td></td><td>哈工本计院</td><td></td><td></td><td>bar还行，好像筛985生源。未投递，不想去北方（虽然最后还是去了北方的学校）</td></tr><tr><td></td><td>哈工威计院</td><td></td><td></td><td>bar不高，计科有rk10+入营。我未投递，感觉优先级低于本校。</td></tr><tr><td></td><td>西交计院</td><td>宣讲营</td><td></td><td>bar不高，本校rk10+都可。弱com，与老师谈好即可，预推免走形式即可。</td></tr><tr><td></td><td>西交软院</td><td></td><td></td><td>bar不高，985都可。弱com，钱塘潮每年名场面贡献指定。</td></tr><tr><td>985</td><td>同济电院</td><td>优营</td><td></td><td>bar极高，只放rk1，人称“小复旦”，优营率高且稳，适合高rk用来保底</td></tr><tr><td></td><td>同济软院</td><td></td><td></td><td>bar很高，本校有人入营。但夏令营优营无效力，直通预推免</td></tr><tr><td></td><td>同济无人系统中心</td><td></td><td></td><td>bar未知。出的太晚，我已报电院</td></tr><tr><td></td><td>北航计院</td><td>宣讲营</td><td>929面试</td><td>bar还可，今年本校很多上岸北航的同学。</td></tr><tr><td></td><td>武大计院</td><td>入营放弃</td><td></td><td>bar较高，本专业有优营。机考和面试并重。我与sjtu冲突，放弃，优营率很高。</td></tr><tr><td></td><td>武大国重</td><td></td><td></td><td>bar尚可，本专业低rk最终去向。优营率较低，据说本校无人夏令营优营。</td></tr><tr><td></td><td>华科计院</td><td>只招直博</td><td></td><td>bar较低，预推免时基本上本校都可以去。929被鸽穿，晚上还在招人。我已有同济优营，不想去武汉，故未报。</td></tr><tr><td></td><td>华科AI院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>东南电院</td><td>只有8月末夏令营+预推免</td><td></td><td>bar不高，本校有同学最终去向。我已有同济优营，故未报。</td></tr><tr><td></td><td>中山计院</td><td>优营</td><td></td><td>bar不高，本专业基本放到rk10，最终本专业夏令营去了10人。夏令营优先级大于预推免，由于年年鸽穿，故候补基本上等于offer。今年929又被鸽穿，夏令营拿候补都能补到。</td></tr><tr><td></td><td>电科计院</td><td>优营</td><td></td><td>夏令营发100优营，预推免发100优营。据说分组打分差异大。成都离家太远，故没想去这里发展。</td></tr><tr><td></td><td>南开计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>南开软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>南开AI院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>天大计院</td><td></td><td></td><td>天大杯xcpc邀请赛，大海营，有线上机考，通过方可去线下，听说优营效力没那么高</td></tr><tr><td></td><td>北理计院</td><td></td><td></td><td>听说都是内部消化了</td></tr><tr><td></td><td>北理叉院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>山大计&#x2F;AI院</td><td>宣讲</td><td></td><td>未详细了解</td></tr><tr><td></td><td>山大软院</td><td>宣讲</td><td></td><td>未详细了解</td></tr><tr><td></td><td>山大数据科学</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>华东师大计院</td><td>未入营</td><td></td><td>bar神奇。我作为本校唯一rk1未入营，据说要联系导师才可入营。</td></tr><tr><td></td><td>华东师大软院</td><td>未入营</td><td></td><td>bar极高，本校rk1入营，以rk3投递未入营。</td></tr><tr><td></td><td>华东师大数据科学与工程学院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>厦大信院</td><td>未入营</td><td></td><td>bar很迷。唯一rk1投递未入营（总不能是oq了吧），似乎要联系导师（但是老师都不回复）</td></tr><tr><td></td><td>厦大AI院</td><td></td><td></td><td>bar很迷。需要厦大老师推荐信（但是老师都不回复）</td></tr><tr><td></td><td>中南计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>北师AI院</td><td></td><td></td><td>bar很低。感觉可以旅游营，但是太累了，不想再去一次北京了，遂没报。</td></tr><tr><td></td><td>西工计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>西工软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>川大计院</td><td></td><td></td><td>行程硬控5天，太难受，遂没报。只有一个线下机考两个小时，</td></tr><tr><td></td><td>川大国重</td><td></td><td></td><td>bar不高。入营20人，约招8人，后来发现其实可以投着试试的，挺可惜。本校有人去了这个，应该拿到了优营。</td></tr><tr><td></td><td>华南理工软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>东北计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>东北软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>吉大计院</td><td></td><td></td><td>夏令营第一个开，被很多人拿来练手。</td></tr><tr><td></td><td>吉大软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>吉大AI院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>重大计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>重大卓工</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>大工计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>大工软院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>湖大信息</td><td>入营放弃</td><td>优营</td><td>今年不提供本校保底，甚至把本校在预推免靠前的同学放在候补。若未及时点击确认不保证录取。</td></tr><tr><td></td><td>国防科大计院</td><td>优营</td><td></td><td>bar不高，rk10左右也能去。夏令营分两批次，按分数合并。估计也能鸽穿。</td></tr><tr><td>211</td><td>北邮计院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>北邮AI</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>西电</td><td></td><td></td><td>未详细了解</td></tr><tr><td>研究院所</td><td>中科院计算所</td><td></td><td></td><td>bar很高。未报名，感觉不配</td></tr><tr><td></td><td>中科院自动化所</td><td>入营放弃</td><td></td><td>bar很高。入营，紫东初阳大模型研究中心推荐我入营的，该中心2022年成立。当时太累了放弃了。</td></tr><tr><td></td><td>中科院软件所</td><td></td><td></td><td>未入营，感觉只招软件，同校软件很多入的，应该是筛软件了</td></tr><tr><td></td><td>中科院信工所</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>中科院深先所</td><td></td><td></td><td>未详细了解。被称为“神仙所”。</td></tr><tr><td></td><td>中科院杭高院</td><td></td><td></td><td>未详细了解</td></tr><tr><td></td><td>中科院上高院</td><td></td><td></td><td>未详细了解</td></tr></tbody></table><h2 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h2><p>总结：基本符合预期，拿下了中九的保底offer。为预推免冲华五奠定了良好的基础。</p><h3 id="6-28-同济电院"><a href="#6-28-同济电院" class="headerlink" title="6.28 同济电院"></a>6.28 同济电院</h3><p>时间线：</p><ul><li>6.28 报到</li><li>6.29 机试+笔试+专业英语</li><li>6.30 面试+面试英语</li><li>7.5 优营结果公示，有优营</li><li>9.10 告知老师放弃，老师说愿意等我再考虑一下（感谢老师！）</li><li>后续：告知老师确认放弃，得到老师的祝福（老师人真的好好）</li></ul><p>入营情况&amp;优营效力：</p><ul><li>（官方说法）：6月28日至30日，我院第十三届全国优秀大学生暑期学校在嘉定校区圆满举行。本次暑期学校共有230所高校的3166名学生报名，经过专家组筛选，451名学子从全国75所国内重点高校中脱颖而出，包括哈尔滨工业大学、西安交通大学、西北工业大学、厦门大学、中南大学、四川大学、南开大学、山东大学、东北大学、东南大学、北京理工大学、华南理工大学等知名高校。（然而没有本校）</li><li>入营的bar比较高，感觉末九只放各专业rk1进（不限定计科），本专业rk3未入营，本校只放计科、信安、软件rk1共3人入营。入营还搞了一个很长的候补队列。</li><li>入营即offer，只是把入营者进行了一个排序。计算机科学与技术入营92学硕30专硕，全部给了优营。</li></ul><p>考核：</p><p>【暂时隐藏】</p><p>机试40分+笔试60分+面试150分+专业英语50分+面试英语50分</p><p>机试（40分，1.5小时）纯送分题</p><ul><li>10分，给字符串，要求按照规定格式输出，for循环即可解决。</li><li>15分，数独寻找冲突，分别找出行列宫的第一个冲突的地址，for循环即可解决。</li><li>15分，打印数字三角形，若打表机试部分0分处理，必须使用递归完成。递归即可。</li></ul><p>笔试（60分专业课+50分专业英语，总共1.5小时，完全来不及）：</p><p>专业课（完整考察408，均有考到，《王道》难度，不少原题）20选择10填空10判断4大题，大题5分一题其余1分一题。</p><p>专业英语（新闻报道类文章20分+论文原文30分，分别是4道题目和3道题目）</p><ul><li>主要时间太紧了，根本没来得及看全原文，只能瞎写一些上交了，但看到同学基本都写满了，还分点写的，心里很不是滋味，当天晚上心里很难受。</li></ul><p>面试（150分专业综合+50分英文面试，不同组考核的差别较大）</p><p>流水日记：</p><ul><li>6.28 从杭州出发，晚上到达上海，转地铁转了好久才到嘉定，有学长在酒店大堂等待我们并给我们发参营用品。有一件衣服（很大气，用料很好，可以经常穿），一本笔记本，一个很好看的同济大学的帆布袋，一支笔还有一沓餐券（狠狠夸奖同济的餐食，中餐晚餐餐券25元，早餐餐券8元，真的好吃的不得了）。同济的酒店定在格林豪泰，两人一间，我跟同校信安的同学一起住。晚上下雨，前往同济校园稍微转了转，但是吃饭的时候食堂已经关了，遂随便解决了一下。同济的校园很大，有一个护城河一样的河流。有很多高楼，有一个很大的操场，很有校园氛围。</li><li>6.29 早上开营仪式+参观实验室。开营仪式水过去了，实验室只参观了两个感兴趣的。看了一个在地下室的偏雷达探测的实验室，然后看了一个类脑研究的实验室。下午机试+笔试。机试难度太低了，基本上直接AC了，我对于数独那道题理解一开始有点偏差，多花了点时间，考场很多人就直接离开了。笔试难度尚可，但是时间太少了。我先做的英语第一篇，再做专业课，最后补做英语第二篇。英语第二篇没有完卷。然后整个晚上都处于一种抑郁的状态。考完后跟同学一起逛了校园，今天晴天，夏日的微风轻拂过，再加上黄昏的夕阳，同济的校园显得很美。但我当时感觉这个笔试的发挥不一定能来了，所以心里无限感伤。当时心里挺难受的，渴望，但又感觉大势已去，有种说不出来的感觉。</li><li>6.30 早上面试，我在比较靠前的位置，本来以为能在中午吃饭之前面试的，结果了正好到我的时候老师就去吃饭了。这意味着我是下午第一个接受面试的，一想到老师酒足饭饱之后精神焕发来拷打我，就不寒而栗。我没吃中饭，因为吃饱饭之后人容易发昏。多出来的这半个小时左右的时间我跑到了四楼去自己跟自己说话，从头演练了一遍可能被问到的问题然后自己回答，包括英语问题都演练了一遍。然后面试总体比较顺利，面试完后回到食堂好好地吃了一顿。离开的时间同济又是大雨，我匆匆忙忙地坐着嘉松线离开了嘉定。感觉对于同济，真是非常的喜欢。</li><li>7.5 早上在人大信院报道时看到，优营中间。</li><li>7.6 晚上手动排序了一下，共92个优营，排位40+，中偏前。总共112人，发了92个优营，真的是80%优营率。</li><li>7.4 老师联系我，问是否确定之后来，我说想试试上交，老师表示理解。</li><li>感觉同济是最值得投递的学校，对于rk1非常友好，是一个很稳很稳的保底选择，有了同济的优营之后，我在参加其他学校的夏令营的时候心态上都比较稳，有助于更好的发挥。</li></ul><p><img src="/Bao-Yan/baoyan-tongji2.png" alt="同济大学"></p><p><img src="/Bao-Yan/baoyan-tongji1.png" alt="同济大学夏令营发放的礼包"></p><p><img src="/Bao-Yan/baoyan-tongji3.png" alt="同济电院欢迎参加夏令营同学们"></p><p><img src="/Bao-Yan/baoyan-tongji4.png" alt="同济发的餐券，很大气，能吃的很饱"></p><p><img src="/Bao-Yan/baoyan-tongji5.png" alt="同济的饭菜非常好吃"></p><h3 id="7-3-成电计院"><a href="#7-3-成电计院" class="headerlink" title="7.3 成电计院"></a>7.3 成电计院</h3><p>时间线：</p><ul><li>7.3 报到</li><li>7.4 面试</li><li>7.5 结果：在人大信院考完机考之后考笔试之前看到，优营。晚上数了一下40+&#x2F;100的位置。</li></ul><p>总评价：抽象，只有7.4的一场面试，有主持人，主持人会引导面试过程进行。</p><p>另外：成电取得优营之后还要联系老师并通过老师的考核，这样才能找到自己心仪的老师。</p><p>面试：【暂时隐藏】</p><p>总体感觉：</p><p>成电是我经历的最不像夏令营的一个学校，它完全可以直接称为是一个“面试”，核心部分也就只是一场面试而已。但是成电是一个很好的学校，校园景色也十分优美，作为我的第二站，真的很有校园氛围的感觉（除了本校，都有校园氛围感doge）。</p><p><img src="/Bao-Yan/baoyan-uestc-1.png" alt="在住的地方远眺成电全景"></p><p><img src="/Bao-Yan/baoyan-uestc-2.png" alt="等候室，这个教室很新，我很喜欢"></p><p><img src="/Bao-Yan/baoyan-uestc-3.png" alt="成电校园景色一角，建筑各有特色"></p><p><img src="/Bao-Yan/baoyan-uestc-4.png" alt="成电结束后，一晚上直飞北京，挑战的就是一个极限"></p><h3 id="7-5-人大信院"><a href="#7-5-人大信院" class="headerlink" title="7.5 人大信院"></a>7.5 人大信院</h3><p>时间线：</p><ul><li>7.5 报到，机考</li><li>7.6 面试</li><li>7.7 坐动车离开北京</li></ul><p>优营效力：入营130，到场86，优营71，只排序不定性（即不发优营&#x2F;offer&#x2F;候补等）</p><p>7.4晚上21：30从成都双流飞北京大兴，睡下已经1:00了。7.5早上7点起床，换乘3趟地铁到海淀黄庄下，到人大信院报道。7.5中午开营然后下午马上机试笔试，7.6早上面试，先集体群面，全部群面完之后再单面。</p><p>补充：人大提供住宿，这一点对于中关村附近非常重要，一晚上300多的住宿真的扛不住。然后还附赠的是人大的入校权限，预约几乎不可能成功的。</p><p>考核要求：数据结构与算法（80分）+程序设计机考（20分，支持C&#x2F;C++&#x2F;Python【python只支持最基本库】）专业课及综合素质面试（150分）英语口试（50分）</p><p>【占比20分】机考（1小时3道题，时间很赶）：</p><ul><li>（1）收集雨滴问题：几个挡板中拿出两个来，能聚集最多的水。暴力80分。【这道题是LeetCode上经典的问题，但当时我没练，所以只会暴力骗分】</li><li>（2）大模拟：实现高考的赋分制，还要查询。主要逻辑都写出来了，拿了50分，没有敲一分一段对应的，时间来不及了。</li><li>（3）称重问题，n个砝码，每种分别重x[i]，每种有y[i]个，问有多少种可能的情况。暴力30分。</li></ul><p>【占比80分】笔试（1.5小时，时间太宽裕）：</p><p>【由于保密协议，略过】考察了基础408问题，很简单，稍微过一遍408的数据结构就能全部答上来。</p><p>面试：</p><p>群面：</p><ul><li>每个问题最多3人回答，共9人，第一轮必须每人回答一次。总共15分钟，时间够到问了4个问题，我只回答了第二个问题，但是我是第一个回答的，后面两个人基本是在重复我的论点。</li></ul><p>单面：</p><p>（只有10分钟，感觉时间确实太短了。本来是两天面试，但是全部压缩到一天，导致本来能面15分钟现在只能面试10分钟）</p><p>上来直接抽信封，我选的9号。可能之前成电抽题运气太好了，这次题目都不太会回答。</p><p>【占比50分】英语：</p><ul><li>感觉英文问题总体回答还算正常，但是比较磕磕绊绊，显得不太熟练，与四六级双600有很强的对比。</li></ul><p>【占比150分】专业</p><ul><li>专业真的一团糟</li><li>我感觉专业课一团糟，我表现的像一个没有深入思考的人。而且这些问题都是较简单的问题，我答成这个样子，真的很说不过去。还有脑子抽了，太急了。后来跟其他人交流了解到如果不会，其实可以直接跟老师说不会，这样就可以听到后面的问题，有更多的机会展示自己。然后其他人都问到简历了，我的专业课时间太久了，所以简历都没有面到，真的很烦，感觉很好的一次机会就因为我的不理智浪费掉了。</li></ul><p>美丽的RUC校园：</p><p><img src="/Bao-Yan/baoyan-ruc-2.png" alt="明德楼前的标志性校徽"></p><p><img src="/Bao-Yan/baoyan-ruc-3.png" alt="中国人民大学！"></p><p><img src="/Bao-Yan/baoyan-ruc-4.png" alt="世纪馆，以及体育场"></p><p><img src="/Bao-Yan/baoyan-ruc-14.png" alt="党办的大学，让党放心"></p><p><img src="/Bao-Yan/baoyan-ruc-5.png" alt="I love RUC ！"></p><p><img src="/Bao-Yan/baoyan-ruc-9.png" alt="雄伟的明德楼（绿群的群友都在说明德楼前一堆鸽子hhh）"></p><p><img src="/Bao-Yan/baoyan-ruc-10.png" alt="崇德楼，与明德楼各有特色"></p><p><img src="/Bao-Yan/baoyan-ruc-7.png" alt="RUC提供给夏令营同学的宿舍，很温馨"></p><p>北京的其他地方：</p><p><img src="/Bao-Yan/baoyan-ruc-11.png" alt="夏日午后的海淀路，这个路牌画风好像动漫里那种感觉"></p><p>既在北京，没理由不朝圣清北。但是来之前都在准备复试，没有预约门票，显然是没法进去的。</p><p><img src="/Bao-Yan/baoyan-ruc-12.png" alt="借用一个流行说法：京城双日凌空-天下第一文宗-未名琳琅阁"></p><p>当时还不知道，与清华的缘分在后面还有，只是抱着朝圣的心态，觐见了每一个学子的梦想。没法进到二校门，只能在西门口草草拍了一张照片，以证明我来过。</p><p><img src="/Bao-Yan/baoyan-ruc-13.png" alt="借用一个流行说法：京城双日凌空-天下第一武宗-清泉春晖殿"></p><p><img src="/Bao-Yan/baoyan-ruc-6.png" alt="大兴国际机场，当年高考八省联考模拟的数学题也是亲眼见到了"></p><p><img src="/Bao-Yan/baoyan-ruc-1.png" alt="海淀黄庄地铁站，听闻已久的卷王中心"></p><p><img src="/Bao-Yan/baoyan-ruc-8.png" alt="中关村的双向八车道地下隧道"></p><h3 id="7-10-上交电院计系"><a href="#7-10-上交电院计系" class="headerlink" title="7.10 上交电院计系"></a>7.10 上交电院计系</h3><p>时间线：</p><ul><li>7.9 动车前往上海</li><li>7.10 机考</li><li>7.11 面试</li><li>9.10 放弃直硕优秀生源</li></ul><p>总体评价：好不容易有几个赏识我的老师，却配上一个差地不能再差的机考成绩。</p><p>机考：</p><p>上交电院的机考是我见过难度最高的，主要在于每道题都只给一段时间做，做完了也只能等着，没做完时间到了之后就没法回来做了。这样就没法对时间进行重分配以拿到更高的分数，对于能否一遍把代码逻辑完全写对、以及现场debug是一个很严重的挑战。你需要把代码写地又快又好。机考不允许携带任何资料。</p><p>机考环境是使用头哥平台，这个平台很抽象，它有些错误不会报错，如果有问题，它就直接不显示输出了，这让我没办法进行debug，所以第二题就没有调出来。再加上时间很紧迫，故整个过程心态很炸裂，结束后我知道基本上没戏了，遂在电院旁的湖边跟同学打了一个小时的电话，遗憾这一次上交之行。</p><p>由于【保密要求】我不得泄露试题，我只能大概泛泛讲讲内容。</p><p>机考试题：</p><ul><li>第一题：类似于单源最短路径加上一个附加的条件，做一些改动。</li><li>第二题：对一些节点进行判断，能否成树，若能那么树根是谁。</li><li>第三题：大模拟，实现一个Linux的文件系统的部分功能。</li></ul><p><img src="/Bao-Yan/baoyan-sjtu-1.png" alt="机考规则"></p><p>面试：</p><p>给老师提交了材料之后，老师说，你做个自我介绍吧。 自我介绍 具体问了项目，具体是什么。我做了什么工作。我们团队有几个人，我承担了什么工作。</p><p>【暂时隐藏】</p><p>面试结束之后有不止一个导师加我微信，询问我是否有意愿了解他们的方向。从老师反馈来看我的面试应该是非常好的，只是可惜机考实在太差了，这样看应该是无缘了。</p><p>【2024.10.18补充】上交最后录取学硕52专硕20，实际最终录取到优秀生源排序最后三位为96，99和119（121.8分）。优秀生源总共123人，所以实际上是快穿了。实际上我如果什么都不做，在929当天会被录取为最后一个专硕。也许这就是命运的轨迹吧。</p><p><img src="/Bao-Yan/baoyan-sjtu-8.png" alt="上交的校园环境真的太优美了，是梦想中的学校的样子"></p><p><img src="/Bao-Yan/baoyan-sjtu-2.png" alt="上交电院——永远的家"></p><p><img src="/Bao-Yan/baoyan-sjtu-3.png" alt="I love SJTU"></p><p><img src="/Bao-Yan/baoyan-sjtu-4.png" alt="上海交大！真是高考时做梦都没能想过的梦想"></p><p><img src="/Bao-Yan/baoyan-sjtu-5.png" alt="上交的教室——让每个学生更加优秀！"></p><p><img src="/Bao-Yan/baoyan-sjtu-6.png" alt="上交的饭菜（甚至没有本校的好吃）"></p><p><img src="/Bao-Yan/baoyan-sjtu-7.png" alt="前往广州中山——也是坐上了原神专机啦"></p><h3 id="7-12-中山计院"><a href="#7-12-中山计院" class="headerlink" title="7.12 中山计院"></a>7.12 中山计院</h3><p>时间线：</p><ul><li>7.11 飞机前往广州</li><li>7.12 上午模拟机考，下午机考</li><li>7.13 早上开营仪式，下午参观导师实验室+参观超算中心</li><li>7.14 面试</li><li>7.16 中午出优营结果</li><li>7.17 离开广州</li><li>9.26 向limei确认放弃</li></ul><p>7.12 上午机考模拟，下午机考</p><p>机考内容有 程序设计+数据结构+模拟+算法</p><p>我机考大概是576。共10道题，满分1000分，我做出来4道题（链表实现、并查集、类继承、模拟）。记忆化递归51分，这个是因为超时了。有一个逆序对的25分。然后骗分30+30+30+20（长度太长，截断了，没法打表）。</p><p>机考过编译10分，过标准样例20分，随机测评70分。而且标准样例和随机样例的预期结果和实际结果都是可以看的（因为长度原因超过而被截断的看不了），所以可以骗部分分。</p><p>【暂时隐藏】</p><p>7.13 早上开营仪式，下午参观导师实验室+参观超算中心，和两个稳中山的同学共6人一起吃了个晚饭，拍了合照。</p><p>下午进老师实验室，有很好的学长跟我们聊天，讲了在中山生活的感悟，然后老师来跟我们交流，讲了实验室的配置（应该是不缺卡），毕业的条件，放实习的条件等。然后谈了谈他做的方向（应该是有4个方向，基本都是关于CV方向的，里面的小方向，我都挺感兴趣的）。然后老师说，如果真想来sysu，基本都能录上。然后有同学让老师认认我们的脸，多打几分，哈哈。老师说明天他不参与面试。</p><p>7.14 面试：我是计X组，第一天早上第X位参与面试。</p><p>严格计时，满12分钟就结束。有的组会对各部分计时。</p><p>坐在门口等候，前一位出来就进门。两张桌子拼在一起，面试老师坐在对面，也有一个坐在你这边，你前面有个电脑，你的PPT已经被预先放在那里了，你可以用鼠标点击打开PPT与前后切换。总体氛围很宽松，像小组讨论一样。我们组的情况是只有主面老师在提问，其它老师在摆烂或发呆。</p><p>流程是先从信封中抽取英文材料。英文材料大概六七行的样子，科普类短篇或者是新闻报道，专业性不是很强，但可能会有几个专业名词比较陌生。要求先阅读一遍，再翻译。听说有的组会打断，不知道是因为时间到了还是英语实在太broken了。我抽到的是一段关于百度的阿波罗无人车或者是无人出租车，没太搞懂。有简单介绍，然后是人们关于它的顾虑，像一篇科普类新闻。我没有被打断，个别词没读太顺，但英语底子还好，总体比较顺畅。翻译自我感觉也是还可以。也有人抽到5G等，评价是难度不一。</p><p>然后是讲PPT，我就直接大大咧咧地从前往后讲。一开始我以为计时器是对我PPT进行计时的，所以讲PPT就快了一点。我PPT主要介绍了一个项目，其余都是略讲。然后跟老师说如果感兴趣的话之后再提问我（后来想想胆子真是大，有种倒反天罡的美感）。没被打断，直接讲完了。</p><p>讲完PPT之后，主面老师开始问我问题。出乎意料的是，老师没有问项目，似乎对我当助教的经历比较感兴趣。问我助教都干些什么，我说验收实验、讲解试卷、日常答疑等。然后老师又问我们计算机系统课程是不是比较偏软件的？我说是的，我们比较偏硬件的课程主要在计算机体系结构里完成。老师问我都做过哪些？我说我们每个人都要完成一个五级流水线。这个时候老师突然欣慰，脸上笑容更加洋溢了，我心里就感觉不好，果不其然，老师开始很欣慰地拷打专业课了，在这等着我呢。老师问流水线是哪五级？我说IF、ID、MEM、EXE、WB。老师接着问，有哪些因素影响流水线继续推进？我当时没反应过来，就答的预测失败，会使得流水线需要停滞甚至回退。然后老师试图引导我回答更多的原因。我突然想起来那三个因素：结构冲突，数据冲突和控制冲突。然后老师问我控制冲突跟我之前回答的那个是什么关系。我回答应该是包含关系。老师突然笑了，说应该就是一样的。我也笑了，说有点考虑不全面。</p><p>老师继续问我之前的项目，我就把PPT调回去讲了一下那个项目。然后老师比较关心的是我有没有对算法做一些改进。我有点懵了，就说可能在处理数据的代码上有一些改进。这里表现的不太好。老师问是不是把模型缩小了，我说没有缩小模型。</p><p>然后闹钟响了，应该是时间到了，老师就让我出去了。我说谢谢老师，跟你们交流很愉快（这句也有点不知好歹了，有倒反天罡的美感）。然后我就滚出去了。</p><p>滚出去之后，找还没面试的同学交流了一下面试的形势，同时给他们一些信心。我是我们学校10个人中第一个面试的，也是最后分数最高的。中山的面试我感觉酣畅淋漓，可能是之前面试到现在否极泰来了。感觉老师们都挺好的，交流确实很舒服。可能是运气比较好，老师没拷打我数学。听说我们学校别的同学有被拷打线性代数、概率论等。我面试完之后一个最大的遗憾就是没有将本校更进一步向SYSU的老师们展示，感觉我还是做不到游刃有余地切换，还是有一些胆小哈哈。</p><p>不过此时我已经有同济的优营了，来中山其实就是来玩玩，主要跟同学们聚一聚，感觉在一个陌生的地方跟同学们一起玩还是挺有趣的。</p><p>中山我感觉还是有点背景面的意思，我们学校rk靠前的同学得分就是会偏高，甚至4个优营3个都是rk1。提前联系导师对于面试分数没有太大的优势。</p><p>7.15 中午和来参营的共10人拍了合照，下午离开参观了沙面，晚上参观永庆坊。</p><p>7.16 下午参观广东省博物馆，远看广州塔，在广州图书馆休息。晚上补了早茶，和舍友吃了16份广式甜点，很满足。</p><p>7.17 飞机离开广州，飞杭州萧山。广州地铁真的是地狱。我在车陂南站等了大约5趟地铁，全是人，根本上不去。后来来了一辆完全空的地铁，直接人全部挤上去就充满了，后面还有人没上来，早高峰的广州地铁真是太恐怖了。</p><p>优营情况：效率很高，7.16中午出优营结果。</p><p>总结感悟：</p><p>前一天的机试没有太看，老师没有提起来，据说考太低可能会被问。感觉面试还是有点看背景，三位rk1的排位都很靠前，如果没有rk可能得项目非常好才能弥补。中山还是比较整体地去评判一个人的。提前联系导师似乎对于面试结果没有影响，不会因为老师关照就多打分。</p><p><img src="/Bao-Yan/baoyan-sysu-1.png" alt="到广州的晚上已经是23：05了，侥幸坐上了倒数第二趟车"></p><p><img src="/Bao-Yan/baoyan-sysu-2.png" alt="国立中山大学（这里是中山大学的北门）后来本专业来的10位同学在这里合照"></p><p><img src="/Bao-Yan/baoyan-sysu-3.png" alt="这一层是计算机学院的同学所在的地方，也是我之后去中山的同学的工位所在地"></p><p><img src="/Bao-Yan/baoyan-sysu-4.png" alt="SYSU的计算机学院"></p><p><img src="/Bao-Yan/baoyan-sysu-5.png" alt="I love SYSU！ 食堂太好吃了"></p><p><img src="/Bao-Yan/baoyan-sysu-6.png" alt="似乎是椰子树？好大的校园！"></p><p><img src="/Bao-Yan/baoyan-sysu-7.png" alt="我们机考的地方"></p><p><img src="/Bao-Yan/baoyan-sysu-8.png" alt="中山大学！"></p><p><img src="/Bao-Yan/baoyan-sysu-9.png" alt="中山大学宽敞的地下通道，连接生活区与学习区（这个时候就要看看本校建了好久但还没好的地道了）"></p><p><img src="/Bao-Yan/baoyan-sysu-10.png" alt="真的感觉景致很美很美"></p><p><img src="/Bao-Yan/baoyan-sysu-11.png" alt="有一种漫画里的感觉，云真的很低很低！"></p><p><img src="/Bao-Yan/baoyan-sysu-12.png" alt="中山的餐票补助，真够爽吃！体验感非常好！"></p><h3 id="8-26-国防科大计院"><a href="#8-26-国防科大计院" class="headerlink" title="8.26 国防科大计院"></a>8.26 国防科大计院</h3><p>时间线：</p><ul><li>8.26 晚上坐地铁到世界之窗旁边报到</li><li>8.27 清早合影，然后一天的学术讲座</li><li>8.28 早上体检，下午参观</li><li>8.29 早上面试，下午心理测试</li><li>8.30 离开，坐地铁回</li><li>9.4 出结果</li></ul><p>面试：</p><p>【这个我好像也签过保密协议，所以有些不能细说】</p><p>面试分为综合面试和政治考核。</p><ul><li>英文自我介绍：抽英文问题，5选1。老师读的不是很清楚，好像是问将来一段时间你觉得哪个计算机领域会发展比较好，好像是这样。我说多模态和大语言模型会比较好，因为数据很多，要用这些数据来做预测或任务。</li><li>中文自我介绍：</li><li>项目问题：<ul><li>有没有去申请专利或者有论文的产出。</li><li>在预训练过程中如何解决灾难性遗忘问题。（没答上来，老师换问在预训练阶段你做了什么，我说使用全参微调）</li></ul></li><li>其他还面试了哪些学校，如何做选择？那你有没有联系的导师？其他学校有没有联系的导师？（感觉很在意我是不是鸽子）</li><li>老师没有我们的个人信息，没有简历（不知道能不能自己准备简历递上去，我没带简历），所以所有都只能依靠自己说出来，对于工作的表述是一个很严峻的挑战。提问很随性，很符合我对于推免面试的想象。</li></ul><p>政治考核：</p><ul><li>与党有关的知识（不便细说）</li><li>一分钟介绍家庭情况。</li><li>有什么特长，不能是爱好。</li></ul><p>评价：</p><p>全程包吃包住，但是体检要自己花钱，报销路费（这个没用上）。主要还是锻炼了自己，用来刷经验的。从一开始就没打算来。但是确实发现了自己项目中的不足部分，后来回去重新复习了一下。</p><p>最终位次：排名170&#x2F;467（夏令营1+夏令营2）</p><p>由于国防科大很多地方都涉密，所以没有拍照片。只是拍了一些公开的部分。</p><p><img src="/Bao-Yan/baoyan-nudt-1.png" alt="国防科大夏令营"></p><p><img src="/Bao-Yan/baoyan-nudt-2.png" alt="每餐饭都是自助餐，真的爽吃了好多，都变胖了"></p><p><img src="/Bao-Yan/baoyan-nudt-3.png" alt="国防科大的入营礼包，很有夏令营的感觉"></p><p><img src="/Bao-Yan/baoyan-nudt-4.png" alt="和本校同学合住的酒店"></p><p><img src="/Bao-Yan/baoyan-nudt-5.png" alt="体检真的好贵啊"></p><p><img src="/Bao-Yan/baoyan-nudt-6.png" alt="国防科大的图书馆！"></p><p><img src="/Bao-Yan/baoyan-nudt-7.png" alt="图书馆外景"></p><h3 id="夏令营总结与回顾"><a href="#夏令营总结与回顾" class="headerlink" title="夏令营总结与回顾"></a>夏令营总结与回顾</h3><ul><li>不够自信，清计院没有去尝试。</li><li>非核心rk1夏令营还是比较受限的，复旦（核心rk1入营）、sjtu-ai（核心rk1入营，我以为bar很高，真的bar很高）。</li><li>信息差：ustc-6系没入：计科投递ustc-6系属于跨专业，这个关键信息没有把握住。</li><li>408：没有复习好，南大计院机试直接寄，同济也受到了影响。</li><li>机试：没有复习好，上交的机试得分太低，但凡第二题能Ac出来，结果会很大不同。</li><li>预推免还是要更加敢想敢为一些</li></ul><h2 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h2><p>预期目标：计划报复旦计院、浙大工院、南大计院、尝试清北，尽量捞一个学硕或者专硕的稳offer，目标为华五的硕offer。</p><h3 id="9-13-南大计院"><a href="#9-13-南大计院" class="headerlink" title="9.13 南大计院"></a>9.13 南大计院</h3><p>预推免的难度明显比夏令营难度下调了，很多都是基础的408知识。</p><p>时间线：</p><ul><li>9.8 线上机考</li><li>9.9 出了机考结果，获得了线下资格。</li><li>9.12 下午坐动车出发前往南京南，晚上住在南大仙林南门不远处。</li><li>9.13 上午面试，下午2点到4点机考。9.13晚就睡了4个小时。</li><li>9.14 早上7：30高铁回长沙。约11点高铁上收到邮件，候补。打电话问，在预推免waitlist前20，午后打电话确认在前15。老师说有机会能补上。预计25日将夏令营和预推免waitlist合并，按权重考虑，算法没说。据说也有机考280的wl，也有280的学硕，也有210的专硕。</li><li>同学wl前10在9.26下午候补到专硕</li><li>我wl10-15在9.27早上候补到专硕</li><li>929当天南大cs几乎被鸽穿，据说夏令营的wl120-130都能补到专硕，离谱啊离谱，南大你养了一大群鸽子。</li></ul><p>线下情况</p><p>直硕7组，直博1组。每组大约15人，有人没来，大约硕士可能不到100人这个样子。看了一眼本组的生源，有几个南大的，也有一些211的，包括苏州大学的等，排名也有差异，不都是第一这种，也有很多前十的。总体来说感觉还是放松了很多。</p><p>面试</p><p>【重要情报】明年想推免去南大的同学们注意哈，南大开始往科研上靠了，不再单纯依赖408，今年预推免的时候教务老师跟我们说了，明年的考核项会新增一项“科研素养”，直接计入分数。同时结合今年面试经验来看，确实有同学全程都是科研项目，很少408的内容。</p><p>小会议室，3个老师，全程录音录像。中间的老师比较年轻，两边的老师有点老。双盲，老师不知道我的名字和任何信息，只知道我的编号。</p><p>【注意：我的面试不是典型的南大408拷打面试内容】</p><p>【由于不是常规的408拷打，这个应该算老师的即兴提问，分享该部分经验应该没有违反保密规则】</p><p>【南大一般纯靠打专业课，但是到我这里，由于我自己的引导，老师开始对我的项目感兴趣，然后全程在听我的项目，难绷】</p><p>【暂时隐藏】</p><p>感觉随机性很大，每个组的情况都不尽相同。</p><p>我是属于一开始老师问的第一个问题时，我就把话题转到了我的项目上，然后老师对我的项目也比较感兴趣，就顺着往下问了，所以全程没有拷打专业课。从这里可以看出来，有的时候还是要稍微机灵一点，把话题往自己的项目上去引导，往自己熟悉的地方去引导，会有更好的结果。全过程我应该还是比较自信的，但是缺点是说话的时候没看着老师的眼睛。</p><p>总体应该不是压力面，同学出来都感觉跟老师聊的挺不错的。希望我能有个比较好的结果。</p><p>机考</p><p>3道题，最终得分20+100+75&#x3D;195，英文题面</p><p>【我签了保密协议，这里的机考题不能透露出来，只能稍微描述，如果确实想进一步了解，可以进一步探讨】</p><p>第1题：多维矩阵乘法</p><ul><li>高维矩阵相乘</li><li>一上来就这道题，没有任何思路，看了15分钟之后跳过了，最后解决了一个数据点，拿了20分。</li></ul><p>第2题：base32编码（简单模拟题，大家基本都做出来了）</p><ul><li>【暂时隐藏】</li></ul><p>第3题：string golf（数据比较水，纯暴力有75分）</p><ul><li>给了很多定义：</li><li>【我就把这里略去了，不讲，有需要的同学自己找到我吧】</li><li>给定support集和reject集，问同时满足的长度最长的字符串是什么，保证答案唯一，即不会出现长度相同但多个满足题意的情况。</li><li>数据规模：每个set里个数＜20，每个字符串长度＜200，（很友好的数据，故一上来就想到用暴力求解）</li><li>数据子任务：30%数据保证没有通配符.和+（实际上我完全没做这里的处理也过了75%）</li></ul><p>评价：英文题面虽然没有带来太多的理解难度，但是一上来看到的时候心理压力还是非常大。第一道题15分钟没有任何思路真的很难受。但是发现第二道题很简单之后迅速花了大概40分钟敲出来（最近代码生疏了，边做边输出结果验证各个步骤，所以慢了），但是compile error了一次，改了一下交了就拿到了第一个100分，心情大定。然后做第3题，本来打算敲个暴力拿到30分，但是花了30分钟敲出来之后，意料之外骗到了75分，心情又好起来了。最后大概剩下半个小时，第一题想拿点突破但是没有结果，最后我想到可以用dfs来模拟每个维度的不同数值做累加，但是时间已经来不及了，最终没有做出结果来。所以感觉还是有很多的遗憾，因为我知道这次简单，大家应该都能做的比较好，所以我不一定具备优势了。</p><p>下面是南大行程中的一些图片。</p><p><img src="/Bao-Yan/baoyan-nju-3.png" alt="前一天晚上到达南大时拍的南大外景，这是我第二次在这个角度看，上一次是高考前"></p><p><img src="/Bao-Yan/baoyan-nju-9.png" alt="I love NJU ！"></p><p><img src="/Bao-Yan/baoyan-nju-2.png" alt="计算机学院院楼，参加面试的地方"></p><p><img src="/Bao-Yan/baoyan-nju-4.png" alt="这里是参加机考的地方"></p><p><img src="/Bao-Yan/baoyan-nju-7.png" alt="你好，NJU！"></p><p><img src="/Bao-Yan/baoyan-nju-10.png" alt="我最爱的NJU！"></p><p><img src="/Bao-Yan/baoyan-nju-1.png" alt="机考在NJU在线OJ系统上进行，能实时给出反馈"></p><p><img src="/Bao-Yan/baoyan-nju-5.png" alt="和初中相识的同学登上NJU的后山，不得不惊叹NJU的景色是真的很美很美"></p><p><img src="/Bao-Yan/baoyan-nju-6.png" alt="NJU的食堂，可惜没吃上这里的午饭"></p><p><img src="/Bao-Yan/baoyan-nju-8.png" alt="晚上上一届来到NJU的学长请我和同学吃了一餐晚饭，这个食堂真的太好吃了"></p><h3 id="9-17-清华软院"><a href="#9-17-清华软院" class="headerlink" title="9.17 清华软院"></a>9.17 清华软院</h3><p>时间线：</p><ul><li>9.5 收到通知，获得线下综合考核资格并告知了考核时间与方法</li><li>9.12 收到通知，未能通过清深初筛</li><li>9.16 坐飞机从长沙出发，前往北京</li><li>9.17 早上资格审查，下午2点到6点机考</li><li>9.18 早上面试，晚上坐过夜火车离开北京</li><li>9.18 晚上约8点，在地铁上收到了拟录取</li></ul><p>资格审查：</p><ul><li>需要进行人脸比对，要求跟上传的证件照相似度达到80%。建议一定拍个像一点的。到我的时候由于我证件照是大一时候的照片，这几年已经有点不像了。老师非常好心地帮我验证了好多次，每次都差一点，在78%左右。我不断地把自己往照片上拟合，挤出笑脸hhh。万幸最终验证通过了，如果验证不通过可能要写保证书。</li></ul><p>机试：</p><p>【我忘记自己有没有签保密协议了，题目就先不公开了】</p><p>早上有2小时的模拟机考，可以自己试试机房的环境，以及摸索系统。</p><p>OJ赛制，提交及时反馈，每题最多32次提交，取最高分。开卷，允许携带纸质资料。</p><p>环境：NOI虚拟机，网页OJ，本地有Vscode，无dev等集成环境。需要手动使用命令行g++编译并运行。</p><ul><li>第一题：阿瓦隆。题目难度约为CSP第1题至第2题难度。我考试开始后13分钟提交并拿满。</li><li>第二题：网络。我的解题思路：数据分层比较明显，只使用并查集优化的kruskal算法可以拿到33+19&#x3D;52分。是没办法过②④两点的。盲猜数据点连接之后应该全为联通图，所以②点直接输出ans&#x3D;n+m-1，就拿到了这27分，这个比较难想到，数据点也恰好很看运气。最后21分没有去尝试，直接放弃。此时考试过去一个半小时，已经拿到179分。</li><li>第三题：边双。我的解题思路：写了一个dfs的模拟，并把限制条件全部模拟出来，但是没法解决自环问题（成环之后会反复走这个环，没法出来，造成递归无法结束），最终这道题没有做出来，也没有拿全任何一个数据点的分数，使用有深度的递归（即到某个深度强制结束递归）的方法骗到5分，通过微调这个深度骗到10分，再改进无进展。时间耗尽，结束。后来在绿群听说直接输出所有权值加和（即默认所有节点都可访问一遍）可以得10分，不知道跟我这里的这10分是不是一样的，没再深究。第一个数据点有20分（规定n&lt;&#x3D;20）。</li></ul><p>评价：我的最终成绩为接近200分。结束之后绿群里看到大部分人为100+（33+19）&#x3D;152分，即第一题和第二题只使用并查集的kruskal算法。少部分人从第三题拿到了10分或20分。所以我估计中位水平在170分左右。同时这次有许多满分300分，我了解的就至少有4个以上。最后出结果的时候看到很多152分的就没有录取。</p><p>面试：</p><p>共4组，76个同学。基本上会把一个学校的同学拆到不同组去。每组连续面5个同学，老师休息一次。每个同学20分钟，全程严格计时，各部分也是严格计时。</p><p>先对着PPT讲自我介绍（5-7分钟）：会严格卡时间，这里一定要控制好时间。我在项目上花费了太多的时间，所以最后没讲完，老师让我快点往后过一遍。这个整体表现真的很不好，千万要注意。</p><p>然后老师对PPT里感兴趣的内容提问，问题很广泛，基本上像聊天面，聊到哪里就问什么，无迹可寻。</p><p>固定的几个问题：</p><ul><li>英文问题：感觉像是负责该问题的老师随机结合你的项目提问。</li><li>政治问题：你是党员吗？我回答我是预备党员。提问这个的老师被其他老师打断了，就没再继续问了。我还听见其他有问近期的时事的，时政的。感觉这个也是很随机。</li><li>专业课问题：看老师喜欢哪个学科，逮着猛猛薅。我这个老师很喜欢编译原理，于是问我编译原理。第一个问题我大概能理解，第二个问题我没有太理解，我就说我不太会。其他考场有被问到数据库的问题，一个考场估计就问一个科目。（大家答的都不太好，专业课确实太难绷了，很难复习）</li></ul><p>压力的部分：</p><ul><li>你这个项目有什么实际意义呢（我以为是项目太水了被穿了，后来发现几乎每个同学都被问到了）</li><li>请你用一句话表明你的项目怎么体现出你的科研能力（这句也是每个同学都被问到了）</li></ul><p>我这个场地的老师有点压力面，但是其他考场的老师据说很聊天面。</p><p>下面的图片按照时间顺序放吧</p><p><img src="/Bao-Yan/baoyan-thu-16.png" alt="前一天坐上飞往北京的飞机，那两天南边江浙一带有台风，所幸北边没有影响"></p><p><img src="/Bao-Yan/baoyan-thu-8.png" alt="靠在窗边，我看着下面的城市，顿时明白了“星罗棋布”是什么意思，如果让我换个比喻，我会觉得很像电路板，原来中国有这么多人"></p><p><img src="/Bao-Yan/baoyan-thu-9.png" alt="晚上住宿在“者行孙”，这个看着像“自闭小屋”，能深切体会到“北漂”的不易，即使是这个，住一晚都要120块钱，正常旅馆至少得要300块，真的太贵了"></p><p><img src="/Bao-Yan/baoyan-thu-1.png" alt="晚上陪同学去打印资料时经过了“知乎”的总部，很小的一栋，很惊讶与诧异，同时感慨果然是北京，平时只能在网上看到的东西都成为了现实"></p><p><img src="/Bao-Yan/baoyan-thu-5.png" alt="早上打车去参加资格审查的路上看到了“飞书”的总部，感慨与昨晚相似，但对自己今日的行程多了一份期待"></p><p><img src="/Bao-Yan/baoyan-thu-3.png" alt="终于到了清华的门口，最高学府给人的震撼是扑面而来、难以言喻的。现在大概还没到8点，所以人很少，但是保安很多而且很负责，每个人都要核验身份证才能进去，这又再一次增加了肃穆感"></p><p><img src="/Bao-Yan/baoyan-thu-12.png" alt="从门口进去，一路直行来到的是东主楼，右边就是软件学院了，这栋建筑给我一种很庄严的感觉。同时早上的晨光洒在身上，这个氛围感很绝妙，我真的很想留在这里"></p><p><img src="/Bao-Yan/baoyan-thu-14.png" alt="清华的二校门，弥补了暑假时没能进来参观打卡的遗憾，跟同学在这里拍了合照"></p><p><img src="/Bao-Yan/baoyan-thu-10.png" alt="软件学院的门口"></p><p><img src="/Bao-Yan/baoyan-thu-15.png" alt="清华大学软件学院！"></p><p><img src="/Bao-Yan/baoyan-thu-7.png" alt="晚些时候到另外一栋楼参观了传说中的“贵系”！"></p><p><img src="/Bao-Yan/baoyan-thu-13.png" alt="清华的校徽"></p><p><img src="/Bao-Yan/baoyan-thu-11.png" alt="路上随拍的长椅，我都不敢想在这里坐上一整天该有多轻松多惬意"></p><p><img src="/Bao-Yan/baoyan-thu-6.png" alt="面试结束后一起聚餐吃的川菜"></p><p><img src="/Bao-Yan/baoyan-thu-2.png" alt="去年来清华的学长请我吃的晚餐，果然是最高学府的食堂，真的太好吃了！"></p><p><img src="/Bao-Yan/baoyan-thu-17.png" alt="晚上在离开去火车站的地铁上收到了系统上发生变动的消息，心里很激动"></p><p><img src="/Bao-Yan/baoyan-thu-4.png" alt="火车经过武汉长江大桥，已经到次日清晨了，再次看到长江，内心感慨万千"></p><h3 id="9-21-浙大工院"><a href="#9-21-浙大工院" class="headerlink" title="9.21 浙大工院"></a>9.21 浙大工院</h3><p>时间线：</p><ul><li>9.16 正常入营公布，未能入营，打电话问教务，被告知未入营</li><li>9.18 清软面试结束后，中午吃饭时，被电话告知候补入营</li><li>9.20 从长沙出发返回杭州</li><li>9.21 早上前往拱墅面试，下午陪同学逛西湖</li><li>9.23 晚上钉钉拉一个拟录取群，告知处于wl-9（共录取30人）</li><li>9.27 晚 wl-6，前面3人放弃</li><li>9.28 没有填报，相当于放弃了录取资格</li><li>9.29 晚上回去翻了钉钉群，至少鸽了15个，我应该能补到的。算了，有清软了，就不去浙大了。</li></ul><p>面试：</p><p>英语自我介绍，然后讲自己的PPT，之后考官提问，会抽一个专业问题。</p><p>主要是在对我着重提及的项目提问，我还是比较能应对自如的。</p><p>专业问题：抽到的是程序设计的，好像是继承的时候，如果父类函数加virtual但是子类函数不加virtual，能不能实现多态。当时脑抽，说不能实现。被老师质疑有没有学过程序设计。后来反应过来是能实现，有点尴尬。</p><p>政治问题 ：对待法轮功的态度，坚决反对。</p><p>下午陪同学逛了逛西湖。</p><p><img src="/Bao-Yan/baoyan-zju-1.png" alt="果然浙大能代表浙江"></p><p><img src="/Bao-Yan/baoyan-zju-2.png" alt="工程师学院的入口"></p><p><img src="/Bao-Yan/baoyan-zju-3.png" alt="浙大工程师学院的引导做的非常好，省去了我找路的时间"></p><p><img src="/Bao-Yan/baoyan-zju-5.png" alt="还受到了标语的欢迎，受宠若惊"></p><p><img src="/Bao-Yan/baoyan-zju-4.png" alt="西湖的三潭印月，我还是第一次见到hhh"></p><h3 id="9-22-湖大信院"><a href="#9-22-湖大信院" class="headerlink" title="9.22 湖大信院"></a>9.22 湖大信院</h3><p>时间线：</p><ul><li>9.19 晚上邮件告知入营</li><li>9.21 晚上邮件告知面试分组</li><li>9.22 早上开始面试，排在第19位，下午1点面到。</li><li>9.26 下午出结果，有个稳保底了。</li></ul><p>面试：</p><p>不知道为什么今年面试在线上进行，很奇怪。但我也因此有机会参与。</p><p>先进候考室待着，到我面试的时候直接老师的摄像头就开了，一个房间大概五六个老师。</p><p>比较不好的体验主要有几点：（1）没有人提前告知你现在面试到第几个了，全程在等待，也不知道什么时候开始面试。（2）线上面试很难听清楚老师在说什么，那边感觉回音很重。</p><ul><li>先做自我英文介绍。</li><li>然后老师问我本科阶段有没有做过的科研和项目。我说我有PPT，老师说就简单回答一下就可以。我就简单回答了，然后稍微描述了一下细节。</li><li>老师对我做CSDN博主感兴趣，问我感兴趣的论文是什么。我说ICML的一篇论文，然后稍微讲了一下原理。</li><li>老师问我跟的哪个本校老师。</li><li>老师问我还有什么其他的offer，我说了拿到的几个。</li><li>老师最感兴趣的还是为什么我要来预推免，感觉是明牌鸽子。我老实说了想拿个本校的保障。</li><li>老师问我还有什么想问的，我说暂时没有了。</li></ul><p>全程就6分钟左右，就结束了。感觉老师知道我不会来了，就有点聊天的意思。我的最后一场预推免面试就这样结束了。</p><h2 id="929当天"><a href="#929当天" class="headerlink" title="929当天"></a>929当天</h2><p>手上已经把其他学校都释放完了，留了一个强com的南大作为保底以防特殊情况，一个清华其实也是铁offer，还剩下一个空置防止特殊情况（我还是比较求稳的）。填写了一个清华，一个南大。</p><p>根据往年的经验，清华会比较晚发，去年中午12点开系统的话是下午6点才发待录取。今年早上9点开系统，下午2点发的待录取，时间上提前了一个小时。一般如果等清华会错过其他绝大部分学校的待录取，故我的心里其实也是很慌的。</p><p>早上10点左右，南大和清华都发了复试通知。</p><p><img src="/Bao-Yan/baoyan-2.png" alt="接受了南大和清华的复试通知"></p><p>11：30，南大打电话给我妈（我写的座机电话），问到底点不点，不点就要撤回了。很巧的是我在一分钟前刚刚点了拒绝键，因为显然不可能一直等下去。最终拒绝了南大，把这个机会让给有缘人。</p><p><img src="/Bao-Yan/baoyan-3.png" alt="拒绝了南大的待录取"></p><p>清华向来发的比较晚，最终在下午13：56的时候发了拟录取，点击接收，保研就结束了。</p><p><img src="/Bao-Yan/baoyan-4.png" alt="接受了清华的录取，拒绝了南大录取"></p><p>这应该就是尘埃落定了吧，其实真的到了928，内心的激动已经荡然无存了，就好像喜欢了一个人很久，最后终于把结婚证办了，大概这种感觉？当然这也是一个没经历过的事情。我只想好好的睡一觉。</p><p>今年929更是保研春晚，许许多多的学校被鸽穿，很多看似遥不可及的学校一下子就随地可捡，许许多多的闹剧和喜剧同步上演，真就是保研人独属的春晚。不论这三个月你有多劳累，笑一笑感觉又能好起来。</p><p>绿群广播的鸽穿情报（实际上差点穿的学校更多，已经穿的学校也不止这些）：</p><blockquote><p>根据群u情报，目前鸽穿的（有误的和待增加的都可以说一下）seu cs&#x2F;网安&#x2F;蒙纳士，ustc-先研&#x2F;自动化，浙计专-机器人，北理珠，sysu-cs&#x2F;se，sdu-cs&#x2F;se，hust-cs，sjtu-ai，buaa-类脑，hitwh-cs，nudt-cs，bit-cs，ruc-苏州</p></blockquote><p>有的学校被鸽穿了就老实了。</p><p><img src="/Bao-Yan/baoyan-7.png" alt="图片来源于绿群"></p><p>有的学校下午3点还在招人（穿透了）</p><p><img src="/Bao-Yan/baoyan-11.png" alt="图片来源于绿群"></p><p>绿群的群友们在一起听歌，从《鸽子》到《好运来》，几十个人一起听了一晚上的歌，还在听，难绷。</p><p><img src="/Bao-Yan/baoyan-6.png" alt="绿群群友在听歌"></p><p><img src="/Bao-Yan/baoyan-5.png" alt="绿群群友在听歌"></p><p>绿群聊了好久的主人公迎来了结局，《东五》也是后继有人了。（应该是html前端改的字，太难绷了）</p><p><img src="/Bao-Yan/baoyan-8.png" alt="图片来源于绿群，若造成不好影响，请联系我删除，很抱歉给您带来不好的影响"></p><p>小红书上更有人整活，把这个做成一盒药。只能说是很好的反应了保研人这一路上几经崩溃的经历，最后的待录取药到病除的神奇疗效。</p><p><img src="/Bao-Yan/baoyan-9.png" alt="图片来源于小红书，若侵权请联系我删除"></p><p><img src="/Bao-Yan/baoyan-10.png" alt="图片来源于小红书，若侵权请联系我删除"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>还没准备就已开始，还没有感触就已结束。</p><p>我保研的结束，实际上在19号晚接受清软offer时。那一刻，我在北京的地铁上，匆匆转三条地铁线路赶往北京西站，然后坐过夜的火车回长沙。此前在曾住过的酒店澡堂洗了澡，因此头发还湿湿的。深夜约是九点，地铁上已经没有太多的人了，估计也是下班的苦命人。微信企业邮箱收到了一条邮件，点开发现是清华系统提示状态有变化。内心有一阵激动，但结合之前面试的情况，我觉得还是不太可能。抱着想让自己死心的想法，同时还有一种迫切期待得到结果的冲动，我从背包里掏出电脑，连上手机热点，然后点开系统，然后发现了是否确认“初步录取”。这一刻，我心里其实没有太大的波澜。这三个月以来，我经历过绝望，经历过纠结，经历过各种各样状况百出的局面，心里已经麻木了。大有种看开想开的感觉。我其实没有那种三年努力终于得到回报的那种爽感与快感，更多的是一种水到渠成、自然而然的宿命感。我感觉自己是被命运推着来到了这个结局，但如果命运途中发生了一点微小的改变呢，也许会有很不同的结果。但我还是很庆幸，能以这个作为结束，是我最喜欢的硕士offer，虽然是我不敢想的学校。我用手机给妈妈打了一个电话，告知她我不用继续往下走了，因为清华能录上。电话那头先是一阵沉默，然后是哽咽，母亲需要时间消化这个消息。</p><p>诚然，这几个月以来我过的实在不容易。而作为应该是我保研征途中最难的这一场，我居然没有时间做太多准备。除了在南大的机考，我近期并没有练过机试；同样，除了国防科大和南大这两场，距离夏令营的5场面试也过去了很久，我的面试状态已经有了很下滑的趋势，实际上我面试状态的顶峰应该在中山那时。我的精力都用在了别的事情上。因此，除了宿命，我想不出别的理由来解释这个结果。不过好在是以这里结束，这是我能接受的结局，也是我能走出最好的结局。万幸的是，这唯一的机会，被我死死地抓住了。曾有朋友对我说，你要一而再再而三地救自己于水火之中，因为能拯救你自己的，只有你自己，没有别人。我真的很感谢这份幸运，以及之前为这份幸运做出的一切努力。</p><p>保研的目标，是在大一就定下的。高考时我历次模考基本有南大的水准，物理爆冷最后来了本科的学校。之前听说同专业有高中母校来本科母校最后去上交直博的事例，我一直摆在心中当做追随的目标。而清华的title可以完美覆盖上交的title，同时读硕也是我既定的路线。因此这个结局是唯一破局的方法，也是我唯一能接受的结局。我很幸运地得到了它。</p><p>回望这三个月，从6月末离开长沙前往同济这第一个夏令营开始，到9月末本校的最后一个线上营结束，正好十个营，这是否正好对应着十全十美呢，我不知道。我所记得的是，夏令营时七月上半旬的旅行：坐飞机从成都凌晨抵达北京，上交面试完赶着公交到机场坐飞机飞向广州，然后再赶着倒数第二班地铁前往广州体育西路，此时已经过零点，没有地铁了，只能打车前往中山大学附近……这是一个人的旅程，是自己给自己的修行。但是在旅程中，总有可爱的同学陪伴。很巧的是，凡是住宿，都是本校的同学，这给了我安全感……</p><p>之前的经验贴说，保研的过程，也可以领略不同城市的风景。诚然如此，但是我终究是没有心情游玩的。我只是对不同城市有了更加形象的认识。我见识过北京郊区晚上的静谧，北京地铁海淀黄庄站的人流匆匆，广州不眠的夜晚与灯光，成都雨后的夜晚，上海随处可见的繁华，杭州如画美丽的西湖，长沙回程的路在去漫展时走过……有的城市我是第一次前往，有的城市我曾经去过，还有的城市我已经待了很久了……</p><p>我很喜欢上海，曾把复旦专硕作为自己锚定的结局。但是复旦终究与我无缘，两次拒绝我入营。我喜欢上海交大，因为这是米哈游发源的地方，同样也是我高考时想都不敢想的学校，但终究硕士不够格、直博不想读。我喜欢同济大学，同济大学也是我高考时高攀不起的学校，但拿到了优营之后，又有了其他的想法，最终放弃。最后想起来，也许我与上海在这一阶段，暂时无缘了，希望以后在工作的时候能有缘分吧。</p><p>A橙学长曾经说过，“保研，是一个不断认清自己的过程”。诚哉斯言。我从最初觉得同济就是很好的去处，到拿到南大的硕，再到拿到清华的硕。每一步的前进，都是我从不敢想象的，都是我从没有料到的，都是突破自身认知极限的。我不是一个很有自信的人，因此总是按照下限去定目标，在一次次得到了正面的反馈后，我才意识到，哦，原来我能够到这么远。诚然，保研也是一个探究自己极限的过程。有些事情，不去试，永远不知道自己能不能成；有些路，不去走，永远不知道自己能走多远；有些机会，不去拿，永远不知道自己能不能拿到。因此，只有不断尝试，不断探求自己能力的极限，才会不后悔，才会“尽吾志也而不能至者，可以无悔矣”。这一点我要感谢我的母亲，是她鼓励我去尝试所有可能的路径，我在清华机考前，自我怀疑过，“我都不知道我来这里干什么”，是我母亲一直坚持认为我要尝试所有可以尝试的机会，不留下后悔。</p><p>真的到了最后的最后的时候，确定了自己的去向之后，我开始关注身边的朋友们：隔壁专业的第一，在928早上候补到了复旦热门方向的学硕；隔壁另一个专业的第一，在927早上得到了复旦预推免的专硕；一起面试浙大的本校同学决定放弃浙大候补去本校的直博；一起去南大预推免的本校同学最终候补到了南大，我也最终候补到了南大……这一切的一切好似我追的番剧最终有了圆满的结局，又像失落的拼图一块一块都拼了起来。大家都有了自己满意的去处，有点像童话里的美好大结局。</p><p>保研是一个很漫长的过程，真正的战争从大一就开始了。这三个月（7、8、9）的夏令营和预推免，只是检验三年成果的一个契机。友情、亲情、师生情、运气、能力、机遇、奇遇、状态、临场发挥、身体健康……每一个因素都可能被放大为决定因素，每一个因素都在每个维度影响着最终的结果。保研是一个巨大的不定方程，你不可能将所有变量纳入考虑，比你能力强的某一个同学采取了什么样的填报策略，又发挥如何，题目是不是合他的胃口，是不是合你的胃口，wl前面的同学是不是因为有了更好的去处而放弃了offer给我让出了位置……这样的变量多到无法想象。我能做的，只有尽量把自己可以影响甚至决定的因素做到最好，然后静待结果。有时候，会发现即使我能做的全部拉到最好，我能干预的仍然是有限的。这个时候，能做事的，就只有命运的回响了。</p><p>至此，我们的故事结束了，而从今以后，就是你的故事了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note-DBS</title>
      <link href="/2024/04/27/Note-DBS/"/>
      <url>/2024/04/27/Note-DBS/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库系统-笔记"><a href="#数据库系统-笔记" class="headerlink" title="数据库系统-笔记"></a>数据库系统-笔记</h1><p>计科210X 甘晴void 202108010XXX</p><p>教材：《数据库系统概论》第6版</p><img src="/note-dbs/Note-DBS.png" class="" title="数据库系统笔记"><p>（图片来源于网络，侵删)</p><p><strong>【关于版权&#x2F;保密问题的说明】<br>有关课程教案（涉及人大数据库&#x2F;清华数据库的部分以及湖南大学数据库课题组）的课件部分，出于版权原因（仅用于校内教学），我已经全部删除，并对之前造成的影响道歉。现在的笔记中不包含所有可能造成版权纠纷以及湖南大学课题组的课件部分。即，笔记中的所有内容为《数据库系统原理》书本上可找到的内容，与我自己的想法的并集，不存在原样直接上传教案的情况。若有其它问题，欢迎相关监管方面在通知群里再戳我，我一定及时修改(qwq)，再次为之前未经允许上传PPT向老师致歉。</strong></p><p>[TOC]</p><h1 id="第一篇-基础篇"><a href="#第一篇-基础篇" class="headerlink" title="第一篇 基础篇"></a>第一篇 基础篇</h1><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h2><h3 id="1-1数据库系统概述"><a href="#1-1数据库系统概述" class="headerlink" title="1.1数据库系统概述"></a>1.1数据库系统概述</h3><p>基本概念：</p><ul><li><p>数据：<strong>描述事物的符号记录</strong>称为数据。数据的含义称为数据的语义，数据与其语义是不可分的。</p></li><li><p>数据库（DB）：<strong>长期存储在计算机内、有组织的、可共享的大量数据的集合</strong>。数据库中的数据按一定的数据模型组织、描述和存储，具有<strong>较小的冗余度</strong>、<strong>较高的数据独立性和易扩展性</strong>，<strong>并可为各种用户共享</strong>。</p></li><li><p>数据库管理系统（DBMS）：数据库管理软件，<strong>计算机的基础软件</strong></p><p>数据定义功能<br>数据组织、存储和管理<br>数据操纵功能<br>数据库的事务管理和运行管理<br>数据库的建立和维护功能<br>其他功能</p></li><li><p>数据库系统（DBS）：由DB,DBMS及其应用开发工具，应用系统和DBA组成的<strong>存储、管理、处理和维护数据的系统</strong></p></li><li><p>DBA数据库管理员</p></li></ul><p>数据库管理技术的产生和发展：</p><p>人工管理阶段 -&gt; 文件系统阶段 -&gt; 数据库系统阶段</p><p>数据库系统阶段的4个优点</p><ul><li>整体数据的<strong>结构化</strong>(与文件系统的本质区别)</li><li>数据的<strong>共享性</strong>强、冗余度低且易于扩充</li><li>数据的<strong>独立性</strong>强（物理独立性，逻辑独立性）</li><li>数据<strong>由数据库管理系统统一管理和控制</strong></li></ul><p>另外还需要提供的功能：</p><ul><li>数据的安全性保护：防止不合法使用造成的数据泄密和破坏。</li><li>数据的完整性检查：控制数据的正确性，有效性和相容性。</li><li>并发控制</li><li>数据库恢复</li></ul><h3 id="1-2数据模型"><a href="#1-2数据模型" class="headerlink" title="1.2数据模型"></a>1.2数据模型</h3><p>数据模型：数据库系统的核心和基础。</p><p>数据建模：把现实世界中的具体事物抽象、组织为某一数据库管理系统支持的数据模型。</p><p>概念模型（现实世界抽象为信息世界） -&gt; 数据模型（信息世界转换为机器世界）</p><p>概念模型：</p><ul><li>实体：客观存在并可相互区别的实物称为实体。</li><li>属性：实体所具有的某一特性。</li><li>码(key)：唯一标识实体的属性集称为码。</li><li>实体型：用实体名和属性名集合来抽象和刻画同类实体。例如：学生(学号，姓名，性别，院系)。</li><li>实体集：同一类型实体的集合称为实体集。</li><li>联系：实体之间的联系通常是指不同实体集之间的联系。有一对一，一对多和多对多等多种类型。</li></ul><p>概念模型的表示方法：实体-联系模型（E-R模型）</p><p>数据模型三要素：</p><ul><li>数据结构：描述数据库的组成对象以及对象之间的联系。</li><li>数据操作：对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</li><li>完整性约束：一组完整性规则。</li></ul><p>层次模型：</p><ul><li>数据库中满足下面两个条件的基本层次联系的集合为层次模型：<ul><li>有且只有一个结点没有双亲结点，称为根结点。</li><li>根以外的其他结点只有一个双亲结点。</li></ul></li><li>【注意：层次模型是一种一对多的联系】</li><li>数据操纵主要为查询，插入，删除，更新。操作要满足层次模型的完整性约束条件。</li><li>层次模型的优点：<ul><li><strong>数据结构简单清晰</strong>。</li><li><strong>查询效率高</strong>(因为联系用有向边表示)。</li><li>提供了良好的<strong>完整性支持</strong>。</li></ul></li><li>【未标着重】层次模型的缺点：<ul><li>现实中很多联系是非层次性的。</li><li>一个结点有多个双亲结点，就只能引入冗余数据，应用程序编写复杂。</li><li>查询子女结点必须通过双亲结点。</li><li>结构严密，层次命令趋于程序化。</li></ul></li></ul><p>网状模型：</p><ul><li>数据库中满足下面两个条件的基本层次联系的集合为网状模型：<ul><li>允许一个以上的结点无双亲。</li><li>一个结点可以有多于一个的双亲。</li></ul></li><li>【注意：层次模型是一种多对多的联系】</li><li>具体的网状数据库系统对数据操纵都加了一些限制，提供了一定的完整性约束。</li><li>网状模型的优点：<ul><li>能够<strong>更为直接的描述现实世界</strong>。</li><li>具有良好的性能，<strong>存储效率较高</strong>。</li></ul></li><li>【未标着重】网状模型的缺点：<ul><li>结构比较复杂，不利于最终用户掌握。</li><li>DDL，DML复杂，并且要嵌入一种高级语言中，不容易掌握和使用。</li><li>记录之间的联系通过存取路径实现，访问数据时必须选择适当的存取路径，用户必须了解系统结构的细节。</li></ul></li></ul><p>关系模型：</p><ul><li>关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项。</li><li>关系模型的优点：<ul><li>建立在严格的<strong>数学概念基础</strong>上。</li><li><strong>概念单一</strong>，</li><li><strong>关系模型存取路径对用户隐蔽</strong>：有更高的数据独立性，更好的安全保密性。（★因此查询需优化）</li></ul></li></ul><h3 id="1-3数据库系统的结构-三级模式结构"><a href="#1-3数据库系统的结构-三级模式结构" class="headerlink" title="1.3数据库系统的结构(三级模式结构)"></a>1.3数据库系统的结构(三级模式结构)</h3><ul><li>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述。数据库管理系统提供模式数据定义语言(DDL)来严格定义模式。</li><li>模式反映的是数据结构及其联系，而实例反映的是数据库某一时刻的状态。</li><li>三级模式结构：<ul><li>模式：是<strong>所有用户的公共数据视图</strong>。</li><li>外模式：<strong>数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述</strong>，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li><li>内模式：<strong>数据物理结构和存储方式的描述，是数据在数据库内部的组织方式</strong>。</li></ul></li><li>为了实现以上三个抽象层次的联系和转换，数据库管理系统在三级模式之间提供了两层映像：外模式&#x2F;模式映像和模式&#x2F;内模式映像。<ul><li>外模式&#x2F;模式映像：定义了外模式与模式之间的对应关系。</li><li>模式&#x2F;内模式映像：定义了数据全局逻辑结构和存储结构之间的关系。</li></ul></li><li>数据库模式即全局逻辑结构是数据库的中心与关键，独立于数据库的其他层次。（设计数据库模式结构时应<strong>首先确定</strong>）</li><li>当模式改变时，修改映像使外模式不变，这保证了数据与程序的<strong>逻辑独立性</strong>。</li><li>当存储结构(内模式)改变时，修改映像使模式保持不变，这保证了数据与程序的<strong>物理独立性</strong>。</li></ul><h3 id="1-4数据库系统的组成"><a href="#1-4数据库系统的组成" class="headerlink" title="1.4数据库系统的组成"></a>1.4数据库系统的组成</h3><ul><li>硬件平台及数据库</li><li>软件</li><li>人员</li></ul><p>人员包括</p><ul><li>数据库管理员：5个职责（书P32）</li><li>系统分析员和数据库设计人员</li><li>应用程序员：编程</li><li>最终用户</li></ul><h3 id="1-5总结"><a href="#1-5总结" class="headerlink" title="1.5总结"></a>1.5总结</h3><p>4个基本概念</p><p>数据模型3要素</p><p>三级模式与两级映射保证逻辑独立性与物理独立性</p><p>数据库系统三级模式结构的优点</p><p>为什么具有数据和结构的独立性</p><h2 id="2-关系数据库"><a href="#2-关系数据库" class="headerlink" title="2 关系数据库"></a>2 关系数据库</h2><h3 id="2-1关系"><a href="#2-1关系" class="headerlink" title="2.1关系"></a>2.1关系</h3><h4 id="2-1-1关系"><a href="#2-1-1关系" class="headerlink" title="2.1.1关系"></a>2.1.1关系</h4><p>域：域</p><p>笛卡尔积：笛卡尔积（域的运算）、元组、n元组、分量（元组中的每一个值）、基数 （一个域允许的不同取值个数）</p><p>关系：</p><ul><li><p>关系（一些域的笛卡尔积的子集即为这些域的关系，抽取有意义的子集），记作R(……)、</p></li><li><p>关系的目&#x2F;度n（运算的笛卡尔积的个数，即关系表的特征列个数）、</p></li><li><p>属性（n目关系必有n个属性）、</p></li></ul><p>三类关系</p><p>基本关系（基本表&#x2F;基表）【实际存在】有6条性质（列同质、不同元组码不能相同、不同列可出自同一域、列可换顺序、行可换顺序、分量取原子值，即不能表中有表）</p><p>查询表【针对查询结果的临时表，实际存在】</p><p>视图表【虚表】</p><h4 id="2-1-2关系模式"><a href="#2-1-2关系模式" class="headerlink" title="2.1.2关系模式"></a>2.1.2关系模式</h4><p>R(A1,A2,A3,)</p><ul><li>候选码、主码、全码、主属性、非主属性（非码属性）</li></ul><p>关系数据库：关系数据库模式：关系数据库的“型”</p><p>关系模型的存储结构：RDBMS</p><h3 id="2-2关系操作"><a href="#2-2关系操作" class="headerlink" title="2.2关系操作"></a>2.2关系操作</h3><h4 id="2-2-1基本的关系操作"><a href="#2-2-1基本的关系操作" class="headerlink" title="2.2.1基本的关系操作"></a>2.2.1基本的关系操作</h4><ul><li>查询操作</li><li>数据更新操作</li></ul><h4 id="2-2-2关系数据语言的分类"><a href="#2-2-2关系数据语言的分类" class="headerlink" title="2.2.2关系数据语言的分类"></a>2.2.2关系数据语言的分类</h4><ul><li>关系代数语言</li><li>关系演算语言（不要求）</li><li>结构化查询语言（Structured Query Language, SQL）</li></ul><p>关系完备性：一个关系数据语言能够表示关系代数可以表示的查询</p><h3 id="2-3关系完整性"><a href="#2-3关系完整性" class="headerlink" title="2.3关系完整性"></a>2.3关系完整性</h3><p>包括</p><ul><li>实体完整性（主属性不取空值不得重复）</li><li>参照完整性（注意外码的定义：不是参照关系的码但是被参照关系的主码）（外码可以取空值或被参考关系中已经存在的值）</li><li>用户定义的完整性（用户可以自己定义：唯一约束、主键约束、自增长约束、默认值约束、检查约束）</li></ul><h3 id="★2-4关系代数"><a href="#★2-4关系代数" class="headerlink" title="★2.4关系代数"></a>★2.4关系代数</h3><h4 id="2-4-1传统的集合运算"><a href="#2-4-1传统的集合运算" class="headerlink" title="2.4.1传统的集合运算"></a>2.4.1传统的集合运算</h4><p>并、差、交、笛卡尔积</p><p>常考：R∩S&#x3D;R-(R-S)</p><h4 id="2-4-2专门的关系运算"><a href="#2-4-2专门的关系运算" class="headerlink" title="2.4.2专门的关系运算"></a>2.4.2专门的关系运算</h4><p>基础记号：</p><ul><li>关系R、t∈R（t是关系R的一个元组）、t[Ai]（元组t中相应于属性Ai的一个分量）</li><li>t[A]&#x3D;（t[Ai1]，t[Ai2]，t[Ai3]，……，t[Aik]）（元组t中相应于属性Ai的一个分量）</li><li>元组的连接&#x2F;串接（就是把列连起来）</li><li>象集（关系R(X,Z)，对所有列ABCD……,以A&#x3D;a，B&#x3D;b（即X&#x3D;x）这样的条件筛选满足的元组，筛选结果中非列AB的列属性构成的组合即为x在Z上的象集）</li></ul><p>专门关系：</p><ul><li>选择（σ）：（根据逻辑表达式来筛选有效元组）【注意比较运算符的不等于是&lt;&gt;】</li><li>投影（Π）：（只关注属性列，筛选出某些属性列并去除重复的元组）</li><li>连接（⋈）：对两个关系R、S，从笛卡尔积中抽取满足条件的元组（特殊的连接：θ取“&#x3D;”为等值连接、自然连接）</li><li>等值连接：抽取R中A列与S中B列相等的元组</li><li>自然连接：进行比较的列必需是同名的属性列，可能造成悬浮问题</li><li>悬浮元组、外连接、左外连接（只保留左边关系的悬浮元组）、右外连接（只保留右边关系的悬浮元组）</li><li>除运算（÷）：（除集合）对于公共属性列的投影，（被除集合）中谁的（象集）完全包含它，谁就需要被纳入结果。</li><li>【÷运算可以用来做筛选：例如由SC表÷Course表可得到选修所有课程学生的名单】</li></ul><p>经过有限次复合得到的表达式称为 关系代数表达式</p><p>如何使用五种基本运算来表达专门关系？是一个重要的问题</p><blockquote><p><strong>【知识框架总结因为版权问题不能放在这里】</strong></p></blockquote><h2 id="3-关系数据库标准语言-SQL"><a href="#3-关系数据库标准语言-SQL" class="headerlink" title="3 关系数据库标准语言 SQL"></a>3 关系数据库标准语言 SQL</h2><h3 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h3><p>▲特点</p><ul><li>功能综合且风格统一</li><li>数据操纵高度非过程化（只要提出做什么就可以）</li><li>面向集合的操作方式</li><li>以统一的语法结构提供多种使用方式（独立语言&#x2F;嵌入式语言）</li><li>语言简洁且易学易用</li></ul><h3 id="3-2数据定义"><a href="#3-2数据定义" class="headerlink" title="3.2数据定义"></a>3.2数据定义</h3><p>模式的定义与删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#定义模式</span><span class="token keyword">create</span> <span class="token keyword">schema</span> <span class="token punctuation">[</span>模式名<span class="token punctuation">]</span> <span class="token keyword">authorization</span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment">#删除模式</span><span class="token keyword">drop</span> <span class="token keyword">schema</span> <span class="token operator">&lt;</span>模式名<span class="token operator">></span><span class="token operator">&lt;</span><span class="token keyword">cascade</span><span class="token operator">|</span><span class="token keyword">restrict</span><span class="token operator">></span><span class="token comment">//级联与限制必须二选一（CASADE会删除所有，而若该模式内有东西，RESTRICT会拒绝删除）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>基本表的定义、删除与修改</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#基本表的定义</span><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token operator">&lt;</span>数据类型<span class="token operator">></span><span class="token punctuation">[</span>列级完整性约束<span class="token punctuation">]</span>                  ……                  <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表级完整性约束<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#一些表级完整性约束</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Cno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Sno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">)</span><span class="token punctuation">;</span>列级完整性<span class="token operator">/</span>表级完整性<span class="token comment">#基本表的修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">ADD</span> <span class="token punctuation">[</span><span class="token keyword">COLUMN</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>新列名<span class="token operator">></span><span class="token operator">&lt;</span>数据类型<span class="token operator">></span><span class="token punctuation">[</span>完整性约束<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ADD</span> <span class="token operator">&lt;</span>表级完整性约束<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">DROP</span> <span class="token punctuation">[</span><span class="token keyword">column</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">cascade</span><span class="token operator">|</span><span class="token keyword">restrict</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">DROP</span> <span class="token keyword">constraint</span> <span class="token operator">&lt;</span>完整性约束名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">restrict</span><span class="token operator">|</span><span class="token keyword">cascade</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">RENAME</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token keyword">to</span> <span class="token operator">&lt;</span>新列名<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token keyword">TYPE</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span><span class="token punctuation">]</span><span class="token comment">#基本表的删除</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">restrict</span><span class="token operator">|</span><span class="token keyword">cascade</span><span class="token punctuation">]</span>  <span class="token comment">#▲注意区别，默认RESTRICT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模式与基本表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#基本表属于某一个特定的模式，下面是创建特定模式下基本表的方法。</span><span class="token comment">#可以在指定模式下创建基本表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token string">"SC-C-SC"</span><span class="token punctuation">.</span>Student（……）<span class="token comment">#可以设定模式然后创建基本表</span><span class="token keyword">SHOW</span> SEARCH_PATH<span class="token punctuation">;</span><span class="token comment">#可以查看当前搜索路径</span><span class="token keyword">SET</span> SEARCH_PATH <span class="token keyword">TO</span> <span class="token string">"SC-C-SC"</span><span class="token punctuation">,</span><span class="token keyword">PUBLIC</span><span class="token punctuation">;</span><span class="token comment">#设置当前模式</span><span class="token comment">#之后再创建基本表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>课本示例</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#课本示例</span><span class="token comment">/*建立一个学生表*/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Student<span class="token punctuation">(</span>Sno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    Sname <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>    Ssex <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Sage <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span>    Sdept <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*建立一个课程表*/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Course<span class="token punctuation">(</span>Cno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    Cname <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    Cpno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Ccredit <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span>    <span class="token comment">/*表级完整性约束条件*/</span>    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Cpno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Course<span class="token punctuation">(</span>Cno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*建立学生选课表SC*/</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> SC<span class="token punctuation">(</span>Sno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Cno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Grade <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Cno<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Sno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>Cno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Cource<span class="token punctuation">(</span>Cno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据类型</p><p>P75</p><p>索引的建立与删除</p><p>建立索引：加快查询速度</p><p>索引是关系数据库管理系统的内部实现技术，属于<strong>内模式</strong>的范畴。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#索引的建立</span><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">unique</span><span class="token punctuation">]</span><span class="token punctuation">[</span>cluster<span class="token punctuation">]</span><span class="token keyword">index</span> <span class="token operator">&lt;</span>索引名<span class="token operator">></span><span class="token keyword">on</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">[</span><span class="token operator">&lt;</span>次序<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">,</span>……<span class="token punctuation">)</span><span class="token comment">#索引的修改</span><span class="token keyword">ALTER</span> <span class="token keyword">index</span> <span class="token operator">&lt;</span>旧索引名<span class="token operator">></span> <span class="token keyword">rename</span> <span class="token keyword">to</span> <span class="token operator">&lt;</span>新索引名<span class="token operator">></span><span class="token comment">#索引的删除</span><span class="token keyword">DROP</span> <span class="token keyword">index</span> <span class="token operator">&lt;</span>索引名<span class="token operator">></span><span class="token comment">#e.g.</span><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> Stusno <span class="token keyword">ON</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> Cousno <span class="token keyword">ON</span> Cource<span class="token punctuation">(</span>Cno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> SCno <span class="token keyword">ON</span> SC<span class="token punctuation">(</span>Sno <span class="token keyword">ASC</span><span class="token punctuation">,</span>Cno <span class="token keyword">DESC</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据字典（记录数据定义）</p><h3 id="★3-3数据查询"><a href="#★3-3数据查询" class="headerlink" title="★3.3数据查询"></a>★3.3数据查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">all</span><span class="token operator">|</span><span class="token keyword">distinct</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">[</span>别名<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">[</span>别名<span class="token punctuation">]</span><span class="token punctuation">]</span>……<span class="token keyword">FROM</span> <span class="token operator">&lt;></span> <span class="token punctuation">[</span><span class="token keyword">WHERE</span><span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>某个列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">having</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>某个列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">asc</span><span class="token operator">|</span><span class="token keyword">desc</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">limit</span> <span class="token operator">&lt;</span>行数<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">offset</span> <span class="token operator">&lt;</span>行数<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.3.1单表查询</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">#选择表中的若干列（投影操作）SELECT Sno FROM Student;#选择表中的若干组（选择操作）SELECT DISTINCT Sno FROM Student;#比较大小WHERE &#x3D; &gt; &lt; &lt;&gt;  !&#x3D; !&gt; !&lt;#确定范围SELECT Sno FROM Student WHERE Sage BETWEEN 20 AND 21;SELECT Sno FROM Student WHERE Sage NOT BETWEEN 20 AND 21;#确定集合IN | NOT IN#字符匹配% #任意长度字符串_ #任意单个字符WHERE Sname LIKE &#39;__寅&#39;;WHERE Sname NOT LIKE &#39;%寅&#39;;#涉及到含有通配符，可以后跟ESCAPE&#39;\&#39;进行转义#WHERE Sname NOT LIKE &#39;%寅\_&#39; ESCAPE &#39;\&#39;;#涉及空值的查询WHERE GRADE IS NULLWHERE GRADE IS NOT NULL#多重条件查询AND OR 括号#ORDER BY子句ORDER BY grade DESC | ASC #（排序操作）允许第二关键字#查询结果排序，不影响原表#聚集函数（数理统计）#不能用作WHERE子句条件表达式#只能作为SELECT子句和GROUP BY子句的HAVING短语COUNT(*)COUNT([ DISTINCT | ALL ]&lt;列名&gt;)支持 sum avg max min #e.g.SELECT COUNT(DISTINCT Sno) From SC;#GROUP BY子句（分组筛选）★★★GROUP BYSELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*) &gt; 10;#Limit子句（只选择前多少个子句，常与ORDER BY连用）LIMIT 10 OFFSET 5 #显示10个忽略前5个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.3.2连接查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 自然连接查询 复合条件连接查询</span><span class="token keyword">SELECT</span> student<span class="token punctuation">.</span>sno<span class="token punctuation">,</span>sname<span class="token keyword">FROM</span> student<span class="token punctuation">,</span>sc<span class="token keyword">WHERE</span> student<span class="token punctuation">.</span>sno<span class="token operator">=</span>sc<span class="token punctuation">.</span>sno <span class="token operator">AND</span>sc<span class="token punctuation">.</span>cno<span class="token operator">=</span><span class="token string">'2'</span> <span class="token operator">AND</span> sc<span class="token punctuation">.</span>grade<span class="token operator">></span><span class="token number">90</span><span class="token punctuation">;</span><span class="token comment"># 自身连接，需要为表起别名</span><span class="token comment">#e.g. 间接先修课（先修课的先修课）</span><span class="token keyword">SELECT</span> <span class="token keyword">first</span><span class="token punctuation">.</span>cno<span class="token punctuation">,</span>seconde<span class="token punctuation">.</span>cpno<span class="token keyword">FROM</span> course <span class="token keyword">first</span><span class="token punctuation">,</span>course <span class="token keyword">second</span><span class="token keyword">WHERE</span> <span class="token keyword">first</span><span class="token punctuation">.</span>cpno<span class="token operator">=</span><span class="token keyword">second</span><span class="token punctuation">.</span>cno<span class="token punctuation">;</span><span class="token comment"># 外连接，把表中的悬浮元组保存在结果关系中</span><span class="token keyword">SELECT</span> student<span class="token punctuation">.</span>sno<span class="token punctuation">,</span>sname<span class="token punctuation">,</span>ssex<span class="token punctuation">,</span>sage<span class="token punctuation">,</span>sdept<span class="token punctuation">,</span>cno<span class="token punctuation">,</span>grade<span class="token keyword">FROM</span> student <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> sc <span class="token keyword">ON</span> <span class="token punctuation">(</span>student<span class="token punctuation">.</span>sno<span class="token operator">=</span>sc<span class="token punctuation">.</span>sno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 多表连接和以上类似</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.3.3嵌套查询</p><p>查询块：一个select-from-where</p><p>嵌套查询，外层查询（父查询），内层查询（子查询）</p><p>【子查询不能用order by】</p><p> any,all,</p><p> exist谓词：只返回逻辑真假<br> 存在量词与全称量词</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">  <span class="token comment"># 不相关子查询</span><span class="token keyword">SELECT</span> name<span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> dept <span class="token operator">IN</span><span class="token punctuation">(</span>        <span class="token keyword">SELECT</span> dept         <span class="token keyword">FROM</span> student        <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'刘晨'</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 相关子查询</span><span class="token keyword">SELECT</span> sno<span class="token punctuation">,</span>cno<span class="token keyword">FROM</span> SC x<span class="token keyword">WHERE</span> Grade <span class="token operator">>=</span> <span class="token punctuation">(</span>    <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>               <span class="token keyword">FROM</span> SC y    <span class="token keyword">WHERE</span> y<span class="token punctuation">.</span>sno<span class="token operator">=</span>x<span class="token punctuation">.</span>sno               <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># ANY(SOME)/ALL</span><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span>age<span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> age<span class="token operator">&lt;</span><span class="token keyword">ALL</span><span class="token punctuation">(</span>        <span class="token keyword">SELECT</span> age        <span class="token keyword">FROM</span> student        <span class="token keyword">WHERE</span> dept<span class="token operator">=</span><span class="token string">'CS'</span>    <span class="token punctuation">)</span>    <span class="token operator">AND</span> dept<span class="token operator">!=</span><span class="token string">'CS'</span><span class="token punctuation">;</span><span class="token comment"># EXIST</span><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span><span class="token punctuation">(</span>    <span class="token keyword">SELECT</span> <span class="token operator">*</span>        <span class="token keyword">FROM</span> SC        <span class="token keyword">WHERE</span> sno<span class="token operator">=</span>student<span class="token punctuation">.</span>sno <span class="token operator">AND</span> cno<span class="token operator">=</span><span class="token string">'1'</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>★全称量词的转换</p><p>看书</p><p>★逻辑蕴含的转换</p><p>看书和作业例题</p><p>3.3.4集合查询（了解即可）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># UNION</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> dept<span class="token operator">=</span><span class="token string">'CS'</span><span class="token keyword">UNION</span> <span class="token punctuation">(</span><span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> age<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span><span class="token comment"># INTERSECT</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> dept<span class="token operator">=</span><span class="token string">'CS'</span><span class="token keyword">INTERSECT</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> age<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span><span class="token comment"># EXCEPT</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> dept<span class="token operator">=</span><span class="token string">'CS'</span><span class="token keyword">EXCEPT</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> student<span class="token keyword">WHERE</span> age<span class="token operator">&lt;=</span><span class="token number">19</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.3.5基于派生表的查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Cno<span class="token keyword">FROM</span> SC<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span><span class="token function">Avg</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span> <span class="token keyword">FROM</span> SC <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno<span class="token punctuation">)</span><span class="token keyword">AS</span> Avg_SC<span class="token punctuation">(</span>Avg_sno<span class="token punctuation">,</span>Avg_grade<span class="token punctuation">)</span><span class="token keyword">WHERE</span> SC<span class="token punctuation">.</span>Sno <span class="token operator">=</span> Avg_SC<span class="token punctuation">.</span>Avg_sno <span class="token operator">AND</span> SC<span class="token punctuation">.</span>Grade <span class="token operator">>=</span> Avg_SC<span class="token punctuation">.</span>Avg_grade<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4数据更新"><a href="#3-4数据更新" class="headerlink" title="3.4数据更新"></a>3.4数据更新</h3><p>3.4.1插入数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">插入一个元组<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>属性列<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>属性列<span class="token number">2</span><span class="token operator">></span>，……<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment">#如果与原表一致则可以省略</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>常量<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>常量<span class="token number">2</span><span class="token operator">></span>，……<span class="token punctuation">)</span><span class="token punctuation">;</span>插入子查询结果<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>属性列<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>属性列<span class="token number">2</span><span class="token operator">></span>，……<span class="token punctuation">)</span><span class="token punctuation">]</span>子查询<span class="token punctuation">;</span><span class="token comment">#e.g.</span><span class="token comment"># 插入元组</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student<span class="token punctuation">(</span>sno<span class="token punctuation">,</span>sname<span class="token punctuation">,</span>ssex<span class="token punctuation">,</span>sdept<span class="token punctuation">,</span>sage<span class="token punctuation">)</span><span class="token comment">#可以不指出属性名，但VALUE要保持顺序</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'201215128'</span><span class="token punctuation">,</span><span class="token string">'陈东'</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'IS'</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">#未给出的列将自动赋空值</span><span class="token comment"># 插入子查询结果</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> DEPT_AGE<span class="token punctuation">(</span>SDEPT <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>     AVG_AGE <span class="token keyword">SMALLINT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> DEPT_AGE<span class="token punctuation">(</span>SDEPT<span class="token punctuation">,</span>AVG_AGE<span class="token punctuation">)</span><span class="token keyword">SELECT</span> SDEPT<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>SAGE<span class="token punctuation">)</span><span class="token keyword">FROM</span> STUDENT<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> SDEPT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.4.2修改数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token keyword">set</span> <span class="token operator">&lt;</span>列名<span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token operator">></span>……<span class="token punctuation">[</span><span class="token keyword">where</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment"># 修改一个元组的值</span><span class="token keyword">UPDATE</span> student<span class="token keyword">SET</span> sage<span class="token operator">=</span><span class="token number">22</span><span class="token keyword">WHERE</span> sno<span class="token operator">=</span><span class="token string">'201215121'</span><span class="token punctuation">;</span><span class="token comment"># 修改多个元组的值</span><span class="token keyword">UPDATE</span> student<span class="token keyword">SET</span> sage<span class="token operator">=</span>sage<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment"># 带子查询的修改语句</span><span class="token keyword">UPDATE</span> SC<span class="token keyword">SET</span> grade<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">WHERE</span> sno <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> sno     <span class="token keyword">FROM</span> student     <span class="token keyword">WHERE</span> sdept<span class="token operator">=</span><span class="token string">'CS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.4.3删除数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">delete</span> <span class="token keyword">from</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">where</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-5空值的处理"><a href="#3-5空值的处理" class="headerlink" title="3.5空值的处理"></a>3.5空值的处理</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">空值与另一个值的算数运算结果为空值空值与另一个值的比较运算结果为UNKNOWN，不参与<span class="token operator">/</span>影响是非判定<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-6视图"><a href="#3-6视图" class="headerlink" title="3.6视图"></a>3.6视图</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span>，……<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">as</span> <span class="token operator">&lt;</span>子查询<span class="token operator">></span><span class="token comment">#子查询可以嵌套，此时称建立在多个基本表上</span><span class="token punctuation">[</span><span class="token keyword">with</span> <span class="token keyword">check</span> <span class="token keyword">option</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">#加上该句之后插入值时会自动检查是否符合子查询的要求，若不满足则拒绝</span><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">CASCADE</span><span class="token punctuation">]</span><span class="token keyword">UPDATE</span> <span class="token keyword">SET</span> <span class="token keyword">WHERE</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">VALUES</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token keyword">WHERE</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>执行CREATE VIEW 语句时指示把视图的定义存入数据字典，不执行SELECT语句，只有在对视图查询时，才按视图的定义从基本表中将数据查出。</li><li>行列子集视图：从单个基本表导出，并且只是丢掉了某些行或列，但保留了主码。（一般是可更新的）</li><li>带表达式的视图：带虚拟列的视图。</li><li>视图消解：首先进行有效性检查，检查查询中涉及的视图等是否存在。若存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的子查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询</li></ul><p>★视图的作用：</p><ul><li>视图能够对机密数据提供<strong>安全保护</strong></li><li>视图<strong>对重构数据库提供了一定程度的逻辑独立性</strong></li><li>视图能够<strong>简化用户操作</strong></li><li>视图使用户能以<strong>多种角度看待同一数据</strong></li></ul><h2 id="4-数据库安全性"><a href="#4-数据库安全性" class="headerlink" title="4 数据库安全性"></a>4 数据库安全性</h2><p>数据库安全性是指<strong>保护数据库</strong>，以防<strong>不合法使用</strong>所造成的数巨泄露、篡改或破坏。</p><p>★数据库的安全性保护数据<strong>防止恶意的破坏和非法的存取</strong></p><p>不安全因素：</p><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul><p>安全标准：TCSEC：A1,B3,B2,B1,C2,C1,D</p><p>CC</p><p>用户身份鉴别：静态口令鉴别，动态口令鉴别，生物特征鉴别，智能卡鉴别，入侵检测</p><p>存取控制：自主存取控制DAC（C2级），强制存取控制MAC（B1级）</p><h3 id="自主存取控制"><a href="#自主存取控制" class="headerlink" title="自主存取控制"></a>自主存取控制</h3><p>自主存取控制的缺点是可能存在数据无意识的泄露。因为数据本身并无安全性标记。</p><p>授权（grant）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token operator">&lt;</span>权限<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>权限<span class="token number">2</span><span class="token operator">></span>……<span class="token comment">#全部，用all priviliges</span><span class="token keyword">ON</span> <span class="token operator">&lt;</span>对象类型<span class="token operator">></span><span class="token operator">&lt;</span>对象名<span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>对象类型<span class="token number">2</span><span class="token operator">></span><span class="token operator">&lt;</span>对象名<span class="token number">2</span><span class="token operator">></span>……<span class="token keyword">TO</span> <span class="token operator">&lt;</span>用户<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token operator">&lt;</span>用户<span class="token number">2</span><span class="token operator">></span>……<span class="token comment">#全部，用public</span><span class="token punctuation">[</span><span class="token keyword">with</span> <span class="token keyword">grant</span> <span class="token keyword">option</span><span class="token punctuation">]</span><span class="token comment">#是否允许授权传播</span><span class="token comment">#注意不得循环授权</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>收回（revoke）</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">revoke &lt;权限1&gt;,&lt;权限2&gt;……on &lt;对象类型&gt;&lt;对象名&gt;,&lt;对象类型2&gt;&lt;对象名2&gt;……from &lt;用户1&gt;,&lt;用户2&gt;……[cascade | restrict]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建数据库权限</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create user &lt;username&gt; [with] [superuser | createdb] | password &#39;password&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数据库角色</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">create role &lt;角色名&gt;#创建角色grant &lt;权限&gt; on &lt;对象类型&gt;&lt;对象名&gt; to &lt;角色&gt;#角色授权grant &lt;角色&gt; to &lt;角色&#x2F;用户&gt; [with admin option] #角色授予其他角色&#x2F;用户，with admin option是否允许传播revoke &lt;权限&gt; on &lt;对象类型&gt;&lt;对象名&gt; from &lt;角色&gt;#角色授权收回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="强制存取控制"><a href="#强制存取控制" class="headerlink" title="强制存取控制"></a>强制存取控制</h3><p>强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体。</p><p>同时检查DAC和MAC</p><p>每个数据库对象被标以一定的密级，每一个用户被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。主体对客体的存取必须遵循以下规则：</p><ul><li>主体许可证级别大于或等于客体密级时，才能读取客体</li><li>主体许可证级别小于或等于客体密级时，才能写客体</li></ul><p>第二条是为了防止高许可证级别的主体恶意降低高密级客体导致数据泄露。</p><h3 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h3><p>与授权机制结合</p><h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>审计功能<strong>把用户对数据库的所有操作记录下来放入审计日志</strong>。</p><p>审计员可以通过审计日志监控数据库行为，找到非法存取数据的人，时间和内容等。审计机制提供了一种事后安全检查的机制。</p><p>DDL,DML,DCL分别是什么</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> audit_trail<span class="token keyword">set</span> audit_trail <span class="token keyword">to</span> <span class="token keyword">on</span>audit alert<span class="token punctuation">,</span><span class="token keyword">update</span> <span class="token keyword">on</span> xxx <span class="token keyword">by</span> access<span class="token comment">#对xxx进行审计</span>noaudit alert<span class="token punctuation">,</span><span class="token keyword">update</span> <span class="token keyword">on</span> xxx<span class="token comment">#取消对xxx进行审计</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据加密（略）"><a href="#数据加密（略）" class="headerlink" title="数据加密（略）"></a>数据加密（略）</h3><p>存储加密，传输加密</p><h3 id="其他安全性保护"><a href="#其他安全性保护" class="headerlink" title="其他安全性保护"></a>其他安全性保护</h3><p>推理控制，隐蔽信道，数据隐私，“三权分立”的安全管理机制</p><h2 id="5-数据库完整性"><a href="#5-数据库完整性" class="headerlink" title="5 数据库完整性"></a>5 数据库完整性</h2><p>★数据库的完整性防范对象：<strong>不合语义、不正确的数据</strong>，防止它们进入数据库。</p><p>数据库数据的<strong>正确性</strong>和<strong>相容性</strong></p><p>据库管理系统必须能够实现以下功能：</p><ul><li>提供<strong>定义完整性约束</strong>的机制</li><li>提供<strong>检查完整性约束</strong>的方法</li><li>提供完整性的<strong>违约处理</strong>办法</li></ul><h3 id="5-2-实体完整性"><a href="#5-2-实体完整性" class="headerlink" title="5.2 实体完整性"></a>5.2 实体完整性</h3><p>PRIMARY KEY 主码</p><p>检查主码值是否唯一，检查主码的各个属性是否为空，否则拒绝修改</p><h3 id="5-3-参照完整性"><a href="#5-3-参照完整性" class="headerlink" title="5.3 参照完整性"></a>5.3 参照完整性</h3><p>FOREIGN KEY 外码</p><p>对被参照表和参照表进行修改时可能出现问题</p><p>违约处理策略：（一般采用默认，如果需要其他，则在创建参照表时显式说明）</p><ul><li>拒绝执行（默认）</li><li>级联操作</li><li>设置为空值</li></ul><h3 id="5-4-用户定义的完整性"><a href="#5-4-用户定义的完整性" class="headerlink" title="5.4 用户定义的完整性"></a>5.4 用户定义的完整性</h3><p>属性上的约束（不满足拒绝执行）</p><ul><li>列值非空（NOT NULL）</li><li>列值唯一（UNIQUE）</li><li>检查列值是否满足一个条件表达式（CHECK短语）</li></ul><p>元组上的约束</p><p>违约处理：拒绝执行</p><p>注意如何使用CHECK子句</p><h3 id="5-5-完整性约束命名子句"><a href="#5-5-完整性约束命名子句" class="headerlink" title="5.5 完整性约束命名子句"></a>5.5 完整性约束命名子句</h3><p>完整性约束命名子句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CONSTRAINT</span> <span class="token operator">&lt;</span>完整性约束名<span class="token operator">></span> <span class="token operator">&lt;</span>完整性约束<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>包括NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK等子句</p><p>修改表中的完整性限制</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> xxxxx<span class="token keyword">DROP</span> <span class="token keyword">CONSTRAINT</span> C1<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> C2 <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-7-触发器"><a href="#5-7-触发器" class="headerlink" title="5.7 触发器"></a>5.7 触发器</h3><p>事件-条件-动作规则（ECArule）</p><p>类似约束，自动激活，功能更强</p><p>定义触发器</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">CREATE TRIGGER &lt;触发器名&gt;&#123;BEFORE|AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt;#触发事件为INSERT,DELETE,UPDATE以及它们的and,or以及类似UPDATE &lt;触发列,……&gt;具体指明操作列REFERENCING NEW|OLD AS &lt;变量&gt;FOR EACH &#123;ROW|STATEMENT&#125; [WHEN&lt;触发条件&gt;]&lt;触发动作体&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>教材举例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 将INSERT语句增加的元组数记录到insertlog中</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> Student_Count<span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> StudentREFERENCINGNEW <span class="token keyword">TABLE</span> <span class="token keyword">AS</span> DELTA<span class="token keyword">FOR</span> EACH STATEMENT<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> StudentInsertLog<span class="token punctuation">(</span>Numbers<span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> DELTA<span class="token punctuation">;</span><span class="token comment"># 将分数增加10%的操作添加到一个另一个表SC_U</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> SC_T<span class="token keyword">AFTER</span> <span class="token keyword">UPDATE</span> <span class="token keyword">ON</span> SCREFERENCINGOLDROW <span class="token keyword">AS</span> OldTupleNEWROW <span class="token keyword">AS</span> NewTuple<span class="token keyword">FOR EACH ROW</span><span class="token keyword">WHEN</span> <span class="token punctuation">(</span>NewTuple<span class="token punctuation">.</span>Grade<span class="token operator">>=</span><span class="token number">1.1</span><span class="token operator">*</span>OldTuple<span class="token punctuation">.</span>Grade<span class="token punctuation">)</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> SC_U <span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Cno<span class="token punctuation">,</span>OldGrade<span class="token punctuation">,</span>NewGrade<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span>OldTuple<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span>OldTuple<span class="token punctuation">.</span>Cno<span class="token punctuation">,</span>ldTuple<span class="token punctuation">.</span>Grade<span class="token punctuation">,</span>NewTuple<span class="token punctuation">.</span>Grade<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 教授的工资不低于4000，低于4000则改为4000</span><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> Insert_Or_Update_SalBEFORE <span class="token keyword">INSERT</span> <span class="token operator">OR</span> <span class="token keyword">UPDATE</span> <span class="token keyword">ON</span> TeacherREFERENCING NEW <span class="token keyword">row</span> <span class="token keyword">AS</span> newtuple<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span><span class="token keyword">IF</span><span class="token punctuation">(</span>newtuple<span class="token punctuation">.</span>Job<span class="token operator">=</span>‘教授’<span class="token punctuation">)</span> <span class="token operator">AND</span> newtuple<span class="token punctuation">.</span>Sal<span class="token operator">&lt;</span><span class="token number">4000</span><span class="token punctuation">)</span><span class="token keyword">THEN</span> newtuple<span class="token punctuation">.</span>Sal:<span class="token operator">=</span><span class="token number">4000</span><span class="token punctuation">;</span><span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行触发器（顺序）</p><ul><li>BEFORE触发器</li><li>激活该触发器的SQL语句</li><li>AFTER触发器</li></ul><p>删除触发器</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="【期中考试备考】"><a href="#【期中考试备考】" class="headerlink" title="【期中考试备考】"></a>【期中考试备考】</h1><p>事务的四个特性：持久性，一致性，原子性，隔离性</p><p>SQL语言具有的功能：数据定义，数据操纵，数据控制</p><p>DML数据操纵语言，DBL数据定义语言</p><h1 id="第二篇-设计与应用开发篇"><a href="#第二篇-设计与应用开发篇" class="headerlink" title="第二篇 设计与应用开发篇"></a>第二篇 设计与应用开发篇</h1><h2 id="★6-关系数据理论"><a href="#★6-关系数据理论" class="headerlink" title="★6 关系数据理论"></a>★6 关系数据理论</h2><h3 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h3><p>函数依赖：</p><ul><li><p>X函数确定Y   或   Y函数依赖于X   记作   X→Y</p></li><li><p>非平凡的函数依赖&#x2F;平凡的函数依赖（X→Y但Y⊆X，则是平凡的）</p></li><li><p>完全函数依赖&#x2F;部分函数依赖（X推出Y时X中的各部分是否缺一不可，若X的一部分就可以推出Y，则是部分函数依赖）</p></li><li><p>直接函数依赖&#x2F;传递函数依赖（X→Y,Y不是平凡的,Y不能→X,Y→Z,Z不是平凡的，则X→Z有传递函数依赖）</p></li></ul><p>（★不考）多值依赖：</p><ul><li>对于关系R(U,F),X+Y+Z&#x3D;U,若存在(x,y1,z1),(x,y2,z2)时，(x,y1,z2),(x,y2,z1)也同时存在，则多值函数依赖X→→Y。</li><li>理解：x确定时，y1到z的所有映射，y2都需要有。</li><li>若Z&#x3D;空集，则X→→Y为平凡的多值依赖</li></ul><p>码&#x2F;键：</p><ul><li>候选码：K-（F）-&gt;U，（U完全函数依赖于K），则K为R的候选码。</li><li>主码：若候选码多于一个，可以指定一个为主码。</li><li>全码：主码就是全部属性时。</li><li>超码：K-（P）-&gt;U，（U部分函数依赖于U），则K为超码。</li><li>外码：R中属性组X不是R的码，但X是另一个关系模式的码，X是R的外码。</li><li>候选码的超集（若存在）一定是超码，候选码的任何真子集一定不是超码</li></ul><p>范式</p><blockquote><p><strong>【范式和规范化因为版权问题不能放图片，我稍微简述一下】</strong></p></blockquote><p>大致就是</p><ul><li>第一范式（1NF）-&gt;第二范式（2NF）-&gt;第三范式（3NF）-&gt;巴斯科德范式（BCNF）-&gt;第四范式（4NF）-&gt;第五范式（5NF）</li><li>第一范式（1NF） 属性值都是不可分的原子值 第一范式（1NF）-&gt;第二范式（2NF） 消除非主属性对键的部分函数依赖</li><li>第二范式（2NF）-&gt;第三范式（3NF） 消除非主属性对键的传递函数依赖 第三范式（3NF）-&gt;巴斯科德范式（BCNF）</li><li>消除主属性对键的部分&#x2F;传递函数依赖 巴斯科德范式（BCNF）-&gt;第四范式（4NF）消除多值依赖</li><li>第四范式（4NF）-&gt;第五范式（5NF）消除链接依赖</li></ul><p>★不同等级的范式</p><ul><li><p>1NF（属性值都是不可分的原子值）</p></li><li><p>2NF（每一个非主属性完全函数依赖于任何一个候选码）</p></li><li><p>3NF（在1NF基础上，R不存在码X属性组Y非主属性Z且Z不是Y的子集，X→Y，Y→Z，Y不能→X）【每一个非主属性不传递依赖于码，不部分依赖于码】</p></li><li><p>BCNF（在1NF基础上，X→Y且Y不是X子集，X必含有码，即每一个决定因素必含有码）【不存在任何属性对候选码的传递函数依赖】在3NF基础上消除了主属性对码的部分函数依赖</p></li><li><p>（不考）4NF（在1NF基础上，对于R的每个非平凡多值依赖X→→Y且Y不是X的子集，X都含有码）</p></li></ul><p>（应试）掌握到3NF与BCNF即可，考题问是否能达到3NF</p><h3 id="★6-3-数据依赖的公理系统"><a href="#★6-3-数据依赖的公理系统" class="headerlink" title="★6.3 数据依赖的公理系统"></a>★6.3 数据依赖的公理系统</h3><p>Armstrong公理系统</p><ul><li>A1 自反律：若Y⊆X⊆U，则F逻辑蕴涵X→Y</li><li>A2 增广律：若F逻辑蕴涵X→Y，Z⊆U，则F逻辑蕴涵XZ→YZ</li><li>A3 传递律：若F逻辑蕴涵X→Y,Y→Z，则F逻辑蕴涵X→Z</li></ul><p>根据A1,A2,A3可得以下推理规则</p><ul><li>合并规则：若X→Y,X→Z，则X→YZ</li><li>分解规则：若X→Y,Z⊆Y，则X→Z</li><li>伪传递规则：若X→Y,WY→Z，则WX→Z</li></ul><p>引理：X→A1A2A3A4……Ak &lt;&lt;&lt;充分必要&gt;&gt;&gt; X→Ai成立（1&lt;i&lt;n）</p><p>Armstrong公理系统的有效性&amp;完备性</p><ul><li>有效性：由F出发，根据系统推导出来的每一个函数依赖一定在F+中</li><li>完备性：F+中的每一个函数依赖，必定可以由F触发根据系统推导出来</li></ul><p>函数依赖集的闭包：</p><ul><li>F为U上一组函数依赖，X⊆U，X在F上的闭包&#x3D;{A | X→A能由F根据Armstrong公理系统推导出}</li><li>引理6.2：X,Y⊆U,X→Y能由F根据Armstrong公理系统推导出 &lt;&lt;&lt;充分必要&gt;&gt;&gt; Y⊆X在F上的闭包</li></ul><p>函数依赖集的等价</p><ul><li>引理6.3 【F的闭包&#x3D;G的闭包】 &lt;&lt;&lt;充要条件&gt;&gt;&gt; 【F的闭包⊆G的闭包】 &amp;&amp; 【G的闭包⊆F的闭包】</li><li>判断是否【F⊆G的闭包】成立：逐一对F中的函数依赖X→Y，判断Y⊆（G+在X中的闭包）是否成立即可。</li></ul><p>★★★大题考察：</p><p>【书P187-189】</p><ul><li>求某个属性组X在F上的闭包（【做法】由X和组成X的元素去做扩散，看能推出哪些元素，自己自然是可以推出自己的）</li><li>判断该属性组X是否为候选码（闭包为全部属性的集合）（【做法】如果推出的元素就是全集，那这就是候选码）</li><li>（书上没有）求解关系的候选码（【思路】分为四类，L,R,LR,N，分别是只在左边出现，只在右边出现，左右都出现，左右都不出现，L和N必定是候选码中的属性，R必定不是，LR可能是）</li><li>判断两个函数依赖集是否等价（【做法】假设对F和G判定，对F中所有的X→Y都做X在G中的闭包，看看Y是不是被包含，然后同理可得G中也是，就能证明是不是等价的）</li><li>计算最小依赖集&#x2F;最小覆盖（【思路】①将右边拆成单个属性②试图将左边拆成单个属性：若AB→C，若C∈A在F中的闭包，则B冗余（剥夺B，不影响，B多余）③试图删除某个关系：若 A→B，若B∈A在{F删去A→B}的闭包，则该关系冗余（剥夺该关系，该关系的左值仍能推出右值，该关系冗余））</li><li>【具体做法】【图片】</li><li>检验F是否为最小依赖集（计算出来是自己）</li></ul><h2 id="7-数据库设计"><a href="#7-数据库设计" class="headerlink" title="7 数据库设计"></a>7 数据库设计</h2><h3 id="★7-1-数据库设计概述"><a href="#★7-1-数据库设计概述" class="headerlink" title="★7.1 数据库设计概述"></a>★7.1 数据库设计概述</h3><p>数据库一般设计过程</p><ul><li><strong>需求分析</strong>阶段：准确<strong>了解与分析用户需求（包括数据与处理）</strong>，需求分析如果不好可能会导致整个数据库重做。</li><li><strong>概念结构设计</strong>阶段：通过对用户需求进行综合、归纳与抽象，<strong>形成一个独立于具体数据库管理系统的概念模型</strong>。</li><li><strong>逻辑结构设计</strong>阶段：将概念结构转换为某个数据库管理系统所支持的<strong>数据模型</strong>，并对其进行<strong>优化</strong>。</li><li><strong>物理结构设计</strong>阶段：为逻辑数据模型选取一个最适合应用环境的<strong>物理结构（包括存储结构和存取方法）</strong>。</li><li><strong>数据库实施</strong>阶段：设计人员运用数据库管理系统提供的数据语言、工具及宿主语言，根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。</li><li><strong>数据库运行和维护</strong>阶段：在数据库系统运行过程中对其进行评价、调整与修改。</li></ul><h3 id="7-2-需求分析"><a href="#7-2-需求分析" class="headerlink" title="7.2 需求分析"></a>7.2 需求分析</h3><p>数据字典，包括下列5项</p><ul><li><p>数据项：不可再分的数据单位</p></li><li><p>数据结构：反映数据项之间的组合关系。数据结构可由数据项&#x2F;数据结构混合组成。</p></li><li><p>数据流：数据结构在系统内传输的路径</p></li><li><p>数据存储：数据结构停留或保存的地方，也是数据流的来源和去向之一。</p></li><li><p>处理过程：判定表&#x2F;判定树</p></li></ul><h3 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h3><p>概念模型：①真实充分反映现实世界，②易于理解，③易于更改，④易于向关系模型，网状模型，层次模型等数据模型进行转换。</p><p>E-R模型：</p><p>实体之间的联系：</p><ul><li>两个实体型之间：一对一联系，一对多联系，多对多联系 </li><li>两个以上实体型：</li><li>单个实体型内：</li></ul><p>E-R图：</p><ul><li>实体型：矩形</li><li>属性：椭圆形</li><li>联系：菱形</li><li>无向边：需要标注联系的类型(1:1,1:m,m:n等)</li></ul><p>【考试：先画含属性的实体型图，再画一张不含属性但含联系的实体型图】</p><p>用E-R图进行概念结构设计：</p><ul><li>实体与属性划分原则：属性为①不可再分的数据项 ②与别的实体无联系</li></ul><p>E-R图集成：</p><ul><li>自顶向下需求分析，自底向上设计概念结构</li></ul><p>过程：</p><p>（1）合并E-R图，生成初步E-R图</p><ul><li>属性冲突：属性域冲突，属性取值单位冲突</li><li>命名冲突：同名异义，异名同义</li><li>结构冲突：①同一对象在不同应用中具有不同的抽象 ②同一实体在不同子系统的E-R图中包含的属性个数和次序不一致 ③……</li></ul><p>（2）消除不必要的冗余，设计基本E-R图</p><ul><li><p>分析法：【……不是考察重点，不再展开……】</p></li><li><p>规范化理论：【……不是考察重点，不再展开……】</p></li></ul><h3 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h3><p>E-R图向关系模型的转换</p><ul><li>1:1的联系：可以转换为一个独立的关系模式，也可以与任意一端对于的关系模式合并。</li><li>1:n的联系：可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。</li><li>m:n的联系：转换为一个独立的关系模式。各实体的码组成关系的码或关系码的一部分。</li><li>三个或三个以上实体间的一个多元联系可以转换为一个关系模式</li><li>具有相同码的关系模式可以合并</li></ul><p>数据模型的优化</p><p>以规范化理论为指导：【5条】</p><p>水平分解：把（基本）关系的元组分为若干子集合</p><p>垂直分解：把关系模式R的属性分解为若干子集合</p><h3 id="7-5-物理结构设计"><a href="#7-5-物理结构设计" class="headerlink" title="7.5 物理结构设计"></a>7.5 物理结构设计</h3><ul><li>物理结构：主要是存取方法和存取结构</li><li>对物理结构进行评价：时间&#x2F;空间效率</li></ul><p>数据库物理结构设计的内容和方法</p><p>选择关系模式存取方法</p><p>（1）B+树索引方法的选择</p><ul><li>一个&#x2F;一组属性经常在查询条件中出现，考虑在这个&#x2F;这组属性上建立索引</li><li>一个属性经常作为最大值和最小值等聚集函数的参数，考虑在这个属性上建立索引</li><li>一个&#x2F;一组属性经常在连接操作的连接条件中出现，考虑在这个&#x2F;这组属性上建立索引。</li></ul><p>维护索引要代价，索引不是越多越好</p><p>（2）哈希索引方法的选择</p><p>①大小可预知且不变，或②关系大小动态改变，但DBMS支持动态哈希索引方法</p><p>（3）聚簇方法的选择</p><p>提高某个属性（组）的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块。该属性（组）称聚簇码。</p><p>设计候选聚簇【3条，略】</p><p>检查候选聚簇中的关系，取消不必要的关系【3条，略】</p><p>确定数据库的存储结构</p><ul><li>确定数据存放位置</li><li>确定系统配置</li></ul><p>评价数据库的物理结构：存储空间，存取时间，维护代价等</p><p>重组和重构</p><ul><li>数据库重组：不修改原设计的逻辑和物理结构</li><li>数据库重构：部分修改数据库的模式和内模式</li></ul><h3 id="7-6-数据库的实施和维护"><a href="#7-6-数据库的实施和维护" class="headerlink" title="7.6 数据库的实施和维护"></a>7.6 数据库的实施和维护</h3><p>数据的载入和应用程序的编码与调试</p><p>数据库的试运行</p><p>数据库的运行和维护</p><ul><li>数据库的转出和恢复</li><li>数据库的安全性&#x2F;完整性控制</li><li>数据库性能的监督，分析和改造</li><li>数据库的重组与重构：重组（不修改逻辑和物理结构），重构（部分修改数据库的模式和内模式）</li></ul><h2 id="【不考】8-数据库编程"><a href="#【不考】8-数据库编程" class="headerlink" title="【不考】8 数据库编程"></a>【不考】8 数据库编程</h2><h3 id="8-1-扩展SQL功能"><a href="#8-1-扩展SQL功能" class="headerlink" title="8.1 扩展SQL功能"></a>8.1 扩展SQL功能</h3><p>with子句</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>WITH RECURSIVE 子句</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内置函数</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过高级语言实现复杂应用</p><h3 id="8-2-过程化SQL"><a href="#8-2-过程化SQL" class="headerlink" title="8.2 过程化SQL"></a>8.2 过程化SQL</h3><p>过程化SQL的基本结构</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量&#x2F;常量定义</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>流程控制：条件控制&#x2F;循环控制&#x2F;错误处理</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>存储过程：创建&#x2F;执行&#x2F;修改&#x2F;删除&#x2F;优点</p><pre class="line-numbers language-none"><code class="language-none"># 优点运行效率更高，降低了客户机和服务器间的通信量，方便实施企业规则<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>存储函数（必须指定返回类型）：创建&#x2F;执行&#x2F;修改</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token operator">OR</span> <span class="token keyword">REPLACE</span> <span class="token keyword">FUNCTION</span> 函数名<span class="token keyword">RETURNS</span> <span class="token operator">&lt;</span>类型<span class="token operator">></span><span class="token keyword">AS</span> <span class="token operator">&lt;</span>过程化<span class="token keyword">SQL</span>块<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="8-3-JDBC编程"><a href="#8-3-JDBC编程" class="headerlink" title="8.3 JDBC编程"></a>8.3 JDBC编程</h3><p>Java DataBase Connectivity</p><p>结构：用户应用程序，JDBC驱动程序管理器，数据源</p><p>使用JDBC操纵数据库的工作流程</p><ul><li>加载驱动程序</li><li>建立于数据库的连接</li><li>执行SQL语句</li><li>处理结果集</li><li>释放资源</li></ul><p>【书P263有完整案例】</p><h2 id="【不考】9-关系数据库存储管理"><a href="#【不考】9-关系数据库存储管理" class="headerlink" title="【不考】9 关系数据库存储管理"></a>【不考】9 关系数据库存储管理</h2><p>了解 B+树索引，哈希索引</p><h2 id="10-关系查询处理和查询优化"><a href="#10-关系查询处理和查询优化" class="headerlink" title="10 关系查询处理和查询优化"></a>10 关系查询处理和查询优化</h2><h3 id="10-1-关系数据库管理系统的查询处理"><a href="#10-1-关系数据库管理系统的查询处理" class="headerlink" title="10.1 关系数据库管理系统的查询处理"></a>10.1 关系数据库管理系统的查询处理</h3><p>查询处理步骤：</p><ul><li>查询分析（ 词法+语法），</li><li>查询检查（语义，符号名转换安全性，完整性，这一步生成语法树），</li><li>查询优化（代数优化：关系代数表达式的优化，物理优化：存取路径和底层操作算法的优化，生成查询执行计划），</li><li>查询执行（代码生成器生成具体代码）</li></ul><p>实现查询操作的算法：</p><p>选择操作：</p><ul><li>全表扫描算法</li><li>索引扫描算法</li><li>（选择率大小不同，效率不同，根据结果集来选择，如果结果集比较小，就用索引，否则全表扫描）</li></ul><p>连接操作：</p><ul><li>嵌套循环连接算法（假设内存最大M块，A表先读M-1块，B表先读1块，进行匹配，然后B表下一块，B表读完后，A表再继续下一个M-1块，直至全部结束），</li><li>排序合并连接算法（先对连接属性排序，然后对于同一个A表按顺序读B表，读到B表第一个连接属性不同的就返回A表读下一个），</li><li>索引连接算法（建立连接属性的索引，然后根据索引查找并连接），</li><li>哈希连接算法（划分&#x2F;创建阶段：以连接属性作为哈希码，把较小的表映射到桶中，试探&#x2F;连接阶段：另一个表进行散列，然后桶中再进行匹配）</li></ul><h3 id="10-2-关系数据库管理系统的查询优化"><a href="#10-2-关系数据库管理系统的查询优化" class="headerlink" title="10.2 关系数据库管理系统的查询优化"></a>10.2 关系数据库管理系统的查询优化</h3><p>查询优化：选择有效的策略，求得给定关系表达式的值，使得查询代价较小。</p><p>★一个实例P308【可考计算题】</p><h3 id="10-3-代数优化"><a href="#10-3-代数优化" class="headerlink" title="10.3 代数优化"></a>10.3 代数优化</h3><p>通过对关系代数表达式的等价变换来提高查询效率</p><p>关系代数表达式等价变换规则【书P309-310】</p><p>语法树的启发式优化【5条启发式规则】</p><p>★大题：画语法树，关系代数语法树，优化后的语法树</p><h3 id="10-4-物理优化"><a href="#10-4-物理优化" class="headerlink" title="10.4 物理优化"></a>10.4 物理优化</h3><p>可供选择的方法有</p><ul><li>基于启发式规则的优化</li><li>基于代价估算的优化</li><li>两者结合</li></ul><p>基于启发式规则的优化：</p><p>选择操作的启发式规则：</p><ul><li>小关系：用全表顺序扫描</li><li>大关系：</li><li>【5条】书P313</li></ul><p>连接操作的启发式规则：</p><ul><li>【4条】书P313</li><li>选用嵌套循环连接算法时，选择其中占用块数B较小的表作为外表</li></ul><p>基于代价估算的优化</p><p>【书P314】</p><h3 id="★本章重要简答题"><a href="#★本章重要简答题" class="headerlink" title="★本章重要简答题"></a>★本章重要简答题</h3><p>1.试述关系数据库管理系统查询优化的一般准则。</p><p>记忆：选择怎么样？投影怎么样？选择和投影可以怎么样？选择和笛卡尔积可以怎么样？公共子表达式？连接算法？</p><pre class="line-numbers language-none"><code class="language-none">（1）尽可能先做选择运算（2）投影运算和选择运算应同时进行（3）把投影和其前后的双目运算结合起来（4）把某些选择与在它前面要执行的笛卡尔积结合起来成为一个连接运算（5）找出公共子表达式（6）选取合适的连接算法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.试述关系数据库管理系统查询优化的一般步骤。</p><p>记忆：画语法树，优化，存取路径，查询计划</p><pre class="line-numbers language-none"><code class="language-none">（1）把查询转换成某种内部表示，通常用的内部表示是语法树（2）利用优化算法，优化语法树（3）选择低层的存取路径（4）生成查询计划并选择其中代价最小的一种<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-数据库恢复技术"><a href="#11-数据库恢复技术" class="headerlink" title="11 数据库恢复技术"></a>11 数据库恢复技术</h2><h3 id="11-1-事务的基本概念"><a href="#11-1-事务的基本概念" class="headerlink" title="11.1 事务的基本概念"></a>11.1 事务的基本概念</h3><p>事务（transaction）：用户定义的一个数据库操作序列，不做或全做，这个工作单位不可分割。</p><p>显式定义事务</p><pre class="line-numbers language-aql" data-language="aql"><code class="language-aql">BEGIN TRANSACTION<span class="token punctuation">;</span>COMMIT<span class="token punctuation">;</span><span class="token comment">//正常结束，提交，所有更新写回物理数据库</span>ROLLBACK<span class="token punctuation">;</span><span class="token comment">//发生错误，回滚，事务中发生的操作全部撤销</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>★事务的ACID特性</p><ul><li>原子性(atomicity)：事务中的操作要么不做要么全做。</li><li>一致性(consistency)：事务执行的结果必须使数据库从一个一致性状态转移到另一个一致性状态。即完整性。</li><li>隔离性(isolation)：一个事务的执行不能被其它事务干扰。</li><li>持续性(durability)：一个事务一旦提交，它对数据库中数据的改变是永久性的，接下来其它操作或故障不会对它的执行结果造成影响。</li></ul><p>事务ACID遭破坏的可能因素：</p><ul><li>多个事务并行运行，不同事务的操作交叉执行（并发控制机制）</li><li>事务在运行过程中被强行停止（恢复机制）</li></ul><h3 id="★11-3-故障的种类"><a href="#★11-3-故障的种类" class="headerlink" title="★11.3 故障的种类"></a>★11.3 故障的种类</h3><ul><li>事务内部的故障：事务没有到达预期的终点（COMMIT或显式ROLLBACK）</li><li>系统故障：（软故障）造成系统停止运转，系统要重新启动（尚未完成的数据送入物理数据库，破坏原子性&#x2F;一致性；内存&#x2F;缓冲区数据丢失，破坏事务持续性）</li><li>介质故障：（硬故障）外存故障：磁盘损坏，磁头碰撞，瞬间强磁场干扰，破坏硬盘数据的计算机病毒等。</li></ul><h3 id="11-4-数据库恢复的实现技术"><a href="#11-4-数据库恢复的实现技术" class="headerlink" title="11.4 数据库恢复的实现技术"></a>11.4 数据库恢复的实现技术</h3><ul><li>本质：建立冗余数据</li><li>方法：数据转储（dump）和登记日志文件</li></ul><p>分类：</p><ul><li><p>事务故障&amp;系统故障：记录事务更新对象旧值和新值（日志文件），回滚未提交的事务（恢复为旧值），重做已提交的事务（更新为新值），（日志logging技术）</p></li><li><p>介质故障：重载备份（数据备份backup技术）</p></li></ul><p>数据转储（数据备份backup技术）</p><ul><li><p>静态备份：备份开始时处于一致性状态，且没有事务正在进行（优：实现简单；缺：必须等待事务结束，新事务等待备份结束）</p></li><li><p>动态备份：备份操作与用户事务并发进行（优：不用等待结束，不会影响新事务进行；缺：仅依靠后备副本无法保证数据有效）</p></li><li><p>全量备份</p></li><li><p>增量备份</p></li></ul><p>登记日志文件（日志logging技术）</p><ul><li><p>Undo日志：先写日志，后写数据，最后写提交标记</p></li><li><p>Redo日志：先写日志，再写提交标记，最后写数据</p></li><li><p>Undo&#x2F;Redo日志：先写日志，后写数据</p></li></ul><p>★为什么要先写日志，后写数据？</p><ul><li>这两者之间可能发生故障，若先写日志后发生故障，恢复时多做一次不必要的Undo操作，不会影响数据库正确性。若先写数据后发生故障，因为没有日志所以无法恢复。</li></ul><h3 id="★11-5-恢复策略"><a href="#★11-5-恢复策略" class="headerlink" title="★11.5 恢复策略"></a>★11.5 恢复策略</h3><p>事务故障：</p><ul><li>因为只是该事务发生的故障</li><li>反向扫描日志文件，对该事务的更新操作做逆操作，直到读到此事务的开始标记</li></ul><blockquote><p><strong>【因为版权问题以及课件的保密协议这里有2张图片不能放】</strong></p></blockquote><p>系统故障：</p><ul><li><p>正向扫描日志文件，找出故障发送前已提交的事务（有BEGIN TRANSACTION 和 COMMIT），放入REDO-LIST。找出故障时尚未完成的事务（只有BEGIN TRANSACTION 但无 COMMIT），放入UNDO-LIST。</p></li><li><p>对UNDO-LIST中的事务做撤销（反向扫描日志文件，对每个更新操作做逆操作，即“更新前的值”写入数据库）</p></li><li><p>对REDO-LIST中的事务做重做（正向扫描日志文件，重新执行日志文件登记操作，即“更新后的值”写入数据库）</p></li></ul><blockquote><p><strong>【因为版权问题以及课件的保密协议这里有2张图片不能放】</strong></p></blockquote><p>介质故障：</p><ul><li>装入最新数据库后备副本，恢复数据库到最近的一致状态</li><li>装入相应的日志文件副本，重做已完成的事务</li></ul><blockquote><p><strong>【因为版权问题以及课件的保密协议这里有2张图片不能放】</strong></p></blockquote><h3 id="★11-6-具有检查点的恢复技术"><a href="#★11-6-具有检查点的恢复技术" class="headerlink" title="★11.6 具有检查点的恢复技术"></a>★11.6 具有检查点的恢复技术</h3><p>问题：搜索整个日志很耗时，重新执行浪费大量时间，日志存储代价很大。为了解决这个问题，新增检查点。</p><p>检查点记录{①建立检查点时刻所有正在执行的事务清单 ②这些事务最近一个日志记录的地址}</p><p>重新开始文件：存放各个检查点在日志文件中的地址</p><blockquote><p><strong>【因为版权问题以及课件的保密协议这里有1张图片不能放】</strong></p></blockquote><p>利用检查点恢复的步骤：</p><ul><li>从“重新开始文件”中找到最后一个“检查点记录”的地址，在日志文件中找到最后一个“检查点记录”。</li><li>建立事务队列UNDO-LIST和REDO-LIST，检查点时的ACTIVE-LIST初始放入UNDO-LIST</li><li>正向扫描直至结束：若某任务START，放入UNDO-LIST；若某任务COMMIT，放入REDO-LIST</li><li>对UNDO-LIST中的事务，从结束逆向到最后检查点开始做UNDO，但对于在检查点记录中的ACTIVE事务，要继续回推到该事务的START（总结，UNDO-LIST中的事务都要完整从结束反推回START）</li><li>对REDO-LIST中的事务，从最后检查点开始正向扫描，对每一条做REDO</li></ul><p>具体案例：</p><blockquote><p><strong>【因为版权问题以及课件的保密协议这里有2张图片不能放】</strong></p></blockquote><h3 id="11-7-数据库镜像（了解）"><a href="#11-7-数据库镜像（了解）" class="headerlink" title="11.7 数据库镜像（了解）"></a>11.7 数据库镜像（了解）</h3><p>复制主数据库到别的地方，可以同时便利并发操作的读取。</p><h2 id="12-并发控制"><a href="#12-并发控制" class="headerlink" title="12 并发控制"></a>12 并发控制</h2><p>单处理机系统中，事务的并行执行实际上是这些并发事务的并行操作轮流交叉运行。称为：交叉并发方式。</p><h3 id="12-1-并发控制概述"><a href="#12-1-并发控制概述" class="headerlink" title="12.1 并发控制概述"></a>12.1 并发控制概述</h3><p>事务是并发控制的基本单位。目标是保证事务的隔离性和一致性。</p><p>并发操作带来的不一致性主要有：</p><ul><li>丢失修改（T1和T2读入同一数据各自修改，T2的提交破坏了 T1的修改，导致T1的修改被丢失）</li><li>脏读（T1提交的数据被T2读取后又被撤销，此时T2读到的数据就是脏的，即不正确的）</li><li>不可重复读（T1读取数据后，T2对记录中的数据更新，使得T1再次读取时得到与之前不一致的值）</li><li>幻读（T1读取数据后，T2对部分记录插入或删除，使得T1再次读取时发现一些记录小时了或者多出来了）</li></ul><p>并发控制的主要技术：封锁（locking），时间戳（timestamp），乐观方法，多版本并发控制</p><h3 id="12-2-事务的隔离级别"><a href="#12-2-事务的隔离级别" class="headerlink" title="12.2 事务的隔离级别"></a>12.2 事务的隔离级别</h3><p>由低到高（数据一致性增强，系统代价增高）：</p><ul><li>读未提交：允许一个事务读取另一个未提交事务正在修改的数据（避免丢失修改）</li><li>读已提交：只允许一个事务读取一个已提交的数据（避免丢失修改，避免脏读）</li><li>可重复读：一个十五开始读取数据后，其他事务就不能再对该数据执行更新操作（避免丢失修改，避免脏读，避免不可重复读）</li><li>可串行化：事务执行顺序可串行化（避免所有）</li></ul><h3 id="12-3-封锁"><a href="#12-3-封锁" class="headerlink" title="12.3 封锁"></a>12.3 封锁</h3><p>封锁：事务T对某个数据对象操作前先向系统申请加锁</p><p>基本封锁类型：</p><ul><li>排他型锁（X锁）：写锁，只允许事务T读取修改A，不允许别的事务加锁。</li><li>共享型锁（S锁）：读锁，允许事务T读取A不能修改A，允许别的事务加S锁但不能X锁。</li></ul><p>相容矩阵：只有S锁和S锁自己可相容，另：空跟别的都可相容</p><h3 id="12-4-封锁协议"><a href="#12-4-封锁协议" class="headerlink" title="12.4 封锁协议"></a>12.4 封锁协议</h3><p>三级封锁协议：定义何时申请锁，持续时间，何时释放</p><ul><li>一级封锁协议：长写锁。事务T修改数据R前加X锁，事务结束后释放。（【没有丢失修改】不保证不脏读，不保证可重复读）</li><li>二级封锁协议：长写锁+短读锁。在一级协议上，新增：事务T读数据R前加S锁，读完就可释放。（【不脏读】不保证可重复读）</li><li>三级封锁协议：长写锁+长读锁。在一级协议上，新增：事务T读数据R前加S锁，事务结束才可释放。【可重复读】</li></ul><h3 id="12-5-活锁和死锁"><a href="#12-5-活锁和死锁" class="headerlink" title="12.5  活锁和死锁"></a>12.5  活锁和死锁</h3><p>活锁</p><p>原因：多个事务请求同一个，但有可能先允许了后面的事务，导致前面的事务一直等待，饿死。</p><p>解决方法：采取先来先服务的策略</p><p>死锁</p><p>原因：T1和T2各自封锁对方想要获得的资源，并同时请求自己想要获得的资源</p><p>死锁的预防；</p><ul><li>一次封锁法：一次性将所有数据全部加锁</li><li>顺序封锁法：预先规定封锁顺序，所有事务都按照这个顺序封锁。</li></ul><p>死锁的诊断与解除：</p><ul><li>超时法：超过规定时间就认为发生了死锁</li><li>事务等待图法：有向图，节点为事务，边指向等待的事务，若出现回路，则存在死锁</li></ul><h3 id="12-6-并发调度的可串行性"><a href="#12-6-并发调度的可串行性" class="headerlink" title="12.6 并发调度的可串行性"></a>12.6 并发调度的可串行性</h3><p>调度不同，可能结果不同，存在一种正确调度。</p><ul><li><p>串行调度：（串行调度的并发执行必然是正确的）</p></li><li><p>可串行化调度：这种调度方式产生的结果与某次串行调度产生的结果相同。（可串行化调度的并发执行是正确的）</p></li><li><p>冲突可串行化调度：这种调度在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到的另一个调度是串行的，则该事务是冲突可串行化的，也必然是可串行化的（充分条件：冲突可串行化→可串行化）</p></li><li><p>冲突操作：不同事务对同一数据的读写&#x2F;写写操作</p></li><li><p>【不同事务的冲突操作】和【同一事务的两个操作】顺序不能互换</p></li></ul><p>做题：判断一个调度是否冲突可串行化调度？在规则允许的范围内尽可能交换事务中各语句的次序，使得事务能尽可能分离开来，变成串行的，如果能办到，就是冲突可串行化调度。</p><p>【期末考试8分】例题：R3(B)R1(A)W3(B)R2(B)R2(A)W2(B)R1(B)W1(A)，该调度是冲突可串行化的调度吗？为什么？</p><p>对原式中R1(A)依次与右边的邻居交换最终得到R3(B)W3(B)R2(B)R2(A)W2(B)R1(A)R1(B)W1(A)这是一个串行调度，故原调度是冲突可串行化调度。</p><h3 id="12-7-两段锁协议"><a href="#12-7-两段锁协议" class="headerlink" title="12.7 两段锁协议"></a>12.7 两段锁协议</h3><p>为了保证调度可串行化，使用两段封锁（two-phase lock，2PL）来实现可串行化。</p><p>遵守两段锁协议的一定是可串行化的。</p><p>所有事务必须分两个阶段对数据项加锁和解锁（读写之前申请封锁，释放锁后，不再申请和获得封锁）</p><ul><li>扩展阶段：获得封锁</li><li>收缩阶段：释放封锁</li></ul><p>★一次封锁法&lt;&gt;两段锁协议</p><p>一次封锁法遵守两段锁协议，但两段锁协议不要求一次封锁，故两段锁协议仍然可能发生死锁</p><h3 id="12-8-封锁的粒度"><a href="#12-8-封锁的粒度" class="headerlink" title="12.8 封锁的粒度"></a>12.8 封锁的粒度</h3><p>封锁粒度：封锁对象的大小（可以是逻辑单元：属性值，属性值集合，元组，关系，索引项，整个索引，整个数据库；物理单元：数据页，索引页；物理记录等）</p><p>封锁粒度↑，并发度↓，系统开销↓</p><p>多粒度封锁</p><p>多粒度树（根节点表示整个数据库，往下层次依次关系，元组等）</p><p>多粒度封锁协议：允许该树中的每个节点被独立加锁，加一个节点的锁时，其子树上的节点都加锁</p><ul><li><p>显式封锁：直接加到该节点的锁</p></li><li><p>隐式封锁：由于其上级节点被加锁而被加锁</p></li></ul><p>意向锁：表明该节点的子树上的节点正在被加锁。对任意节点加锁时，其所有上层节点都要加意向锁。</p><ul><li>意向共享型锁（IS）：其子树上的节点想加S锁</li><li>意向排他型锁（IX）：其子树上的节点想加X锁</li><li>共享意向排他型锁（SIX锁）：先加S锁再加IX锁</li><li>SIX例子：对某个表加SIX锁，读取整个表，但更新部分元组。</li><li>锁的强度关系：X&gt;SIX&gt;S,IX&gt;IS</li></ul><p>具有意向锁的多粒度封锁方法，提高了系统并发度，减少了加锁和解锁开销。</p><h1 id="【期末考试复习】"><a href="#【期末考试复习】" class="headerlink" title="【期末考试复习】"></a>【期末考试复习】</h1><p>【老师提供】数据库系统期末考试复习提纲（2023）</p><p>第一章 绪论</p><p>1.1 数据库的 4 个基本概念（数据、数据库、数据库管理系统和数据库系统）</p><ul><li><p>数据，是描述事物的符号记录。</p></li><li><p>数据库（DB），是长期存储在计算机内、有组织、可共享的大量数据的集合。</p></li><li><p>数据库管理系统（DBMS），位于用户与OS之间的数据管理软件。</p></li><li><p>数据库系统（DBS），是由DB、DBMS及其应用开发工具、应用程序和DBA组成的存储、管理、处理和维护数据的系统。</p></li></ul><p>1.2 数据库系统的特点、数据库系统与文件系统的区别与联系</p><ul><li>特点：数据共享性高，冗余度低且易扩充，独立性高，整体数据的结构化。</li><li>联系：文件系统和数据库系统都用于存储和管理数据</li></ul><p>1.3 数据模型及三要素</p><ul><li>数据模型：对现实世界数据特征的抽象</li><li>三要素：数据结构，数据操作，完整性约束</li><li>数据结构：描述数据库的组成对象以及对象之间的联系。</li><li>数据操作：对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</li><li>完整性约束：一组完整性规则。</li></ul><p>1.4 数据库系统的三级模式结构（外模式、模式、内模式）</p><p>数据库的二级映像功能与数据独立性（逻辑独立性、物理独立性）</p><p>第二章 关系数据库</p><p>2.1 码、主属性、非主属性、外码</p><p>2.2 关系代数 并、差、交、笛卡尔积、选择、投影、连接、除运算。</p><p>2.3 关系代数查询及关系运算</p><p>第三章 关系数据库标准语言 SQL</p><p>3.1 SQL 的基本概念，基本表、视图。</p><p>3.2 基本表及视图的定义、查询、更新</p><p>3.3 数据查询: 常用的 SQL 语句，常用的查询、修改、删除、分组、排序等 SQL 语句</p><p>3.4 能熟练使用聚集函数、通配符</p><p>3.5 多表连接查询、复合条件连接查询、嵌套查询</p><p>3.6 数据更新 插入数据、修改数据、删除数据</p><p>第四章 数据库安全性</p><p>4.1 数据库的安全性</p><ul><li>保护数据库，以防不合法使用所造成的数据泄露，篡改或破坏</li></ul><p>4.2 实现数据库安全性控制常用的方法和技术</p><p>4.3 掌握用户、角色的创建及授权和收回权限</p><p>第五章 数据库的完整性</p><p>5.1 数据库的完整性</p><ul><li>数据库的正确性和相容性</li></ul><p>5.2 实体完整性、参照完整性、用户定义完整性</p><p>第六章 关系数据理论</p><p>6.1 对函数依赖、码、主属性、非主属性、外码等有深入的理解</p><p>6.2 掌握关系模式的基本函数依赖、关系模式的候选码</p><p>6.2 掌握规范化理论，能够判断给定关系模式的规范化程度</p><p>6.3 掌握模式的分解,能够按要求对给定关系模式进行分解，修改为符合更高一级的范式</p><p>第七章 数据库设计</p><p>7.1 掌握数据库的一般设计过程及每个阶段的主要任务。</p><ul><li>需求分析：明确用户对数据库的需求</li><li>概念结构设计：设计独立于具体DBMS的概念模型</li><li>逻辑结构设计：根据概念模型转换得到具体的DBMS逻辑模型</li><li>物理结构设计：设计存储结构和存储路径</li><li>数据库实施：</li><li>数据库运行和维护：</li></ul><p>7.2 根据语义设计系统的 E-R 图，并将 E-R 图转换为关系模式（写出关系名称和所有属性）</p><p>7.3 对数据库设计方面有自己独到的理解</p><ul><li>【猜测】可扩展性：数据库模块化，数据库模块可变更的能力</li></ul><p>第九章 关系查询处理和查询优化</p><p>9.1 理解关系数据库系统查询优化的主要规则及步骤</p><ul><li>记忆（主要规则）：选择怎么样？投影怎么样？选择和投影可以怎么样？选择和笛卡尔积可以怎么样？公共子表达式？连接算法？</li><li>记忆（步骤）：画语法树，优化，存取路径，查询计划</li></ul><p>9.2 了解代数优化、物理优化</p><ul><li>代数优化：对关系代数表达式的优化，按照一定规则对关系代数表达式进行等价变换，改变操作的组合及次序，提高查询效率</li><li>物理优化：对存取路径和底层操作算进行优化</li></ul><p>第十章 数据库恢复技术</p><p>10.1 对事务的基本概念及事务的 ACID 特性有一定的理解和掌握</p><p>【事务】</p><p>10.2 理解数据库系统中故障的种类</p><ul><li>事务，介质，系统</li></ul><p>10.3 掌握数据库恢复技术（数据转储或数据备份、登记日志文件）</p><p>10.4 掌握并能熟练使用具有检查点的恢复技术。</p><ul><li>【推测考大题】</li></ul><p>第十一章 并发控制</p><p>11.1 并发控制及并发操作带来的数据不一致性</p><ul><li>丢失修改，脏读，不可重复读</li></ul><p>11.2 封锁技术及基本封锁类型（排他锁和共享锁）、三级封锁协议</p><p>11.3 活锁和死锁，死锁的预防、诊断与解除</p><p>11.4 可串行化调度及两段锁协议，判断一个并发调度是不是冲突可串行化调度。</p><p>【两段锁协议】</p><p>11.5 了解封锁粒度及多粒度封锁。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Note-AI</title>
      <link href="/2024/01/16/Note-AI/"/>
      <url>/2024/01/16/Note-AI/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基本概览了人工智能领域的基础知识，从Agent入手，经过搜索，逻辑等。</p><p>但对于领域前沿以及一些科研相关的内容没有过多涉及，还是比较浅显。</p><p>我准备分笔记、备考两个页面来讲清楚这门课程怎么收获知识+成绩。这里先放笔记。</p><img src="/note-ai/AI-note.png" class="" title="人工智能笔记"><h1 id="人工智能笔记"><a href="#人工智能笔记" class="headerlink" title="人工智能笔记"></a>人工智能笔记</h1><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><p>人工智能的4种观点</p><ul><li>像人一样思考</li><li>像人一样行动</li><li>合理地思考</li><li>合理地行动：★理性Agent：能够实现最佳期望结果而行动的Agent</li></ul><h2 id="第2章-智能Agent"><a href="#第2章-智能Agent" class="headerlink" title="第2章 智能Agent"></a>第2章 智能Agent</h2><h3 id="2-1-Agent和环境"><a href="#2-1-Agent和环境" class="headerlink" title="2.1 Agent和环境"></a>2.1 Agent和环境</h3><ul><li>【2024期中】Agent：可以<strong>感知</strong>环境并在环境中<strong>行动</strong>的事物</li><li>Agent函数：描述Agent行为，将感知序列映射为行动</li><li>Agent程序：实现Agent函数</li></ul><h3 id="2-2-理性Agent"><a href="#2-2-理性Agent" class="headerlink" title="2.2 理性Agent"></a>2.2 理性Agent</h3><p>【2024期中】理性Agent：对每一个可能的感知序列，根据已知的感知序列和Agent具有的先验知识，理性Agent应该采取能使其性能度量最大化的行动。</p><p>或：理性 Agent 为合理行动的 Agent，Agent 根据它所知道的做了“正确的事情”。</p><h3 id="2-3-环境PEAS"><a href="#2-3-环境PEAS" class="headerlink" title="2.3 环境PEAS"></a>2.3 环境PEAS</h3><p>【2024期中】一个 Agent 包含 4 个部分，性能、环境、执行器、感知器</p><p>任务环境：PEAS</p><ul><li>性能：Performance</li><li>环境：Environment</li><li>执行器：Actuators</li><li>传感器：Sensors</li></ul><p>任务环境的性质</p><ul><li>完全可观察&lt;&gt;部分可观察（完全可观察：每个时间点上都能获取环境的完整状态）</li><li>单Agent&lt;&gt;多Agent</li><li>确定的&lt;&gt;随机的&lt;&gt;不确定的（确定的：下一状态完全取决于当前状态和Agent执行的动作）【举例：真空吸尘器世界&lt;&gt;自动驾驶&lt;&gt;】</li><li>片段式的&lt;&gt;延续式的（下一片段不依赖于之前片段中采取的行动）【举例：流水线上的分类任务&lt;&gt;自动驾驶和国际象棋】</li><li>静态的&lt;&gt;动态的&lt;&gt;半动态的（环境在Agent计算时是否会发生变化。若Agent性能评价随时间流逝而变化，为半动态）【举例：字谜游戏&lt;&gt;自动驾驶&lt;&gt;国际象棋（计时）】</li><li>离散的&lt;&gt;连续的（环境的状态，时间；Agent的感知信息和行动）【举例：国际象棋&lt;&gt;自动驾驶】</li><li>已知的&lt;&gt;未知的（Agent的知识状态，即Agent了解环境的“物理法则”）环境的部分&#x2F;完全可观察&lt;&gt;环境已知&#x2F;未知【举例：翻牌游戏（已知环境部分可观察）&lt;&gt;视频游戏（未知环境完全可观察）】</li></ul><h3 id="2-4-Agent结构"><a href="#2-4-Agent结构" class="headerlink" title="2.4 Agent结构"></a>2.4 Agent结构</h3><p>Agent&#x3D;体系结构+程序</p><p>★Agent程序（基础4个+转化为学习Agent）</p><p>（每张对应的图要能画出来，下图由前向后每次迭代增加功能）</p><img src="/note-ai/ai-2.png" class="" title="Agent的四张图"><ul><li>简单反射Agent：基于当前感知选择行动，不关注感知历史</li><li>基于模型的反射Agent：Agent根据感知历史维持内部状态，Agent随时更新内部状态信息</li><li>基于目标的Agent：除了感知信息之外，还需要根据目标信息来选择行动</li><li>基于效用的Agent：当达到目标的行为有多种时，基于效用进行决策</li></ul><p>【2020期中】学习Agent：由性能元件，评判元件，学习元件，问题产生器构成</p><img src="/note-ai/ai-3.png" class="" title="学习Agent"><ul><li>评判元件：根据固定的性能标准告诉学习元件Agent的运转情况</li><li>学习元件：学习部件根据评判部件反馈的评价Agent的表现，确定如何修改执行部件</li><li>性能元件：接受感知，选择外部行动</li><li>问题产生器：负责得到新的和有信息的经验的行动提议</li></ul><h2 id="第3章-通过搜索进行问题求解"><a href="#第3章-通过搜索进行问题求解" class="headerlink" title="第3章 通过搜索进行问题求解"></a>第3章 通过搜索进行问题求解</h2><h3 id="3-1-问题求解Agent"><a href="#3-1-问题求解Agent" class="headerlink" title="3.1 问题求解Agent"></a>3.1 问题求解Agent</h3><p>搜索问题求解Agent步骤：形式化，搜索，执行</p><p>问题的定义</p><ul><li>初始状态：In(A)</li><li>行动：对于状态s，ACTION(s)&#x3D;{GO(B), GO(C), GO(D)}</li><li>转移模型：RESULT(IN(A), GO(B))&#x3D;IN(B)</li><li>目标测试：测试当前状态是否目标状态{IN(TARGET)}</li><li>路径耗散：反应性能度量</li></ul><h3 id="3-2-问题实例"><a href="#3-2-问题实例" class="headerlink" title="3.2 问题实例"></a>3.2 问题实例</h3><p>真空吸尘器世界</p><ul><li>状态：机器人的位置和灰尘的位置</li><li>行动：向左，向右，吸灰尘</li><li>转移模型：状态+行动-&gt;新状态</li><li>目标测试：检查所有位置是否都干净</li><li>路径耗散：1&#x2F;行动</li></ul><p>八数码问题</p><ul><li>状态：8个棋子以及空格在棋盘9个方格上的分布</li><li>行动：空格向左，向右，向上，向下</li><li>转移模型：状态+行动-&gt;新状态</li><li>目标测试：检查状态是否匹配目标</li><li>路径耗散：1&#x2F;行动</li></ul><p>八皇后问题（原版）</p><ul><li>状态：棋盘上0-8个皇后的任一摆放都是一个状态</li><li>行动：任意空格增加1个皇后</li><li>转移模型：将增加了皇后的棋盘返回</li><li>目标测试：8个皇后都在棋盘上，且无法互相攻击</li><li>路径耗散：无</li></ul><p>八皇后问题（改进）</p><ul><li>状态：n（0&lt;&#x3D;n&lt;&#x3D;8）皇后在棋盘上的任意摆放，满足左边起n列的皇后位置都合法</li><li>行动：在最左侧的空列中选择一格摆放皇后，要求该格子未受攻击</li><li>转移模型：将增加了皇后的棋盘返回</li><li>目标测试：8个皇后都在棋盘上，且无法互相攻击</li><li>路径耗散：无</li></ul><h3 id="3-3-通过搜索求解"><a href="#3-3-通过搜索求解" class="headerlink" title="3.3 通过搜索求解"></a>3.3 通过搜索求解</h3><p>▲搜索树&lt;&gt;搜索图</p><p>【图搜索集特有】探索集（closed表）：记录每个已扩展的节点。新节点若在探索集&#x2F;边缘集中，它将被丢弃而不是被加入边缘集中</p><p>【区别】搜索树会将与之相连的每个节点都作为待扩展结点（即使刚刚由A-&gt;B，A还是会称为B的扩展结点），搜索图则会保存所有已经被扩展的结点（不是待扩展，而是已经扩展）保存在closed表中，这些结点不会再作为被扩展结点。</p><p>节点数据结构：</p><ul><li>n.state 状态空间中的状态</li><li>n.parent 父节点</li><li>n.action 父节点扩展时采取的行动</li><li>n.path-cost 代价，初始状态到达该节点的路径损耗</li></ul><p>搜索顺序：FIFO队列，LIFO队列，优先级队列</p><p>哈希表：快速有效检测重复状态</p><p>问题求解算法性能</p><ul><li>完备性：问题有解时，算法是否能保证找到解</li><li>最优性：搜索策略是否能找到最优解</li><li>时间复杂度：搜索过程中产生结点的数目</li><li>空间复杂度：内存中同一时间存储的最多节点数</li></ul><h3 id="3-4-★无信息搜索（盲目搜索）"><a href="#3-4-★无信息搜索（盲目搜索）" class="headerlink" title="3.4 ★无信息搜索（盲目搜索）"></a>3.4 ★无信息搜索（盲目搜索）</h3><p>【特点】除了问题定义中提供的状态信息外没有任何附加信息，算法只能区分状态是不是目标状态，无法比较非目标状态的好坏</p><ul><li>宽度优先搜索：FIFO队列实现【完备性√】</li><li>一致代价搜索：扩展路径消耗最小的节点（宽搜+优先队列），【若不存在0代价行动，则是完备的】</li><li>深度优先搜索：</li><li>深度受限搜索：规定到了深度d就不再继续搜索，【可能是不完备的】</li><li>迭代加深的深度优先搜索：若到了深度d无结果，则扩展深度到d+1，【不一定最优，但完备】</li></ul><h3 id="3-5-★有信息（启发式）的搜索策略"><a href="#3-5-★有信息（启发式）的搜索策略" class="headerlink" title="3.5 ★有信息（启发式）的搜索策略"></a>3.5 ★有信息（启发式）的搜索策略</h3><p>定义：</p><ul><li>评估函数：f(n)</li><li>启发函数：h(n) &#x3D; 节点n到目标节点的最小代价路径的代价估计值（只依赖于节点状态）</li><li>当前实际代价：g(n)</li></ul><p>案例：</p><ul><li>（一致代价搜索：f(n) &#x3D; g(n)）（这个不是有信息搜索，放这里只是方便比较）</li><li>贪婪最佳优先搜索：f(n) &#x3D; h(n)</li><li>A*搜索：f(n) &#x3D; g(n) + h(n)</li></ul><p>保证最优性的条件：可采纳性 &amp; 一致性 （一致性更难满足，有一致性则必是可采纳的）</p><ul><li>可采纳性：h(n)不会高估到达目标的代价，即h(x)&lt;h*(x)</li><li>一致性&#x2F;单调性（只作用于图搜索）：满足三角不等式 h(n) &lt;&#x3D; c(n,a,n’) + h(n’)</li></ul><p>（可证明A*算法：若具有可采纳性，则有树搜索最优性；若具有一致性，则具有图搜索最优性）</p><p>【证明过程】PPT上有</p><p>【作业题】证明若一致，必是可采纳</p><p>证明：给定一个启发式函数满足h(G)&#x3D;0,其中G是目标状态，证明如果h是一致的，那么它是可采纳的。</p><blockquote><p>假设n为任意状态, G为某目标状态, 且从状态n到状态G的一条最优路径为n, n1, n2, ……, nm</p><p>根据一致性条件，h(n) &lt;&#x3D; c(n, a1, n1) + h(n1)</p><p>&lt;&#x3D; c(n, a1, n1) + c(n1, a2, n2) + h(n2)</p><p>&lt;&#x3D; c(n, a1, n1) + c(n1, a2, n2) + …… + c(nm, am+1, G) + h(G)</p><p>又 h(G) &#x3D;&#x3D; 0，故 h(n) &lt;&#x3D; c(n, a1, n1) + c(n1, a2, n2) + …… + c(nm, am+1, G)</p><p>根据实际意义，h*(n) &#x3D; c(n, a1, n1) + c(n1, a2, n2) + …… + c(nm, am+1, G)，因为这是从n到G的实际距离。</p><p>综上，h(n) &lt;&#x3D; h*(n)</p></blockquote><h3 id="3-6-启发式函数"><a href="#3-6-启发式函数" class="headerlink" title="3.6 启发式函数"></a>3.6 启发式函数</h3><p>评价：对于启发式搜索策略，关键在于启发式函数，启发式函搜索的性能分析可以使用有效分支因子。假设有N个结点，解的深度为d，<code>N+1 = 1+(b*)+(b*)^2+(b*)^3+……+(b*)^n</code>。b*即为有效分支因子。有效分支因子越小，算法性能越好，h(n)越大，有效分支因子越小。有效分支因子越小，算法性能越好。</p><p>优势：若h2(n) &gt; h1(n) 且均可采纳，则h2(n)有优势。（更倚重引导了，有效分支就减少了）</p><h3 id="第3章总结"><a href="#第3章总结" class="headerlink" title="第3章总结"></a>第3章总结</h3><table><thead><tr><th>算法</th><th>完备性</th><th>最优性</th><th>TIME</th><th>SPACE</th></tr></thead><tbody><tr><td>宽搜</td><td>√（分支有限时）</td><td>√（单步代价相同时）</td><td>0(b^d)，b分支因子</td><td>0(b^d)</td></tr><tr><td>一致代价</td><td>√（分支有限且代价不为0）</td><td>√</td><td>O(b^(1+lowbound(C*&#x2F;ε)))</td><td>O(b^(1+lowbound(C*&#x2F;ε)))</td></tr><tr><td>深搜</td><td>×</td><td>×</td><td>0(b^m),m最大深度</td><td>0(b*m)</td></tr><tr><td>深度受限</td><td>×</td><td>×</td><td></td><td></td></tr><tr><td>迭代加深</td><td>√（分支有限时）</td><td>√（单步代价相同时）</td><td>0(b^d)</td><td>0(b*d)</td></tr><tr><td>双向</td><td>√（都为宽搜且分支有限）</td><td>√（都为宽搜且单步代价相同）</td><td></td><td></td></tr><tr><td>贪婪最佳优先</td><td>×</td><td>×</td><td></td><td></td></tr><tr><td>A*</td><td>√</td><td>√</td><td></td><td></td></tr></tbody></table><p>【某年期末+2020期中】经典题</p><img src="/note-ai/ai-4.png" class="" title="经典题"><p>注意画图与实现</p><p>其中，一致代价：</p><p>队列，每次出队（即为扩展）代价最小的节点，并入队与它相连的且未经扩展过的节点，更新其在队列中的代价，直到扩展到终点节点。</p><h2 id="第4章-超越经典搜索"><a href="#第4章-超越经典搜索" class="headerlink" title="第4章 超越经典搜索"></a>第4章 超越经典搜索</h2><h3 id="4-1局部搜索算法与最优化问题"><a href="#4-1局部搜索算法与最优化问题" class="headerlink" title="4.1局部搜索算法与最优化问题"></a>4.1局部搜索算法与最优化问题</h3><p>智能优化算法（属于启发式算法）：遗传算法，模拟退火算法，禁忌搜索算法，粒子群算法，蚁群算法，爬山法</p><p>局部搜索算法：从单个当前结点出发，通常只移动到它的邻近状态而不保留搜索路径</p><h4 id="①爬山法"><a href="#①爬山法" class="headerlink" title="①爬山法"></a>①爬山法</h4><p>（内存消耗小，能在很大的或者无限的状态空间中找到合理的解。属于局部搜索算法，）</p><p>爬山法的缺陷：</p><ul><li>局部极大值：【主要缺点】会陷入局部最优解，而不一定能搜索到全局最优解</li><li>山脊：一个不直接相连的局部极大值序列，从每个局部极大点出发都是下山方向（搜索可能会在山脊的两面来回震荡，前进步伐很小。）</li><li>高原：一块平的区域，可能会迷路</li></ul><h4 id="②模拟退火算法"><a href="#②模拟退火算法" class="headerlink" title="②模拟退火算法"></a>②模拟退火算法</h4><p>（允许下山的随机爬山算法）：温度T控制以小于1的概率exp(-Δe&#x2F;T)接受非最佳的移动</p><p>在迭代更新可行解时，以一定的概率来接受一个比当前解要差的解，因此有可能会跳出局部最优解，达到全局的最优解。随着时间的推移，允许算法向坏的方向移动的概率逐步下降。</p><img src="/note-ai/ai-5.png" class="" title="模拟退火算法"><h4 id="③局部束搜索（未讲）"><a href="#③局部束搜索（未讲）" class="headerlink" title="③局部束搜索（未讲）"></a>③局部束搜索（未讲）</h4><p>局部束搜索（记录k个状态，各自搜索但信息传递，通知更好的状态）</p><p>随机束搜索（解决局部束搜索可能的k个状态很快聚集问题，随机选择后继的k个状态，即在topk中随机选择，而不是选择最好的那个）</p><h4 id="④遗传算法"><a href="#④遗传算法" class="headerlink" title="④遗传算法"></a>④遗传算法</h4><img src="/note-ai/ai-6.png" class="" title="遗传算法"><ul><li>编码方案：怎样把优化问题的解进行编码（二进制编码、浮点数编码方法、格雷码、符号编码方法、多参数编码方法）</li><li>适应度函数：怎样根据目标函数构建适应度函数</li><li>选择策略：优胜劣汰、适者生存</li><li>控制参数：种群的规模<strong>、</strong>算法执行的最大代数、执行不同遗传操作的概率等</li><li>遗传算子：【重要】选择，交叉，变异</li><li>算法终止准则：最大演化代数，或算法在连续多少代以后解的适应值没有改进</li></ul><p>【遗传算法补充（2024期中考试20分）】</p><p>轮盘赌算法：又称比例选择方法，其基本思想：各个个体被选中的概率与其适应度大小成正比。</p><p>1.产生初始种群 s1&#x3D; 13 (01101) s2&#x3D; 24 (11000) s3&#x3D; 8 (01000) s4&#x3D; 19 (10011)</p><p>2.计算适应度 假定适应度为f(s)&#x3D;s^2 ，则 f (s1) &#x3D; f(13) &#x3D; 13^2 &#x3D; 169 f (s2) &#x3D; f(24) &#x3D; 24^2 &#x3D; 576 f (s3) &#x3D; f(8) &#x3D; 8^2 &#x3D; 64 f (s4) &#x3D; f(19) &#x3D; 19^2 &#x3D; 361</p><p>3.选择概率</p><img src="/note-ai/ai-7.png" class="" title="选择概率"><p>4.累计概率</p><img src="/note-ai/ai-8.png" class="" title="累计概率"><p>平铺图</p><img src="/note-ai/ai-9.png" class="" title="平铺图"><p>例如设从区间［0, 1］中产生4个随机数: r1 &#x3D; 0.450126, r2 &#x3D; 0.110347 r3 &#x3D; 0.572496, r4 &#x3D; 0.98503</p><img src="/note-ai/ai-10.png" class="" title="区间"><p>【2024期中】（TODO）</p><p>轮盘赌算法</p><h3 id="4-2-连续空间中的局部搜索（没讲）"><a href="#4-2-连续空间中的局部搜索（没讲）" class="headerlink" title="4.2 连续空间中的局部搜索（没讲）"></a>4.2 连续空间中的局部搜索（没讲）</h3><h3 id="4-3-使用不确定动作的搜索（没讲）"><a href="#4-3-使用不确定动作的搜索（没讲）" class="headerlink" title="4.3 使用不确定动作的搜索（没讲）"></a>4.3 使用不确定动作的搜索（没讲）</h3><p>实例：不稳定的吸尘器世界</p><p>不确定性问题的解是嵌套if-then-else语句，是树而非序列</p><p>与或搜索树：</p><ul><li>确定性环境，或节点，在或节点上规范一个活动</li><li>不确定性环境：与节点，在与节点上包含所有可能的后果（画图时有连接标记）</li></ul><h3 id="4-4-部分可观察信息的搜索"><a href="#4-4-部分可观察信息的搜索" class="headerlink" title="4.4 部分可观察信息的搜索"></a>4.4 部分可观察信息的搜索</h3><p>①无观察信息的搜素（也称：无传感问题&#x2F;相容问题）【无传感问题可解，不是无解】</p><ul><li>物理状态：对于物理问题P，P有n个物理状态{s1,s2,s3,……,sn}</li><li>信念状态：包含物理状态的每个可能集合（最多2^n个信念状态，其中可能很多不可达）</li><li>初始状态：P这n个物理状态的集合{s1,s2,s3,……,sn}</li><li>行动序列：ACTIONS(b) &#x3D; ∪对任意(s∈b) ACTIONSp(s)</li><li>转移模型：（有点像编译原理LR文法的DFA项集图的感觉，简单来说就是对信念状态内的每个物理状态都做一遍ACTION，所得的为新信念状态）<ul><li>确定行动：b’ &#x3D; RESULT(b,a) &#x3D; {s’ | s’ &#x3D; RESULTp(s,a) 且 s∈b}</li><li>不确定行动：b’ &#x3D; RESULT(b,a) &#x3D; {s’ | s’ ∈ RESULTp(s,a) 且 s∈b}</li></ul></li><li>目标测试：信念状态中的所有物理状态都满足目标状态</li><li>路径开销：假定所有状态下一个行动的开销相同</li><li>结论：如果一个行动序列是信念状态b的解，那么该行动序列是信念状态任何子集的解</li><li><img src="/note-ai/ai-11.png" class="" title="部分可观察信息"></li></ul><p>②有观察信息的搜索</p><img src="/note-ai/ai-12.png" class="" title="有观察信息的搜索"><p>在无观察信息的基础上多加一步对结果可能感知的预测，再多加一个合并</p><img src="/note-ai/ai-13.png" class="" title="有观察信息的搜索"><p>③求解部分可观察环境中的问题</p><img src="/note-ai/ai-14.png" class="" title="不分可观察环境中的问题"><p>④部分可观察环境中的问题求解Agent</p><ul><li>形式化，搜索算法，执行解行动</li><li>解是一个条件规划不是一个序列 if-then-else</li><li>Agent在完成行动和接收感知信息时维护自身的信念状态</li></ul><h3 id="4-5-联机搜索Agent和未知环境（没讲）"><a href="#4-5-联机搜索Agent和未知环境（没讲）" class="headerlink" title="4.5 联机搜索Agent和未知环境（没讲）"></a>4.5 联机搜索Agent和未知环境（没讲）</h3><h2 id="第5章-对抗搜索（博弈）"><a href="#第5章-对抗搜索（博弈）" class="headerlink" title="第5章 对抗搜索（博弈）"></a>第5章 对抗搜索（博弈）</h2><p>定义</p><ul><li>S0 初始状态</li><li>Player 谁行动</li><li>Actions 状态下的合法行动集合</li><li>Result(s,a) 状态转移模型</li><li>Terminal-test(s) 终止测试</li><li>Utility(s,p) 效用函数</li></ul><h3 id="★MIN-MAX算法"><a href="#★MIN-MAX算法" class="headerlink" title="★MIN-MAX算法"></a>★MIN-MAX算法</h3><p>时间复杂度<em>O</em>(b^m)，空间复杂度<em>O</em>(bm)</p><p>MIN层，MAX层</p><h3 id="★αβ剪枝"><a href="#★αβ剪枝" class="headerlink" title="★αβ剪枝"></a>★αβ剪枝</h3><p>剪枝条件（6分）</p><ul><li>对于maximizer的子节点，如果取值大于等于beta，则进行剪枝；</li><li>对于minimizer的子节点，如果取值小于等于alpha，则进行剪枝。</li></ul><h3 id="机会博弈"><a href="#机会博弈" class="headerlink" title="机会博弈"></a>机会博弈</h3><p>扩展极小极大算法：添加chance层</p><h3 id="多人博弈"><a href="#多人博弈" class="headerlink" title="多人博弈"></a>多人博弈</h3><ul><li>用向量值取代单一值</li><li>通常选择使自己效用值最大的行为</li><li>联盟与破坏联盟</li></ul><h3 id="不完整信息游戏"><a href="#不完整信息游戏" class="headerlink" title="不完整信息游戏"></a>不完整信息游戏</h3><h3 id="不完美时的决策"><a href="#不完美时的决策" class="headerlink" title="不完美时的决策"></a>不完美时的决策</h3><p>截断测试，评估函数，向前剪枝，搜索表</p><p>【2017期末】</p><p>提高博弈问题的搜索效率有什么方法并分析每种方法对算法最优性的影响：</p><ul><li>（1）α-β剪枝，不影响算法的最优性 （2分）</li><li>（2）采用评估函数和截断测试的方式，影响算法的最优性（2分）</li><li>（3）向前剪枝策略只考虑最优的部分分支，影响算法的最优性（2分）</li><li>（4）采用搜索表的方式，不影响算法的最优性（2分）</li></ul><h2 id="第6章-CSP约束满足问题"><a href="#第6章-CSP约束满足问题" class="headerlink" title="第6章 CSP约束满足问题"></a>第6章 CSP约束满足问题</h2><h3 id="6-1-约束满足问题的定义："><a href="#6-1-约束满足问题的定义：" class="headerlink" title="6.1 约束满足问题的定义："></a>6.1 约束满足问题的定义：</h3><p>约束满足问题（CSP，Constraint Satisfaction Problem）由一个变量集合和一个约束集合组成。</p><p>每个变量有自己的值域，当每个变量都有自己的赋值同时满足所有关于变量的约束时，问题就得到了解决，这类问题就叫做约束满足问题。</p><p>三元组{X, D, C}</p><ul><li>X 是变量的集合：{X1, X2, X3, ……, Xn}</li><li>D 是值域的集合，每个变量都有自己的值域。：对于Xi有{ D1, D2, D3, ……, Dn} （D即Domain）</li><li>C 是描述变量取值的约束集合（C即Constraint）</li></ul><p>问题的状态定义：对部分&#x2F;全部状态的一个赋值</p><ul><li>相容的：一个不违反任何约束条件的赋值</li><li>完整的：每个变量都已经赋值</li><li>CSP的解是相容的、完整的部分赋值：只有部分变量赋值（通常作为中间状态）</li></ul><p>约束：一元约束、二元约束、高阶约束、全局约束（即这个约束条件涉及几个变量）</p><h3 id="6-2-约束传播：CSP中的推理"><a href="#6-2-约束传播：CSP中的推理" class="headerlink" title="6.2 约束传播：CSP中的推理"></a>6.2 约束传播：CSP中的推理</h3><ul><li>结点相容：单个变量值域中所有取值满足它的一元约束，该变量节点相容。若网络中所有变量都节点相容，该网络节点相容。</li><li>弧相容：某变量值域中所有取值满足它的所有二元约束，该变量弧相容。若网络中所有变量都弧相容，该网络弧相容。<ul><li>通用弧相容：扩展“弧相容”的概念至n元约束，例如对于Xi的{0,1,2,3}，满足约束X&lt;Y&lt;Z，需要删去2和3</li><li>AC-3算法：维护弧相容队列，每次弹出一组弧(Xi,Xj)，首先使Xi对Xj弧相容。若其值域Di无变化，则处理下一条弧；若Di变小，则每个指向Xi的弧(Xk,Xi)都必须重新进入队列中等待检验。若Di变为空集，直接返回失败；否则继续检验。</li></ul></li><li>路径相容：两个变量的集合{Xi,Xj}对于第三个变量Xm是相容的，指对{Xi,Xj}的每一个相容赋值{Xi&#x3D;a,Xj&#x3D;b}，Xm都有合适的取值使得{Xi,Xm}和{Xm,Xj}是相容的。（即）<ul><li>PC-2算法</li></ul></li><li>K相容：对于任何k-1个变量的相容赋值，第k个变量总能被赋予一个和前k-1个变量相容的值，那么这个CSP为k相容<ul><li>1-相容 -&gt; 结点相容</li><li>2-相容 -&gt; 弧相容</li><li>3-相容 -&gt; 路径相容</li><li>强k相容：从k-相容一直到1-相容都成立</li></ul></li></ul><p>全局约束：</p><ul><li>alldiff约束</li><li>资源约束：atmost约束</li></ul><h3 id="6-3-CSP的回溯搜索"><a href="#6-3-CSP的回溯搜索" class="headerlink" title="6.3 CSP的回溯搜索"></a>6.3 CSP的回溯搜索</h3><p>变量和取值顺序：下一步给哪个变量赋值？按什么顺序赋值？</p><ul><li>最少剩余值（MRV）&#x2F;最受约束变量&#x2F;失败优先启发式</li><li>约束最多变量：优先选择最能约束其他变量的变量进行赋值</li><li>（取值顺序）最少约束值启发式：选择使得剩余变量赋值空间更大的值</li></ul><img src="/note-ai/ai-15.png" class="" title="最受约束变量"><img src="/note-ai/ai-16.png" class="" title="约束最多变量"><img src="/note-ai/ai-17.png" class="" title="最多约束变量2"><p>搜索与推理交错进行：每步应该怎样的推理？</p><ul><li>前向检验：只要变量X被赋值了，前向检验对它进行弧相容检查，从与它弧相容的未赋值变量Y的值域中删掉与X不相容的值。若值域为空集，直接回溯。（前向检测从赋值变量向未赋值变量传播信息，但不能对失败提供早期检测）</li><li>MAC（维护弧相容）：Xi被赋值后，调用AC-3对与Xi弧相容的变量Xj出发进行正常的约束传播。若某变量值域为空，直接回溯。</li><li>MAC传递传播约束，而前向检验只读不改</li></ul><img src="/note-ai/ai-18.png" class="" title="前向检验"><p>智能回溯：向后看：收获到达某赋值违反约束时，搜索本身能否避免重复这样的失败？</p><ul><li>建立冲突集，回溯到冲突集中时间最近的赋值（冲突集可以由前向检验算法提供）</li><li>冲突引导的回跳：直接回溯到导致问题的根源</li></ul><h3 id="6-4-CSP局部搜索（没讲）"><a href="#6-4-CSP局部搜索（没讲）" class="headerlink" title="6.4 CSP局部搜索（没讲）"></a>6.4 CSP局部搜索（没讲）</h3><h3 id="6-5-问题的结构"><a href="#6-5-问题的结构" class="headerlink" title="6.5 问题的结构"></a>6.5 问题的结构</h3><p>应用拓扑排序来求解树结构的CSP</p><p>割集调整</p><ul><li>（1）从CSP的变量中选择子集S，使得约束图在删除S之后成为一棵树。S称为环割集</li><li>（2）对于满足S所有约束的S中的变量的每个可能赋值</li><li>（a）从CSP剩余变量的值域中删除与S赋值不相容的值，</li><li>（b）若去掉S后的剩余CSP有解，把解和S的赋值一起返回</li></ul><p>树分解</p><ul><li>原始问题的每个变量至少在一个子问题出现</li><li>如果两个变量在原问题中由约束相连，那么它们至少同时出现在一个子问题中（连同它们的约束）</li><li>吐过一个变量出现在树中的两个子问题中，那么它必须出现在连接这两个子问题的路径上的所有子问题里</li></ul><h2 id="期中考试（另附）"><a href="#期中考试（另附）" class="headerlink" title="期中考试（另附）"></a>期中考试（另附）</h2><p>1.Agent是什么，理性Agent是什么，一个足球运动员Agent有哪些组件构成</p><p>2.初始状态BBWWE，移动方式有两种：①W或B移动到相邻的E，代价1 ②W或B跳到相隔一个W或B的E，代价2。定义评估函数f(x)&#x3D;d(x)+3*h(x)，d(x)为搜索树深度，h(x)为启发函数，定义为W左侧的B个数之和。要画出搜索树，并问这个启发函数是否具有可采纳性。</p><p>3.轮盘赌算法（见遗传补充部分）这里不知道适应度函数代表概率，全错了。</p><p>4.min-max和αβ剪枝</p><p>5.给了一份数独。问约束满足问题的定义，三个组成构件，以及怎么定义这个数独问题的约束满足问题，最后让写出算法。</p><h2 id="第7章-第9章-逻辑Agent"><a href="#第7章-第9章-逻辑Agent" class="headerlink" title="第7章-第9章 逻辑Agent"></a>第7章-第9章 逻辑Agent</h2><p>【参考《离散数学》】</p><h3 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h3><p>假定世界由一个个的事实组成</p><p>基于知识的Agent</p><ul><li><strong>知识库(KB)</strong>&#x3D;一种正式语言的语句集合</li><li>预先给定的而不是推导的语句称为<strong>公理</strong></li><li>知识库的添加:Tell</li><li>知识库的查询:Ask</li></ul><p>逻辑蕴含关系：α |&#x3D; β， M(α) ⊆ M(β)</p><p>模型检验</p><ul><li>可靠性：KB |-i α</li><li>完备性：任意 KB |&#x3D; α，都有 KB |-i α</li></ul><p>命题逻辑</p><ul><li>命题联结词</li><li>复合命题</li><li>真值表</li><li>语法</li><li>语义</li></ul><p>逻辑等价</p><ul><li>如果两个语句α,β在同样的模型集合中为真，则它们是逻辑等价的,记为α ≡ β</li><li>α ≡ β当且仅当 α |&#x3D; β 且β |&#x3D; α</li></ul><p>语句：</p><ul><li>有效的（所有模型中都为真）</li><li>可满足的（在某一个模型中为真）</li><li>不可满足的（每个模型中都不为真）</li></ul><p>推理规则</p><ul><li>假言推理规则&#x2F;分离规则（M.P.）</li><li>与消解</li><li>与导入</li><li>双重否定</li><li>单项消解&#x2F;单项归结</li><li>★消解&#x2F;归结</li></ul><p>命题逻辑推理算法</p><ul><li>DPLL算法：是一种完备的、以回溯为基础的算法，用于解决在合取范式（CNF）中命题逻辑的布尔可满足性问题。</li><li>WalkSAT算法：用于求解布尔可满足性问题（确定是否存在满足给定布尔公式）的局部搜索算法</li></ul><p>WalkSAT算法：</p><ul><li>每次迭代时选择一个未得到满足的子句并从该子句中选择一个符号对其进行翻转，翻转符号的选择方法：<ul><li>1）最小化新状态下未满足语句的数量</li><li>2）随机挑选符号</li></ul></li><li>评估函数：最小化不满足的子句数量</li></ul><h3 id="一阶逻辑-谓词逻辑"><a href="#一阶逻辑-谓词逻辑" class="headerlink" title="一阶逻辑&#x2F;谓词逻辑"></a>一阶逻辑&#x2F;谓词逻辑</h3><p>命题逻辑假定世界由一个个的事实组成</p><p>命题逻辑的局限性</p><ul><li>在命题逻辑中，每个陈述句是最基本的单位——原子命题，无法对原子命题进行分解。</li><li>命题逻辑中，不能表达局部与整体、一般与个别的关系。</li></ul><p>一阶逻辑&#x2F;谓词逻辑（First Order Logic, FOL）假定世界包含对象、关系、函数</p><p>原子命题被细化为个体、谓词和量词。</p><p>基本元素</p><ul><li>谓词</li><li>量词</li><li>函词</li></ul><p>谓词&lt;&gt;函词（谓词提供由个体到True&#x2F;False的映射，函词提供由个体域中的个体到个体的映射）</p><p>全称量词与存在量词</p><p>主要逻辑连接符：</p><ul><li>任意 对应 -&gt;</li><li>存在 对应 合取符号</li></ul><p>全称量词和存在量词同时存在时不能随意交换顺序，同一类别单独存在时可以全称</p><p>全称&#x2F;存在量词的引入&#x2F;消去</p><p>全称量词实例化（用任何常数置换）</p><p>合一置换（使不同的逻辑表示变得相同的置换）Unify</p><p>一般化假言推理规则（GMP）</p><p>归结：通过合一置换θ&#x3D;{<em>u</em>&#x2F;G(<em>x</em>), <em>v</em>&#x2F;<em>x</em>}进行归结</p><p>【用一阶逻辑描述集合论】</p><p>【用一阶逻辑描述电路领域】</p><p>【某年期末考题：建立亲属关系的公理系统】</p><p>【很多年的考题】★★★转换为合取范式（CNF）</p><ul><li>消去等价词（双向蕴含改单向蕴含）</li><li>消去蕴含词</li><li>否定内移</li><li>变量标准化</li><li>Skolem化（注意三种情况的变化<a href="https://zhuanlan.zhihu.com/p/516469801">什么是斯科伦范式（Skloem norm），如何化简 - 知乎</a>）</li><li>删除全称量词</li><li>等价变换为合取范式（将合取分配到析取中）</li></ul><p>Skolem化补充：</p><img src="/note-ai/ai-19.png" class="" title="skolem化"><p>【很多年的考题】使用归结算法证明</p><p>欲证明KB&#x3D;|α，</p><p>只要证明(KB∧﹁α)是不可满足的</p><p>【经典示例：West贩卖导弹给敌国是犯罪的】</p><h2 id="第13章-不确定性的量化"><a href="#第13章-不确定性的量化" class="headerlink" title="第13章 不确定性的量化"></a>第13章 不确定性的量化</h2><p>【参考《概率论》内容】</p><h3 id="13-1-不确定环境下的行动"><a href="#13-1-不确定环境下的行动" class="headerlink" title="13.1 不确定环境下的行动"></a>13.1 不确定环境下的行动</h3><p>信念度：Agent拥有的知识不能保证实现其中任何一个目标，但可以提供它们在某种程度上将被实现。</p><p>逻辑Agent&lt;&gt;概率Agent</p><ul><li>（相同点，都认为）世界由成立或者不成立的事实组成</li><li>逻辑Agent相信每个语句是正确的或者错误的</li><li>概率Agent为每个语句赋予一个0到1之间的数值作为其信念度</li></ul><p>一个Agent是理性的，当且仅当它选择能产生最高期望效用的行动，称为期望效用最大化</p><p>效用理论：Agent会偏好效用（utility）更高的状态</p><p>决策理论&#x3D;概率理论+效用理论</p><p>期望效用最大化（MEU）原则</p><p>逻辑断言与概率断言</p><ul><li>逻辑断言考虑的是要排除所有那些断言不成立的世界。</li><li>概率断言考虑的是各种可能世界的可能性有多大。</li></ul><h3 id="13-2-基本概率符号"><a href="#13-2-基本概率符号" class="headerlink" title="13.2 基本概率符号"></a>13.2 基本概率符号</h3><p>样本空间( Ω，omega的大写)：所有可能世界组成的集合，是互斥的，完备的</p><p>ω（omega的小写）表示样本空间中的一个样本，即ω是一个特定的可能世界</p><p>★公式1：概率基本公理：样本空间中的可能世界的总概率为1：ΣP(w)&#x3D;1</p><p>★公式2：事件&#x2F;命题：对任意命题f，P(f)&#x3D;Σ(w∈f) P(w)</p><p>★公式3：条件概率：P(a|b)&#x3D;P(a∪b)&#x2F;P(b)，注意可以使用链式规则</p><p>★概率密度函数 P(X&#x3D;x)&#x3D;lim(x-&gt;0) P(x&lt;&#x3D;X&lt;&#x3D;x+dx) &#x2F; dx</p><p>★公式4：概率公理：包含-排斥原理： P(A∩B) + P(A∪B) &#x3D; P(A) + P(B)</p><p>★全概率公式：</p><p>柯尔莫哥洛夫公理：公式1+公式4</p><p>无条件概率&#x2F;先验概率：不知道其它信息的情况下对命题的信念度</p><p>要素化表示，随机变量，概率分布</p><p>概率分布：所有可能的随机变量赋予概率值</p><p>联合概率分布：对多个随机变量中的每个变量发生的可能性进行概率赋值</p><p>使用完全联合概率分布作为“知识库”</p><p>归一化α</p><h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>独立性&#x2F;边缘独立性&#x2F;绝对独立性（a⊥b）【这个⊥符号有问题，应该两条竖线】</p><ul><li>P(a|b)&#x3D;P(a)</li><li>P(b|a)&#x3D;P(b)</li><li>P(a∪b)&#x3D;P(a)P(b)</li></ul><p>条件独立性（a⊥b | Z）定义如下</p><ul><li>任意x,y,z P(x,y | z) &#x3D; P(x | z) * P(y | z)</li><li>任意x,y,z P(x | y,z) &#x3D; P(x | z)</li></ul><p>联合概率规则</p><p>P(a∪b) &#x3D; P(a|b) * P(b) &#x3D; P(b|a) * P(a)</p><h3 id="贝叶斯规则"><a href="#贝叶斯规则" class="headerlink" title="贝叶斯规则"></a>贝叶斯规则</h3><p>贝叶斯公式：P(b|a) &#x3D; P(a|b) * P(b) &#x2F; P(a)</p><p>朴素贝叶斯：假设所有Effecti各自独立，公式如下：</p><p>P(Cause,Effect1,……,Effectn) &#x3D; P(Cause) * Π P(Effecti | Cause)</p><h2 id="第14章-概率推理"><a href="#第14章-概率推理" class="headerlink" title="第14章 概率推理"></a>第14章 概率推理</h2><p>★详细教程：</p><p><a href="https://www.cnblogs.com/USTC-ZCC/p/12786860.html">https://www.cnblogs.com/USTC-ZCC/p/12786860.html</a></p><p>贝叶斯网络（信度网&#x2F;概率网络&#x2F;因果网络&#x2F;知识图）</p><p>条件概率表（CPT）</p><p>链式规则：</p><p>P(x1,x2,……,xn)</p><p>&#x3D; P(xn | x1,x2,……,xn-1) * P(xn-1 | x1,x2,……,xn-2) * …… * P(x3 | x1,x2) * P(x2 | x1) * P(x1)</p><p>&#x3D; Π P(Xi | Xi-1 Xi-2 …… X1)</p><p>贝叶斯网络构建：由原因指向结果</p><p>贝叶斯网络计算公式：</p><p>P(x1,x2,……,xn) &#x3D; Π P (xi | parents(xi))</p><p>【很多年考题】贝叶斯网络计算</p><p>计算联合概率分布，</p><p>计算先验概率，</p><p>计算条件概率，</p><p>计算枚举精确推理（有查询变量，有隐藏变量，有证据变量）</p><p>近似推理（直接采样法）【我没掌握，似乎不重要？】</p><p>【2020期末】贝叶斯网络中的条件独立性</p><ul><li>（小班）经典的三种结构（同父，v型，顺序结构）</li><li>moral图只能确认独立性，不能排除非独立性</li><li>D-seperation适用（<a href="https://zhuanlan.zhihu.com/p/72011891">D-Separation：一种概率图结构独立性的判断方法 - 知乎</a>）</li></ul><p>D-seperation划分方法</p><p>碰撞点，观测集合</p><h2 id="第十五章-时间上的概率推理"><a href="#第十五章-时间上的概率推理" class="headerlink" title="第十五章 时间上的概率推理"></a>第十五章 时间上的概率推理</h2><p>马尔科夫假设：当前状态只依赖于有限的固定数量的过去状态</p><p>平稳性假设：转移概率相同</p><p>马尔可夫过程（一阶，二阶）</p><p>马尔科夫链（转移模型）</p><p>隐马尔科夫链（转移模型，传感器模型）</p><p>马尔可夫链的独立性：对于一阶马尔可夫链，不相邻即有独立</p><p>稳定分布：初始分布的影响随着时间的推移，变得越来越少</p><p>【怎么求稳态分布的概率？第∞天和第∞+1天，列二元方程】</p><p>应用：web链接分析，应用内程序的平稳分布</p><p>【2019，2020期末】隐马尔可夫链，序列概率，最可能的隐藏层</p><h2 id="第十八章-机器学习"><a href="#第十八章-机器学习" class="headerlink" title="第十八章 机器学习"></a>第十八章 机器学习</h2><p>机器学习：从数据中自动分析获得规律<strong>，</strong>并利用规律对未知数据进行预测的算法。</p><p>机器学习的分类：</p><ul><li>监督学习（有输入和输出，分类&#x2F;回归）</li><li>无监督学习（没有输出）</li><li>强化学习</li></ul><p>线性回归-参数学习</p><p>损失函数</p><p>训练集，测试集，k折交叉验证</p><p>判别方法&#x2F;生成方法</p><ul><li>判别方法直接学习判别函数𝑓(𝑋) 或者条件概率分布𝑃(𝑌|𝑋) 作为预测的模型，即判别模型。典型判别模型包括回归模型、神经网络、支持向量机和Ada boosting等。</li><li>生成模型从数据中学习联合概率分布𝑃(𝑋, 𝑌)（通过似然概率𝑃(𝑋|𝑌) 和类概率𝑃(𝑌) 的乘积来求取）。典型方法为贝叶斯方法、隐马尔可夫链</li></ul><p>过拟合&#x2F;欠拟合</p><ul><li>early stopping</li><li>数据集扩增</li><li>正则化方法</li><li>Dropout</li></ul><p>KNN（K近邻算法）</p><p>★【】朴素贝叶斯分类器</p><p>★【】决策树</p><p>【期末考试题】</p><p>熵：</p><p>信息增益：</p><h2 id="第十八章-人工神经网络"><a href="#第十八章-人工神经网络" class="headerlink" title="第十八章 人工神经网络"></a>第十八章 人工神经网络</h2><p>感知器算法</p><p>前向传播，反向传播</p><p>多层神经网络</p><p>前向传播，反向传播</p><p>【考题】</p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p>卷积神经网络，卷积核</p><p>【猜测考题】</p><p>计算卷积</p><p>卷积核，步长，卷积运算，特征图</p><p>计算池化</p><p>最大池化，平均池化，总和池化</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Note-CN</title>
      <link href="/2024/01/16/Note-CN/"/>
      <url>/2024/01/16/Note-CN/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-笔记"><a href="#计算机网络-笔记" class="headerlink" title="计算机网络-笔记"></a>计算机网络-笔记</h1><p>计科210X 甘晴void 202108010XXX</p><img src="/note-cn/note-cn.png" class="" title="计算机网络笔记"><h2 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h2><p>【注明】这一部分是A橙学长划的重点</p><p>第一章：分组交换和电路交换的比较</p><p>应用层：要看懂HTTP报文，知道cookie，持续连接非持续连接区别，邮件工作的过程，DNS  原理，后面的没空可以不看了</p><p>运输层： UDP和TCP比较，可靠数据传输的rdt不需要知道那么仔细，知道SR和GBN就可以，TCP要知道报文确认号序号，流量控制和拥塞控制有什么区别，拥塞控制算法</p><h2 id="1计算机网络和因特网"><a href="#1计算机网络和因特网" class="headerlink" title="1计算机网络和因特网"></a>1计算机网络和因特网</h2><h3 id="1-1-因特网"><a href="#1-1-因特网" class="headerlink" title="1.1 因特网"></a>1.1 因特网</h3><p>主机，端系统，通信链路，分组交换机，传输速率bps，分组，路由器，链路层交换机，路径（一个分组经过的链路和分组交换机）</p><p>因特网服务提供商ISP（InternetServiceProvider），传输控制协议TCP（TransmissionControlProtocol），网际协议IP（InternetProtocol），请求评论（RFC）</p><p>互联网是什么？节点和边，通过网络互联设备连接起来</p><p><strong>分布式应用以及为它提供通信服务的基础设施</strong></p><p>分布式应用程序，套接字接口</p><h3 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h3><p> 客户（client），服务器（server）， </p><p>CS模式，P2P模式</p><p>接入网，</p><p>采用网络设施的面向连接服务</p><h3 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h3><p>电路交换：频分复用FDM，时分复用TDM（独享）</p><p>分组交换（将长报文划分为较小的数据块）：虚电路网络，数据报网络</p><p>（电路交换会预留资源，分组交换不会）</p><p>分组交换机</p><p>存储转发传输（交换机开始向输出链路传输前必须先收到整个分组）：d(端到端)&#x3D;NL&#x2F;R,N表示中间路径数</p><p>★分组交换优点：共享性；坏处：丢包&#x2F;时延</p><p>★分组交换与电路交换的对比：</p><ul><li>提供了比电路交换更好的带宽共享</li><li>比电路交换更简单有效，实现成本更低</li></ul><p>包含计算</p><h3 id="1-4-分组交换的时延-丢包和吞吐量"><a href="#1-4-分组交换的时延-丢包和吞吐量" class="headerlink" title="1.4 分组交换的时延&#x2F;丢包和吞吐量"></a>1.4 分组交换的时延&#x2F;丢包和吞吐量</h3><p>节点总时延&#x3D;传输时延+传播时延+排队时延+处理时延【P25】</p><p>处理时延：微秒或更低</p><p>排队时延：毫秒到微秒</p><p>传输时延：分组推向链路，L&#x2F;R，分组长度&#x2F;链路带宽，毫秒到微秒</p><p>传播时延：链路到被接收，d&#x2F;s，物理链路长度&#x2F;传播速度，毫秒量级</p><p>车队类比</p><p>流量强度I&#x3D;La&#x2F;R,，所有分组由Lbit组成，R为传输速率，a为到达分组的平均速率</p><p>流量强度I不能大于1，I接近1时，平均排队时延趋向于无穷大</p><p>吞吐量，取决于瓶颈链路的传输速率</p><h3 id="1-5-协议层次与服务模型"><a href="#1-5-协议层次与服务模型" class="headerlink" title="1.5  协议层次与服务模型"></a>1.5  协议层次与服务模型</h3><p>协议栈，5个层次，应用层（报文），运输层（报文段），网络层（数据报），链路层（帧），物理层</p><p>应用层：HTTP,SMTP,FTP,DNS等；分组：报文</p><p>运输层：TCP,UDP（可靠性，流量控制，拥塞控制）；分组：报文段</p><p>网络层：IP；分组：数据报</p><p>服务</p><p>原语</p><p>服务访问点SAP</p><h2 id="2-应用层原理"><a href="#2-应用层原理" class="headerlink" title="2 应用层原理"></a>2 应用层原理</h2><h3 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h3><p>2.1.1 应用程序体系结构</p><p>客户-服务器体系结构，P2P体系结构（自扩展性）</p><p>2.1.2 数据通信</p><p>2.1.3 可供应用程序使用的运输服务</p><p>可靠数据传输，吞吐量（带宽敏感应用&lt;&gt;弹性应用），定时，安全性</p><p>2.1.4 因特网提供的运输服务</p><p>TCP：面向连接的服务，可靠的数据传送服务 ，拥塞控制机制</p><p>UDP：</p><p>安全套接字SSL（SecureSocketLayer）</p><h3 id="2-2-Web和Http"><a href="#2-2-Web和Http" class="headerlink" title="2.2 Web和Http"></a>2.2 Web和Http</h3><p>2.2.1 HTTP</p><p>超文本传输协议（HyperTextTransferProtocol）</p><p>HTTP，建立在TCP上，默认端口80，无状态协议</p><p>2.2.2 非持续连接和持续连接</p><p>非持续连接，持续连接（所有请求响应经一个单独TCP连接发送） </p><p>往返时间（RTT,RoundTripTime），总响应时间&#x3D;2*RTT+传输HTML文件的时间</p><p>2.2.3 HTTP报文格式</p><p>HTTP请求报文：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;somdir&#x2F;page.html HTTP&#x2F;1.1#方法，URL和HTTP版本字段Host: www.someschool.eduConnection: closeUser-agent: Mozilla&#x2F;5.0Accept-language: fr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法包括：GET,POST,HEAD,PUT,DELETE</p><p>HTTP响应报文：</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 200 OKConnection: closeDate: Tue, 18 Gug 2015 15:44:04 GMTServer: Apache&#x2F;2.2.3 (CentOS)Last-Modified: Tue, 18 Gug 2015 15:11:03 GMTContent-Length: 6821Content-Type: text&#x2F;html(data data ......)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>状态码包括</p><ul><li>200 OK</li><li>301 Moved Permanently</li><li>400 Bad Request</li><li>404 Not Found</li><li>505 HTTP Version Not Supported</li></ul><p>2.2.4 Cookie</p><p>HTTP是一个无状态协议，服务器不保存用户的信息。使用cookie可以让服务器标识一个客户，提供服务。cookie有以下4个组件：</p><ul><li>响应报文中的一个cookie首部行</li><li>请求报文中的一个cookie首部行</li><li>用户端系统中保留一个cookie文件，由浏览器管理</li><li>位于Web站点的一个数据库，记录用户信息</li></ul><p>2.2.5 Web缓存</p><p>Web缓存器（WebCache）也叫代理服务器（proxy server）</p><p>优先请求本地代理服务器，若得不到满足再请求</p><p>能够代表初始Web服务器满足HTTP请求。Web缓存器可以在存储器空间中保留最近请求过的对象的副本。使用Web缓存器可以大大减少对客户请求的响应时间，还能够大大减少一个机构的接入链路到因特网的通信量。</p><p>Web缓存器通常由ISP购买和安装</p><p>Web缓存器既是服务器又是客户</p><p>Web缓存器带来的一个问题是存放在缓存器中的副本可能不是最新的，因此需要有方式去证实请求的对象是最新的。解决：使用条件GET方法，在首部行中添加”If-Modified-Since”，这样只在指定日期后对象被修改过，才发送该对象。返回304NotModified表示未修改</p><p>2.2.* FTP </p><p>默认端口21</p><p>server主动向client的20号端口建立连接。</p><p>有状态协议</p><h3 id="2-3-因特网中的电子邮件"><a href="#2-3-因特网中的电子邮件" class="headerlink" title="2.3 因特网中的电子邮件"></a>2.3 因特网中的电子邮件</h3><p>默认端口 25</p><p>三个重要组成部分：用户代理，邮件服务器，简单邮件传输协议（SMTP,SimpleMailTransferProtocol）</p><p>过程：用户代理—-&gt;邮件服务器—-SMTP—-&gt;邮件服务器—-&gt;用户代理</p><p>SMTP（推协议）</p><p>SMTP是一个推协议，由发送邮件的服务器将文件发给接收邮件的服务器，接收邮件的用户是不能使用该协议获取接收到的邮件的。获取接收到的邮件使用的是邮件访问协议。流行的邮件访问协议有：POP3,IMAP,HTTP。</p><p>POP3（拉协议）</p><p>POP3协议简单，但功能有限。用户代理打开与邮件服务器的TCP连接后，POP3开始工作。POP3工作有三个阶段：</p><ul><li><p>特许：用户代理发送用户名和口令以鉴别用户。</p></li><li><p>事务处理：用户代理取回报文，对报文进行删除标记，取消删除标记，获取邮件的统计信息。获取报文有以下两种方式：下载并保留 || 下载并删除</p></li><li><p>更新：结束POP3会话，删除被标记为删除的报文。</p></li></ul><p>IMAP（拉协议）</p><p>使用POP3协议只能获取报文，不能在服务器上创建文件夹对报文进行管理。为了解决这个或一些其他问题，产生了IMAP协议。IMAP服务器把每个报文与一个文件夹联系起来，报文到达时与INBOX文件夹相关联，而收件人能够把邮件移到一个新的文件夹中，阅读，删除或是移动到别的文件夹。IMAP还提供了查询邮件的命令，且IMAP维护了IMAP会话的用户状态信息(文件夹的名字等)。另外，IMAP还允许用户代理获取报文某些部分的命令。这样当用户处于低带宽连接时，可以选择性的只取回(MIME)报文的一部分。</p><p>基于Web的电子邮件</p><p>今天，基于Web的邮件已经非常常见了。这种电子邮件，用户代理就是浏览器，用户和远程邮箱之间的通信通过HTTP进行。用户发送和获取电子邮件时，都通过HTTP协议在浏览器和邮件服务器之间进行报文传输，但是邮件服务器之间发送和接收报文仍然使用SMTP。</p><p>用户代理–HTTP–&gt;邮件服务器–SMTP–&gt;邮件服务器–HTTP–&gt;用户代理</p><h3 id="2-4-DNS：因特网的目录服务"><a href="#2-4-DNS：因特网的目录服务" class="headerlink" title="2.4 DNS：因特网的目录服务"></a>2.4 DNS：因特网的目录服务</h3><p>4.1 DNS概述与DNS服务</p><p>因特网上的主机可以使用多种方式标识。一种易于记忆的方式是主机名，而路由器所需要的标识则是更为具体的IP地址。将主机名转换到IP地址，就是域名系统DNS的任务。</p><p>DNS是由分层的DNS服务器实现的分布式数据库。</p><p>DNS是使主机能够查询分布式数据库的应用层协议。</p><p>（期中考试20分）DNS协议运行在★★★UDP★★★上，使用53端口。</p><p>（期中考试10分）A,NS,CNAME,MX分别是什么</p><p>除了进行主机名到IP地址的转换，DNS还提供了以下服务：</p><p>主机别名：一个主机除了规范主机名外，还可以有其他别名。通过DNS可以获取别名对应的规范主机名和IP地址。</p><p>邮件服务器别名：和主机别名相同，邮件服务器也可以使用别名，通过DNS获取规范主机名和IP地址。</p><p>负载分配：一个站点可能会被冗余分布在多台服务器上，有不同的IP地址。这些IP地址构成了一个IP地址集，DNS服务器可以在返回这些IP地址时循环改变次序，客户通常选择先返回的IP地址请求服务，这样通过更改返回IP地址的顺序，就能起到负载分配的作用。</p><p>4.2 DNS工作原理</p><p>使用单个DNS服务器有单点故障、通信容量，远距离集中(高时延)，维护等问题，因此DNS采用了分布式的设计方案。按照层次，DNS服务器分为三种：根DNS服务器；顶级域服务器；权威DNS服务器。除了以上三个层次外，还有一类重要的DNS服务器是本地DNS服务器。本地DNS服务器一般离主机很近，起到代理的作用。在进行DNS查询时，有两种查询方式：递归查询和迭代查询。通常，请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。</p><p>为了改善时延性能和减少报文传输，DNS还广泛使用了缓存技术。DNS服务器会缓存主机名&#x2F;IP地址对，一段时间后才丢弃缓存信息。</p><h3 id="2-5-P2P文件分发"><a href="#2-5-P2P文件分发" class="headerlink" title="2.5 P2P文件分发"></a>2.5 P2P文件分发</h3><p>【计算题P95】两个公式</p><p>使用P2P体系结构的网络应用对总是打开的基础设施服务器有最小的依赖。P2P体系结构具有内在自扩展性，无论有多少对等方，P2P体系结构的应用的文件分发时间都小于客户-服务器体系结构的应用。BitToreent是一种用于文件分发的流行P2P协议，以下是BitTorrent的部分功能原理。</p><p>在BitTorrent协议中，参与一个文件分发的所有对等方的集合称为一个洪流。洪流中的对等方互相下载等长度的文件块(典型长度256KB)。对等方刚进入洪流时没有块，一段时间后就持有了块，并可为其他对等方上载块。每个洪流有一个追踪器，当对等方加入洪流时，将向追踪器注册自己，并周期性通知追踪器自己仍在洪流中。</p><p>当一个对等方A加入洪流后，追踪器会给出一个对等方子集及这些对等方的IP地址，A可以从中选择临近的对等方建立TCP连接，交换块列表。选择向邻居请求哪些块使用的策略是最稀缺优先，首先请求邻居中副本最少的块，从而加快这些块的分发。而响应邻居的哪些请求则使用的是一种对换算法，优先响应前四个给A提供数据最高速率的邻居(他们被称为疏通)，并且还会每30s随机选择一个对等方B，如果B的速率够高，就把B换进前四位列表。这样对等方能够趋向于找到彼此的协调的速率上载。除了这五个对等方外，其他相邻的对等方不会收到A的块。这种激励机制被称为“一报还一报”。</p><h3 id="2-6-视频流和内容分发网"><a href="#2-6-视频流和内容分发网" class="headerlink" title="2.6 视频流和内容分发网"></a>2.6 视频流和内容分发网</h3><p>6.1 视频流</p><pre><code>    视频是一系列的图像，可以被压缩，通常用比特率来衡量质量。视频可以被压缩到不同的比特率，让用户根据网络带宽来选择观看的版本。对流式视频最重要的性能度量是平均端到端吞吐量，流式视频应用得到的平均吞吐量至少与压缩视频的比特率一样大。在HTTP流中，视频只是一个普通的文件。用户请求视频文件，将收到的字节进行缓存，一旦超过了预先设定的门限就开始播放，将字节处理成帧，并将这些帧解压缩展现在视频上。视频编码为不同比特率的版本经HTTP传输，被称为经HTTP的动态适应流(DASH)。使用DASH后，视频有不同版本存放在服务器中，服务器会有一个告示文件，提供每个版本的URL和比特率信息。客户可以根据可用带宽指定URL和一个字节范围，对视频数据块请求。</code></pre><p>6.2 内容分发网</p><pre><code>    因特网视频公式每天都需要向百万计的用户发送数据，如果在数据中心存储所有视频，会产生很大的问题。主要有三个问题：1.如果用户离数据中心太远，很可能产生停滞时延。2.流行的视频可能经相同链路发送多次，浪费带宽。3.单个数据中心出现单点故障，就不能分发视频流了。为了解决分发视频数据的问题，，几乎所有的视频流公司都使用内容分发网CDN。CDN管理分布在多个位置的服务器，将用户请求定位到能提供最好服务的CDN位置。CDN包括专用CDN(内容提供商自己的)和第三方CDN(代表多个内容提供商分发内容)。CDN通常集群部署。每个集群只保留一些视频，当用户请求视频时，如果集群中没有该视频，再从其他集群或中心仓库拉取视频到集群，并在本地存储一个副本。CDN的部署通常采用两种原则：</code></pre><p>深入：在全球接入ISP中部署服务器集群，靠近端用户。</p><p>邀请做客：在少量关键的位置建造大集群，邀请ISP做客。</p><pre><code>使用CDN，用户的请求需要被重定向到CDN服务器，这通常是由DNS进行截获和重定向的。DNS检测到URL中有video以及内容提供商的名字，就返回一个CDN域的主机名，用户将再次发送请求到这个CDN域的DNS系统，并得到CDN节点的IP地址。CDN的集群选择策略是CDN部署的核心，一种简单的策略是指派用户到地理上最为临近的集群，也有周期性实时测量集群和用户到集群时延和丢包性能来选择集群的策略。</code></pre><h3 id="2-7-套接字编程"><a href="#2-7-套接字编程" class="headerlink" title="2.7 套接字编程"></a>2.7 套接字编程</h3><pre><code>    网络应用程序有两类，一种使用协议标准(如RFC)定义的操作实现的，另一种是使用专用的应用层协议。如果是开发专用的网络应用程序，应该避免使用熟知端口号。另外一个实现网络应用程序的问题是，该选择TCP还是UDP。这两种协议有各自的特点。以下是分别使用UDP和TCP实现的简单客户-服务器程序(Python实现)。</code></pre><p>7.1 UDP套接字编程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Client</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    serverName <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token comment">#本机IP</span>    serverPort <span class="token operator">=</span> <span class="token number">12000</span><span class="token comment">#端口</span>    clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">)</span><span class="token comment">#IPV4,UDP</span>    message <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Input lowercase sentence:"</span><span class="token punctuation">)</span>    clientSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>message<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>    modifiedMessage<span class="token punctuation">,</span>serverAddress <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>modifiedMessage<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># Server</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    serverPort <span class="token operator">=</span> <span class="token number">12000</span>    serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_DGRAM<span class="token punctuation">)</span>    serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>    message<span class="token punctuation">,</span>clientAddress <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>    modifiedMessage <span class="token operator">=</span> message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    serverSocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>modifiedMessage<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>clientAddress<span class="token punctuation">)</span> <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7.2 TCP套接字编程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Client</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    serverName <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span>    serverPort <span class="token operator">=</span> <span class="token number">12000</span>    clientSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">)</span><span class="token comment">#IPv4,TCP</span>    clientSocket<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#建立连接</span>    sentence <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Input lowercase sentence:"</span><span class="token punctuation">)</span>    clientSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>sentence<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#已建立连接，不需要地址了</span>    modifiedSentence <span class="token operator">=</span> clientSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"From Server:"</span><span class="token punctuation">,</span>modifiedSentence<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    clientSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Server</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    serverPort <span class="token operator">=</span> <span class="token number">12000</span>    serverSocket <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">)</span>    serverSocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>serverPort<span class="token punctuation">)</span><span class="token punctuation">)</span>    serverSocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#欢迎套接字，等待建立连接</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The server is ready to receive"</span><span class="token punctuation">)</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        connectionSocket<span class="token punctuation">,</span>addr <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#客户专用套接字</span>        sentence <span class="token operator">=</span> connectionSocket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>        modifiedSentence <span class="token operator">=</span> sentence<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>modifiedSentence<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        connectionSocket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-传输层"><a href="#3-传输层" class="headerlink" title="3 传输层"></a>3 传输层</h2><h3 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h3><p>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能。运输层协议是在端系统实现的，将应用程序的报文转换为较小的块，加上运输层首部生成运输层分组，称为报文段，将报文段交给网络层，由网络层发送到目的地。</p><p>因特网提供了两种可用的运输层协议：UDP(用户数据报协议)，TCP(传输控制协议)。UDP提供不可靠服务，而TCP提供面向连接的可靠数据传输，还提供拥塞控制。网络层的协议即网际协议IP，提供的是不可靠服务，不确保报文段的交付和按序交付，因此本章主要讨论的一个问题是TCP如何提供可靠数据传输，另一个主要讨论的问题是TCP如何实现拥塞控制。</p><p>TCP:拥塞控制，流量控制，建立连接</p><p>UDP:没有在IP之上提供更多服务（IP主机到主机，UDP进程到进程）</p><p>都不提供延时与带宽保证，数据交付和交错检查（UDP仅能提供的）</p><h3 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h3><p>运输层从紧邻其下的网络层接收报文段。运输层负责将报文段进程交付给主机上运行的适当进程。一个进程有一个或多个套接字，运输层实际上是将数据交给中间的套接字。接收主机可能同时有多个套接字，因此每个套接字都有一个唯一的标识符。为了将运输层报文段定向到合适的套接字，运输层报文段有一些字段，包含了套接字的标识符。</p><p>多路分解：（运输层→套接字，向上）通过这些字段，将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p><p>多路复用：（套接字→网络层，向下）从不同套接字中收集数据块，将数据块封装并添加首部信息产生报文段，发送到网络层的过程工作称为多路复用。</p><p>每个套接字都有唯一的标识符，每个报文段都有特殊字段来指示该报文要交付到的套接字。套接字需要使用端口号进行标识。端口号是一个16bit的数，其中0-1023为熟知端口号。保留给HTTP,FTP等熟知的应用层协议。</p><p>UDP套接字：二元组标识，包含一个目的IP地址(标识主机)和一个目的端口号(标识具体的套接字)。接收主机的运输层收到报文段后，通过首部中的目的端口号，将报文段定向到相应的套接字。</p><p>TCP套接字：四元组(源IP地址，源端口号，目的IP地址，目的端口号)标识。这四个值标识了一个连接，接收主机通过四个值将报文段定向到对应套接字。由于TCP是面向连接的，不同的源IP地址和源端口号与同一个目的IP的同个目的端口号建立的是不同的连接，使用的也是不同的套接字。但是初始创建连接时，连接还没有建立，因此使用的是同一个套接字(欢迎套接字)。连接建立后，接收端进程将创建一个新的套接字供该连接使用。</p><h3 id="3-3-无连接运输UDP"><a href="#3-3-无连接运输UDP" class="headerlink" title="3.3 无连接运输UDP"></a>3.3 无连接运输UDP</h3><p>UDP是无连接的运输，只在IP的基础上进行复用和分解，并增加了少量的差错检测。UDP不能提供可靠的传输服务，但有以下优点：</p><ul><li><p>控制更加精细。采用UDP时，UDP会将数据打包直接传递给网络层，不像TCP存在拥塞控制机制，发送可能受到遏制。</p></li><li><p>无需建立连接。UDP不会引入建立连接的时延。因此DNS就是运行在UDP之上的。</p></li><li><p>无连接状态。UDP不维护连接状态。而TCP则需要维护包括接收和发送缓存，拥塞控制参数和确认号等连接状态。</p></li><li><p>分组首部开销小。仅有8字节。</p></li></ul><p>除了不能提供可靠传输，UDP还可能导致其他问题，因为缺乏拥塞控制，UDP可能导致发送方接收方之间的高丢包率，挤垮TCP会话。</p><p>UDP报文段由源端口号，目的端口号，长度和校验和组成，每个字段2字节，共8个字节。其中的校验和提供了差错检测功能，因为链路层协议可能没有提供差错检测，而报文段的传输可能经过一条没有使用差错检测协议的链路。因此UDP在端到端基础上，在运输层提供差错检测，这称为端到端原则。</p><p>校验：</p><p>发送方：对报文段中所有16比特字的和（任何时候若溢出要回滚），进行反码运算。</p><p>接收方：若无差错，和将是0xFFFF</p><h3 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h3><p>可靠数据传输协议（ReliableDataTransferProtocol）</p><p>可靠传输问题不仅在运输层出现，也在链路层及应用层出现。实现可靠传输服务是可靠数据传输协议的任务。一般情况下，都是在下层协议提供不可靠数据传输(udt)下，建立可靠数据传输协议。由于可靠数据传输(rdt)不仅适用于运输层，收发端交换的数据以下称为分组，而不是运输层的报文段。</p><h4 id="3-4-1-构造可靠数据传输协议（rdt1-0-2-0-2-1-2-2-3-0）"><a href="#3-4-1-构造可靠数据传输协议（rdt1-0-2-0-2-1-2-2-3-0）" class="headerlink" title="3.4.1 构造可靠数据传输协议（rdt1.0,2.0,2.1,2.2,3.0）"></a>3.4.1 构造可靠数据传输协议（rdt1.0,2.0,2.1,2.2,3.0）</h4><p>①经完全可靠信道的可靠数据传输 rdt1.0</p><p>经完全可靠信道的可靠数据传输，接收与发送方不需要进行任何通信。发送方只需接收高层的数据，产生分组并发送到信道中，而接收方只需要从信道接收分组，从分组中取出数据交给上层。</p><p>②经具有比特差错信道的可靠数据传输 rdt2.0</p><p>实际情况下，底层信道的模型是会出现比特差错的模型，在分组的传输，传播或缓存的过程中都可能出现比特差错。为了处理差错，接收方需要对接收到的分组进行确认，发出肯定确认告知发送方分组被接收，发出否定确认告知发送方重发分组。基于这种重传机制的可靠数据传输协议称为自动重传协议(ARQ)。ARQ协议需要三种功能处理比特差错的情况：</p><ul><li><p>差错检测：通过检验和字段，使接收方能够检测到比特差错。</p></li><li><p>接收方反馈：接收方需要进行肯定确认(ACK)，否定确认(NAK)，只需要一个bit的分组就可以进行确认。</p></li><li><p>重传：接收方接收到有差错的分组时，发送方重传分组。</p></li></ul><p>采用以上这种重传机制，发送方在发送分组后，将等待接收方的确认分组，决定是否重传还是传输新的分组。由于这种行为，rdt2.0这样的协议被称为停等协议。</p><p>③rdt2.1</p><p>由于信道本身可能出现差错，因此必须考虑确认分组ACK或NAK出现差错的情况。在这种情况下，发送方不知道接收方是否正确收到了分组。解决该问题的方式是，如果发送分组不能确定接收方是否接收到了正确的分组，就重新发送分组。这种方式给信道引入了冗余分组。但是接收方还需要知道接收到的是新的分组还是重传的分组，因此对于分组需要进行一个序号，需要只需要为0或1，让接收方能够区别分组是否和上一个接收到的分组一样就可以。</p><p>④rdt2.2</p><p>用对前一分组的正向确认替代对当前分组的反向确认（用ACK0替代NAK1回应P1）</p><p>这个方法没有NAK状态，只有ACK。</p><p>⑤经具有比特差错的丢包信道的可靠数据传输 rdt3.0</p><p>除了比特差错，丢包也是常见的一种情况。解决丢包的方式和处理比特差错一样，如果没有接收到确认分组(发送的分组丢失或确认的ACK丢失，又或者只是分组或ACK延时)，就重传数据分组。新的问题是，到底等待多久才能判断分组丢失。这个时间至少大于一个往返时延，要根据情况设置。为了实现以上这种基于时间的重传机制，还需要一个倒计数定时器，发送方每发送一个分组就启动一个定时器，定时器超时就进行重传。解决冗余分组的方式则和rdt2.0相同。因为分组序号在0和1之间交替，rdt3.0也被称为是比特交替协议。</p><p>可以对抗丢失&#x2F;出错</p><h4 id="3-4-2-流水线可靠数据传输协议"><a href="#3-4-2-流水线可靠数据传输协议" class="headerlink" title="3.4.2 流水线可靠数据传输协议"></a>3.4.2 流水线可靠数据传输协议</h4><p>以上所形成的以停等协议为核心的可靠数据传输协议是功能正确的，但是在性能方面存在大的问题，因为发送方的信道利用率太低了，大量时间都在等待确认分组。而确认分组至少需要一个往返时延RTT才能回到发送方，还要加上协议处理时间和中间路由器的时延。这个性能问题的解决办法就是不以停等方式运行，允许发送方发送多个分组。例如发送方可以发送三个分组后再等待确认，这样的方式被称为流水线。不过，在提升性能的同时，采用流水线也会带来新的问题。</p><p>必须增加序号范围，因为输送中的分组有多个。<br>发送方和接收方需要缓存多个分组。<br>需要处理丢失，损坏及延时过大的分组。两种基本方法是：回退N步；选择重传。</p><h4 id="3-4-3-回退N步-GBN"><a href="#3-4-3-回退N步-GBN" class="headerlink" title="3.4.3 回退N步(GBN)"></a>3.4.3 回退N步(GBN)</h4><p>在回退N步协议GBN中，允许发送方发送多个分组，不需等待确认，但是未确认的分组数不能超过某个最大允许数N。定义基序号base为最早未确认分组的序号，下一个序号nextseqnum为下一个待发分组的序号，则：</p><p>GBN协议也常被称为滑动窗口协议。分组的序号在分组首部的字段(k位)，范围为0-2^k-1。GBN发送方响应三种事件：</p><p>上层调用：窗口未满，则发送分组，否则告知上层。上层可能过一会儿再试，也可能发送方直接把上层数据缓存。<br>接收ACK：GBN协议中，对分组的确认方式为累积确认。接收到n的ACK，则序号小于等于n的分组都被确认接收。<br>超时：如果出现超时，重传所有已发送但未被确认过的分组。GBN协议中只有一个定时器，最早发送且未被确认的分组启动计时器，接收到确认分组则重启计时器。<br>GBN协议中，接收方会丢弃所有失序的分组，因为发送方会重传这些分组。直接丢弃这些分组，接收缓存简单，不需要缓存失序分组，接收方唯一需要维护的信息就是下一个按序接收的分组的序号。</p><h4 id="3-4-4-选择重传-SR"><a href="#3-4-4-选择重传-SR" class="headerlink" title="3.4.4 选择重传(SR)"></a>3.4.4 选择重传(SR)</h4><p>如果采用GBN协议，一旦最早发送的未确认分组超时，就需要从该分组开始重传，且接收方接收到的不按序的分组都会被丢掉。在信道差错率增加，时延很大的情况下，GBN可能大量重传分组。选择重传协议SR改进了这一点，只让发送方重传可能出错的分组。接收方将缓存失序的分组，并逐个对分组进行确认，连续的几个分组都收到后一起交付给上层。而发送方的每一个分组都有自己的定时器，超时后只重传一个分组，如果收到了最小未收到确认的分组的对应ACK，就将窗口重新移动到具有最小序号的未确认分组处。</p><p>对于已收到的那些分组，接收方会重新进行确认，这是有必要的，否则发送方可能停留在一个固定的窗口(因为不进行累积确认了，不重新确认窗口就不移动了)。</p><p>另外，考虑到序号是有限的，发送方与接收方窗口的不同步会导致严重的问题。例如，假设序号只有0,1,2，一种情况是正常的按照0,1,2,0来发送分组，另一种情况是分组0的ACK丢失了，发送次序是0,1,2,0(重传0)，因为有这两种不同的情况，接收方无法确认接收到的分组是重复发送的还是新的分组。因此必须限制窗口的大小，避免这种情况的发生。窗口长度必须小于或等于序号空间大小的一半。这样假设发送方没有收到正确的ACK，窗口不移动，接收方接收到了分组，一直向后移动，最后的结果就是发送方的窗口占了一半序号，接收方的窗口占了一半的序号，接收方的窗口最大值刚好停在发送方的窗口最小值前面，而不会发生序号重复。</p><h3 id="3-5-面向连接的传输：TCP"><a href="#3-5-面向连接的传输：TCP" class="headerlink" title="3.5 面向连接的传输：TCP"></a>3.5 面向连接的传输：TCP</h3><p>面向连接，全双工（两方都可以同时收发），三次握手确定连接，通过连接发送数据</p><p>TCP连接建立后，应用进程就可以互相发送数据了。客户进程通过套接字将数据交给TCP，TCP将数据存储到连接的发送缓存中，接下来TCP会从发送缓存中取出数据交给网络层。TCP可取出并添加到报文段的数据大小受限于最大报文长度MSS，而MSS又通常根据最大链路层帧长度(最大传输单元MTU)来设置，MSS要保证一个报文段加上TCP&#x2F;IP首部长度(40字节)适合链路层帧。以太网和PPP链路层协议都有1500字节的MTU，因此MSS的典型值为1460字节。TCP接收端接收到报文段，将数据放到接收缓存中，应用程序从该缓存中读取数据。</p><p>根据以上的讨论，TCP连接的组成包括：一台主机上的缓存，变量和与进程连接的套接字，另一台主机上的缓存，变量和与进程连接的套接字。</p><p>TCP报文结构</p><p>序号和确认号</p><p>发送的ACK是我期望从对方那边得到的期望序号</p><p>3.5.3 往返时间的估计与超时</p><ul><li>EstimatedRTT &#x3D; (1-a) EstimatedRTT + a SampleRTT</li><li>a推荐值取1&#x2F;8</li><li>DevRTT  &#x3D; (1-b) DevRTT + b | SampleRTT - EstimatedRTT |</li><li>b推荐值0.25</li><li>TimeoutInterval &#x3D; EstimatedRTT  + 4 DevRTT</li></ul><p>可靠数据传输 使用单一重传定时器</p><p>超时间隔加倍</p><p>快速重传：监测到3个冗余ACK（期望序号比应该的ACK高）就执行快速重传，比超时重传要早</p><p>产生TCP的ACK的建议（书P163）</p><p>3.5.5 流量控制</p><p>接收窗口（receive window）由发送方维护</p><p>接受方接收到报文段后，将报文段存放到接收缓存当中，应用进程从中取出数据。如果应用程序读取的速度较慢，而发送方发送的数据太多太快，就会导致接收缓存溢出。因此TCP提供了流量控制服务，使发送方的发送速率与接收方应用程序的读取速率匹配。这与拥塞控制很相似，但是完全是出于不同的原因。</p><p>TCP通过让发送方维护一个称为接收窗口的变量来进行流量控制。接收窗口表示接收方可用缓存的大小。发送方需要维护两个变量：</p><p>lastbyteread：读出的最后一个字节<br>lastbyterecv：已到达接收缓存的最后一个字节<br>不允许接收缓存溢出，则lastbyterecv-lastbyteread&lt;&#x3D;rcvbuffer。则接收窗口为：</p><p>rwnd&#x3D;rcvbuffer-[lastbyterecv-lastbyteread]</p><p>rwnd是一个动态的值。在起始时，rwnd&#x3D;recvbuffer，此后接收主机会维护该值，并将其发给发送主机，而发送主机需要进行如下的控制：</p><p>lastbytesent−lastbyteacked&lt;&#x3D;rwnd</p><p>为了避免发送主机收到rwnd&#x3D;0后被阻塞，如果接收窗口为0，发送主机将发送一个只有一个字节的报文段，接收主机将会回发确认，并在确认报文中包含一个新的非0rwnd值。</p><p>TCP提供了以上的流量控制服务，UDP是不提供这样的服务的。因此如果使用UDP，进程从缓存中读取报文段的速度不够快，缓存将会溢出，并丢失报文段。</p><p>3.5.6 TCP连接管理</p><p>TCP建立：三次握手</p><p>两次连接的问题：维持虚假半连接，接收旧数据</p><p>TCP结束：四次挥手</p><h3 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6 拥塞控制原理"></a>3.6 拥塞控制原理</h3><p>流量控制&lt;&gt;拥塞控制，相同点：都是对发送方进行遏制 </p><ul><li><p>流量控制：发送方的发送速率与接收方的读取速率相匹配，以取消出发送方使接收方缓存溢出的可能性</p></li><li><p>拥塞控制：避免网络拥堵</p></li></ul><p>3.6.1 拥塞原因与代价</p><p>通常出现拥塞有以下几种情况：</p><ul><li><p>（情况1：两个发送方和一台具有无穷大缓存的路由器）当发送速率超过吞吐量时，平均排队分组数不断增长，源与目的之间的时延也变为无穷大(假设不停发送，有无限大的缓存)。</p></li><li><p>（情况2：两个发送方和一台具有有限缓存的路由器）当缓存已满，部分分组被丢弃，这将引起发送方的重传，此外，提前发生超时还可能导致发送方重传没有丢失的分组。</p></li><li><p>（情况3：4个发送方和具有有限缓存的多台路由器及多跳路径）在有许多跳的情况下，不同的链路中不同连接的载荷不同。</p></li></ul><p>从以上几种情况来看，由于拥塞丢弃分组产生了以下的代价：</p><ul><li>分组的到达速率接近链路容量时，分组经历巨大的排队时延</li><li>发送方必须重传以补偿因为缓存溢出而丢弃的分组</li><li>发送方在遇到大时延时进行的不必要重传会引起路由器利用链路带宽来转发不必要的分组副本</li><li>一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组的传输容量最终被浪费掉了</li></ul><p>3.6.2 拥塞控制方法</p><p>端到端拥塞控制：端系统自己来观察，网络层不提供信息</p><p>网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显式反馈信息</p><p>ATM ABR </p><p>RM(资源管理)信元：NI位（轻微拥塞指示），CI位（拥塞指示），ER字段（中间路由器将自己可提供带宽写入）</p><h3 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h3><p>当出现了网络拥塞时，TCP应该降低发送速率，进行拥塞控制。实现这样的控制，有三个问题需要解决。</p><p>TCP发送方如何感知到与目的地之间的路径上存在拥塞，或是不存在拥塞<br>TCP如何限制其向连接上发送流量的速率<br>采用什么算法改变发送速率<br>下面逐个解决以上的问题。</p><p>1.拥塞检测与速率的确定</p><p>当发生拥塞时，路径上的路由器缓存溢出，就会引起丢包。对于发送方而言，丢包导致的是出现超时和收到3个冗余ACK。如果发生了这两种情况，就表示发生了拥塞，就应该减小发送速率。这就解决了拥塞检测的问题。在没有拥塞时，为了充分利用所有可用的带宽，TCP发送方还应该可以加快发送的速率。当TCP发送方接收到确认报文段ACK时，就认为一切顺利，网络不拥塞，可以增加发送速率。</p><p>2.限制速率</p><p>TCP采用了一个拥塞窗口cwnd来限制发送速率。注意这与流量控制相似但是不同。发送方未被确认的数据量不会超过cwnd与rwnd的最小值，即LastByteSent-LastByteAcked&lt;&#x3D;min{rwnd，cwnd}。由于此处仅探讨拥塞控制，先假设接收缓存无限大，这样发送速率就只与cwnd有关。通过cwnd的值，就可以调整向连接发送数据的速率了。</p><p>3.TCP拥塞控制算法</p><p>解决了上面两个问题，只要使用特定的算法控制cwnd就可以实现拥塞避免了。TCP拥塞控制算法包括三个部分：慢启动；拥塞避免；快恢复。</p><p>慢启动</p><ul><li>起始时，cwnd的值以一个MSS开始，每当一个报文被确认，就增加一个MSS（对每个ACK都将cwnd增加一个MSS），故相当于*2</li><li>出现超时丢包：cwnd设置为1，慢启动阈值ssthresh值设置为检测到拥塞时的cwnd&#x2F;2，重新开始慢启动。</li><li>cwnd达到ssthresh：结束慢启动，进入拥塞避免模式</li><li>出现三个冗余ACK：ssthresh&#x3D;cwnd&#x2F;2，cwnd&#x3D;ssthresh+3MMS，结束慢启动，进入快速恢复模式</li></ul><p>拥塞避免</p><ul><li>收到上一组全部cwnd的报文，增加一个MSS（线性加）</li><li>出现超时丢包：与慢启动的反应相同，返回并重新开始慢启动</li><li>出现三个冗余ACK：ssthresh&#x3D;cwnd&#x2F;2，cwnd&#x3D;ssthresh+3MMS，结束拥塞避免，进入快速恢复模式</li></ul><p>快速恢复</p><ul><li>对于每个冗余的ACK，cwnd++，在对丢失报文段的ACK到达后，cwnd&#x3D;ssthresh，进入拥塞避免模式</li><li>出现超时丢包，与慢启动的反应相同，返回并重新开始慢启动</li></ul><p>TCP Tahoe（丢包全部按超时处理，进入慢启动）</p><p>TCP Reno(含快速恢复)</p><img src="/note-cn/cn-2.png" class="" title="图片来自中科大郑烇老师的PPT"><p>早期的TCP版本Tahoe没有快恢复机制，无论是收到冗余ACK还是丢包，都直接将cwnd设置为1。TCP的较新版本TCP Reno 则加入了快恢复机制。现在已有Reno的许多变种，例如Vegas，该算法在分组发生丢失之前检查源与目的地之间的拥塞，当检测出快要发生的分组丢失时(通过RTT的变化)，线性降低发送速率。</p><p>7.2 对TCP吞吐量的宏观描述</p><p>有了TCP的拥塞控制算法，可以考虑长期存活的TCP连接的吞吐量了。</p><p>当窗口长度是w，往返时间为RTT，TCP的发送速率大约是W&#x2F;RTT，在一个窗口内发送了w后，收到前一半发送的分组的ACK，因此发送速率约为W&#x2F;RTT。不考虑慢开始阶段(指数增长，很快结束)，发生丢包时，假设速率减半，再增加到W&#x2F;RTT。在以上情况下，TCP的速率重复从W&#x2F;2RTT到W&#x2F;RTT的过程，在两个值之间线性增长，可以得出一个高度理想化的TCP稳态动态性模型：</p><p>一条连接的平均吞吐量 &#x3D; 0.75 * W &#x2F;RTT</p><p>在高带宽路径中，结合MSS和丢包率L，可以得出一条TCP连接的吞吐量公式：</p><p>一条连接的平均吞吐量 &#x3D; 1.22 * MSS &#x2F; (RTT * sqrt(L) )</p><p>7.3 公平性</p><p>可以在吞吐量图上进行演示</p><p>如果有多条TCP连接，通过同一段瓶颈链路，TCP趋于给竞争的多条TCP连接提供平等的带宽共享。书上给出了理想化的证明，在连接有相同MSS和RTT的情况下，公平性是可以保证的。</p><p>现实中存在的不公平挑战：</p><ul><li>多媒体应用使用UDP连接压制TCP流量</li><li>Web浏览器常使用并行连接传输多个对象</li></ul><p>7.4 明确拥塞通告</p><p>拥塞控制的另一类是网络明确向TCP双方发送拥塞信号，这种形式的网络辅助拥塞控制称为明确网络拥塞控制通告ECN。这种形式下，路由器使用一种ECNbit指示该路由器正在经历拥塞，并将该标记携带在IP数据报中，发送给目的主机，再由目的主机告知源主机，实现拥塞控制。</p><p>总结</p><img src="/note-cn/cn-3.png" class="" title="图片来自中科大郑烇老师的PPT"><img src="/note-cn/cn-4.png" class="" title="图片来自中科大郑烇老师的PPT"><h2 id="4-网络层：数据平面"><a href="#4-网络层：数据平面" class="headerlink" title="4 网络层：数据平面"></a>4 网络层：数据平面</h2><h3 id="4-1-导论"><a href="#4-1-导论" class="headerlink" title="4.1 导论"></a>4.1 导论</h3><p>路由（控制平面，全局）&lt;&gt;转发（数据平面，局部）</p><p>传统方式：基于目标地址+转发表</p><p>SDN方式：基于多个字段+流表</p><p>保证：服务模型，带宽，丢失，保序，延迟，拥塞反馈</p><h3 id="4-2-路由器工作原理"><a href="#4-2-路由器工作原理" class="headerlink" title="4.2 路由器工作原理"></a>4.2 路由器工作原理</h3><p>路由器结构组件（4个）：</p><ul><li>输入端口，交换结构，输出端口，路由选择处理器</li></ul><p>输入端口处理和基于目的地的转发：最长前缀匹配规则</p><p>“匹配+动作”抽象</p><p>交换结构：</p><ul><li>经内存交换：由CPU（路由选择处理器）直接控制</li><li>经总线交换：输入端口经一根共享总线将分组直接传送到输出端口</li><li>经互联网络交换：纵横式交换机</li><li>内存&#x2F;总线一次只能处理一个，纵横式只要彼此输出端口不同，一次可以处理n个</li></ul><p>交换速率：N倍输入&#x2F;输出端口速率，否则会成为瓶颈</p><p>输出端口处理</p><p>何处出现排队：输入排队，输出排队</p><ul><li><p>输入排队：线路前部阻塞（HOL）：由于队列前面的受到竞争而阻塞，后面的即使不存在竞争也要等待</p></li><li><p>输出排队：弃尾，主动队列管理（AQM）</p></li></ul><p>多少缓存？</p><ul><li><p>缓存数量B&#x3D;平均往返时延RTT*链路容量C（少量TCP流量）</p></li><li><p>B&#x3D;RTT*C&#x2F;sqrt(N) （大量TCP流量，N条）</p></li></ul><p>分组调度：FIFO，优先权排队（同一优先权分组之间使用FIFO，另：非抢占式优先权排队），循环和加权公平排队（）</p><h3 id="★4-3-网际协议：IPV4，寻址，IPV6及其他"><a href="#★4-3-网际协议：IPV4，寻址，IPV6及其他" class="headerlink" title="★4.3 网际协议：IPV4，寻址，IPV6及其他"></a>★4.3 网际协议：IPV4，寻址，IPV6及其他</h3><p>★IPv4数据报格式</p><p>【补充】</p><p>★IPv4数据报分片</p><p>MTU（最大传送单元）</p><p>标识，标志（最后为0，其余为1），片偏移（计算题）</p><p>★IPv4编址（地址协议）</p><p>一个IP地址与一个接口（主机与物理链路的边界）相关联，而不是该接口的主机或路由器</p><p>子网划分【考题：计算】</p><ul><li>网络地址（子网掩码确定的子网地址，后面部分全为0）</li><li>主机地址（在网络地址和广播地址之间）</li><li>广播地址（子网掩码确定的子网地址，后面部分全为1）</li></ul><p>（不考）特殊IPv4地址：</p><ul><li>默认路由：0.0.0.0</li><li>环回地址：127.0.0.0&#x2F;8（测试IP协议栈是否正常）</li><li>链路本地地址：169.254.0.0&#x2F;16</li></ul><p>（不考）地址分类（已经被淘汰了）</p><ul><li>A类地址（N.H.H.H）默认子网掩码（255.0.0.0）</li><li>B类地址（N.N.H.H）默认子网掩码（255.255.0.0）</li><li>C类地址（N.N.N.H）默认子网掩码（255.255.255.0）</li></ul><p>无类别域间路由选择（CIDR）</p><ul><li>a.b.c.d&#x2F;x前x最高比特构成IP地址的网络部分（网络前缀&#x2F;前缀）</li></ul><p>路由聚合&#x2F;地址聚合&#x2F;路由摘要：使用单个网络前缀通告多个网络的能力（书P221案例，通过申明更长的前缀，可以实现搬家的效果）</p><p>★动态主机配置协议（DHCP，DynamicHostConfigurationProtocal）</p><p>4个步骤【补充】</p><ul><li>DHCP发现报文</li><li>DHCP提供报文</li><li>DHCP请求报文</li><li>DHCP ACK报文</li></ul><p>★网络地址转换NAT（NetworkAdressTranslation）</p><p>10.0.0.0&#x2F;8这类地址被保留用于专用网络，仅在给定的网络中才有意义。</p><p>NAT自己运行一个DHCP服务器给子网用户分IP地址，并从ISP的DHCP服务器得到自己的IP地址。</p><p>NAT转换表（WAN端，LAN端）</p><p>NAT缺点 ：</p><ul><li>（书上）服务器进程在周知端口号上等待入请求</li><li>（书上）P2P对等方在充当服务器时需要接受入连接</li><li>（书上）违背IP设计理念，破坏端到端模型</li><li>延迟增加，</li><li>应用限制</li><li>端口限制（端口数量有限）</li><li>单点故障</li><li>未标准化</li><li>突破NAT穿越问题很麻烦</li></ul><p>（不考）分类</p><ul><li>FullCone NAT（只要知道内部主机的IP和Port，就可以发送数据包）IP和端口都不限制</li><li>Restricted  Cone NAT（只有内网主机主动请求过的外部主机，该外部主机可以使用自己的IP+任意端口，可以向内网主机发送）限制了IP不限制端口</li><li>Port Restricted  Cone NAT（只有内网主机主动请求过的外部主机，该外部主机可以使用自己的IP+自己的端口，可以向内网主机发送）限制了IP+端口</li><li>Symmetric NAT（只有收到内网主机发送的数据才能往回发送，无法实现UDP-P2P通信）</li></ul><p>（不考）NAT穿越</p><ul><li><p>中继，逆向链接，</p></li><li><p>UDP打洞（QQ的原理，A与B连接S进行注册，A向B通信时，A向S通信，要求B向S提供连接，一旦都打开，A可直接与B通信）</p></li></ul><p>（老师给出）NAT的问题</p><ul><li>结构上不合理（与IP提供端到端可达性相悖）；单点故障；没有标准化；突破NAT穿越问题很麻烦；NAT不等同于防火墙；端口号限制</li></ul><p>IPv6</p><p>IPv6数据报格式：版本，流量类型，流标签，有效载荷长度，下一个首部，跳限制，源地址，目的地址，数据</p><p>★注意：IPv6地址共128bit，IPv6不允许在中间路由器上进行<strong>分片&#x2F;重新组装</strong>，并因此取消了<strong>首部检验和</strong>，同时取消了<strong>选项</strong>字段。</p><p>IPv4到IPv6的迁移：建隧道，在中间使用IPv4的路段使用IPv4封装IPv6</p><h3 id="（不考）4-4-通用转发和SDN"><a href="#（不考）4-4-通用转发和SDN" class="headerlink" title="（不考）4.4 通用转发和SDN"></a>（不考）4.4 通用转发和SDN</h3><h3 id="第4章补充"><a href="#第4章补充" class="headerlink" title="第4章补充"></a>第4章补充</h3><p>IP定位工具</p><ul><li>ping工具</li><li>Traceroute工具</li><li>HTTPHead</li><li>CDN工具</li><li>DNS工具</li></ul><p>网络空间测绘技术</p><p>SDN三大特征</p><ul><li>集中控制、分离数据平面和可编程性</li></ul><p>P4 可编程协议无关报文处理语言</p><p>SD-WAN 广域网组网</p><h2 id="5-网络层：控制平面"><a href="#5-网络层：控制平面" class="headerlink" title="5 网络层：控制平面"></a>5 网络层：控制平面</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>路由选择算法</p><p>分类方式（集中式&#x2F;分散式，静态&#x2F;动态，负载敏感&#x2F;负载迟钝）</p><h3 id="5-2-路由选择算法"><a href="#5-2-路由选择算法" class="headerlink" title="5.2 路由选择算法"></a>5.2 路由选择算法</h3><h4 id="5-2-1-链路状态路由选择算法（LS）"><a href="#5-2-1-链路状态路由选择算法（LS）" class="headerlink" title="5.2.1 链路状态路由选择算法（LS）"></a>5.2.1 链路状态路由选择算法（LS）</h4><p>【具体内容……】Dijkstra算法</p><p>问题：拥塞敏感的路由选择的振荡</p><p>解决：确保并非所有路由器同时运行LS算法，避免自同步（发送链路通告的时间随机化）</p><h4 id="5-2-2-距离向量路由选择算法（DV）"><a href="#5-2-2-距离向量路由选择算法（DV）" class="headerlink" title="5.2.2 距离向量路由选择算法（DV）"></a>5.2.2 距离向量路由选择算法（DV）</h4><p>【具体内容……】Bellman-Ford算法</p><p>迭代的，异步的，分布式的算法</p><p>问题：</p><ul><li>好消息传播快，坏消息传播慢（算法本身对于信息的真伪无法甄别）</li><li>无穷计数问题：（链路突然变坏的消息没有及时被别的节点收到，误以为那条路仍然是好的，且这个消息会干扰到直接与那条路相连的节点）</li><li>（解决：毒性逆转：z通告y路由选择到目的地x，则z向y通告它到x的距离是无穷大【三个以上节点的环路无法检测】）</li><li>（书上没有）解决：水平分割：路由器不使用接收更新的同一接口来通告同一网络（从根本上解决问题）</li></ul><p>LS和DV比较</p><ul><li>报文复杂性：</li><li>收敛速度：DV算法收敛慢，会遇到无穷计数问题</li><li>健壮性：LS较好，DV上一个不正确的节点计算会扩散全网</li></ul><h3 id="5-3-OSPF：因特网中自治系统内部的路由选择"><a href="#5-3-OSPF：因特网中自治系统内部的路由选择" class="headerlink" title="5.3 OSPF：因特网中自治系统内部的路由选择"></a>5.3 OSPF：因特网中自治系统内部的路由选择</h3><p>开放最短路优先(OSPF)算法。</p><p>OSPF是一种链路状态协议，使用洪泛链路状态信息和Dijkstra最短路径算法。每台路由器在本地运行Dijkstra算法，构建一个关于整个自治系统的完整拓扑图。</p><p>使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息（不仅仅是向邻居广播），当链路状态变化或经过一个特定周期，路由器就会广播链路状态信息。</p><p>OSPF通告包含在OSPF报文中，直接由IP承载。</p><p>OSPF优点如下：</p><ul><li>安全：使用鉴别，仅有受信任的路由器能参与一个AS内的OSPF协议。</li><li>多条相同开销的路径：对于多条相同开销路径，OSPF允许使用多条路径，这样可以负载均衡。</li><li>对单播与多播路由选择的综合支持。</li><li>支持在单个AS中的层次结构：一个OSPF自治系统能够层次化配置多个区域，每个区域都运行自己的OSPF链路状态路由选择算法，路由器只在区域内进行广播，一台或多台边界路由器负责为流向区域外的分组提供路由选择。</li></ul><h3 id="★5-4-BGP：边界网关协议（Border-Gateway-Protocol）"><a href="#★5-4-BGP：边界网关协议（Border-Gateway-Protocol）" class="headerlink" title="★5.4 BGP：边界网关协议（Border Gateway Protocol）"></a>★5.4 BGP：边界网关协议（Border Gateway Protocol）</h3><p>对于BGP来说，只要把分组送到分组的目标网络，不需要考虑送到目标主机的问题。因此BGP中，一个目的地是一个地址前缀，即一个网络。BGP通过两个手段将分组送到目标网络：</p><ul><li>从邻居AS获取前缀的可达性信息：BGP允许每个子网向因特网中的其他部分通告自己的存在，这样一个AS就知道一个子网的存在，才可能将分组送达这个子网。即“我在这里”</li><li>确定最好的路由路径：基于策略和可达性信息，路由器会选择一条尽可能好的路由路径传送分组。</li></ul><p>通告BGP路由信息</p><ul><li>路由器只有两种：网关路由器（在AS边缘），内部路由器（在AS内）</li><li>路由器通过使用179端口的半永久【TCP连接】交换路由选择信息，每条路由器之间的连接和发送的BGP报文，称为BGP连接</li><li>跨越两个AS的BGP连接为外部BGP(eBGP)，</li><li>AS内部路由器的BGP会话为内部BGP(iBGP)</li></ul><p>BGP属性</p><ul><li>AS-PATH</li><li>NEXT HOP：AS-PATH起始路由器的IP地址</li></ul><p>确定最好的路由</p><ul><li>热土豆路由选择：尽可能快地（最低开销地）送出本AS，即最靠近NEXT-HOP</li><li>路由选择算法：依次采取以下规则：指派一个本地偏好作为属性之一，选择具有最短AS-PATH（AS-PATH就是从当前AS到达一个AS的路径）的路由，使用热土豆路由选择，使用BGP标识符</li><li>注意：当在转发表中对于热土豆路由选择增加AS向外前缀时，AS间路由选择协议（BGP）和AS内部路由选择协议（OSPF）都要用到。</li></ul><p>IP任播</p><ul><li>常用于DNS</li><li>用处：在分散不同的地理位置，替换不同服务器上的相同内容</li><li>让每个用户从最靠近的服务器访问内容</li><li>原理：为多台服务器指派相同的IP地址，并使用标准BGP通告该IP地址。这样当某台BGP路由器收到对于该IP地址的多个路由通告时，它会认为这是对相同物理位置的不同路径，因而根据本地的BGP路由选择算法选择一个较优的路径，事实上访问了最靠近的内容</li><li>在CDN网络实践上并没有采用：BGP路由选择变化能导致相同的TCP连接的不同分组到达Web服务器的不同实例（即到达了不同的服务器上，虽然是同一个IP）</li></ul><p>路由选择策略</p><ul><li>客户网络&lt;&gt;提供商网络</li><li>接入ISP：所有进入接入ISP网络的流量必定以该网络为目的地，所有离开该接入ISP网络的流量必定源于该网络。（我理解为该网络不承担中转任务，只作为终端节点的客户网络）</li><li>多宿接入ISP：连接了多个提供商网络的客户网络。</li><li>提供商网络间结算由它们自己协商</li></ul><p>拼装在一起</p><p>如果要创建一个具有服务器的小型公司网络</p><ul><li><p>首先与本地ISP签合同，将网关路由器与ISP路由器相连，获取IP地址范围，分配IP地址，Web服务器，电子邮件服务器，DNS服务器，网关路由器以及其它设备都需要IP地址。</p></li><li><p>与因特网注册机构签合同，获取域名，向注册机构提供我的DNS服务器的IP地址，注册机构将在顶级域名服务器中为我的DNS服务器添加一个表项</p></li><li><p>本地ISP使用BGP向所有与它连接的ISP通告我的前缀，最终所有因特网路由器都将得知我的前缀。</p></li></ul><h3 id="【不考】5-5-SDN控制平面"><a href="#【不考】5-5-SDN控制平面" class="headerlink" title="【不考】5.5 SDN控制平面"></a>【不考】5.5 SDN控制平面</h3><h3 id="★5-6-ICMP：因特网控制报文协议"><a href="#★5-6-ICMP：因特网控制报文协议" class="headerlink" title="★5.6 ICMP：因特网控制报文协议"></a>★5.6 ICMP：因特网控制报文协议</h3><p>主机和路由器用来彼此沟通网络层信息，用途：差错报告。</p><p>ping的实现，ICMP源抑制报文，Traceroute的实现（向不可达UDP端口号发送TTL逐次递增的报文）</p><p>补充：测试工具：</p><ul><li>ping的参数（-l size指定数据包大小，-i ttl设置存活，-w timeout设置超时时间）</li><li>traceroute（tracert）</li><li>netstat</li><li>pathping（综合ping和traceroute的功能）</li><li>tcping</li><li>http-ping（解决针对ICMP-ping的伪装）</li><li>dig（复现DNS查询过程，包括上级服务器等）</li></ul><h3 id="【】5-7-网络管理和SNMP"><a href="#【】5-7-网络管理和SNMP" class="headerlink" title="【】5.7 网络管理和SNMP"></a>【】5.7 网络管理和SNMP</h3><p>SNMP Protocol</p><h2 id="6-链路层和局域网"><a href="#6-链路层和局域网" class="headerlink" title="6 链路层和局域网"></a>6 链路层和局域网</h2><h3 id="6-1-链路层概述"><a href="#6-1-链路层概述" class="headerlink" title="6.1 链路层概述"></a>6.1 链路层概述</h3><p>节点，链路，链路层帧（在链路之间传递的数据报被封装成链路层帧），</p><p>链路层提供可能的服务</p><ul><li>成帧（framing）</li><li>链路接入，媒体访问控制（MediumAccessControl,MAC）</li><li>可靠交付（很多有线链路层协议不提供可靠交付）</li><li>差错检测和纠正（EDC）</li></ul><p>链路层在何处实现？网络适配器&#x2F;网络接口卡（NIC）</p><p>链路层是硬件和软件的结合体</p><h3 id="6-2-差错检测和纠正技术"><a href="#6-2-差错检测和纠正技术" class="headerlink" title="6.2 差错检测和纠正技术"></a>6.2 差错检测和纠正技术</h3><p>【不重要】</p><ul><li>奇偶校验，</li><li>检验和方法（运输层）：用软件实现。因特网检验和：TCP和UDP对首部&amp;数据字段计算，其他协议只对首部计算</li><li>循环冗余检测（链路层）：硬件实现，可以使用复杂方法。</li></ul><p>循环冗余检测（CRC, Cyclic Redundancy Check）</p><p>首先协商一个r+1比特模式，生成多项式G（最左边是1，剩下为r位）。</p><p>发送方：对于给定要保护的多项式D，左移r位，右边空出来的部分填充R。变换后的式子是（D*2^r XOR R）。发送方要求出R，使得该式子可以整除G（整除的过程也相当于做异或）。</p><p>R &#x3D; remainder[（D*2^r）&#x2F;G]，remainder的意思是取整除结果的后r位</p><p>接收方：若接收到的式子是可以整除G的，就是正确的。</p><p>这种方法可以检测小于r+1比特的突变。</p><h3 id="★6-3-多路访问链路和协议"><a href="#★6-3-多路访问链路和协议" class="headerlink" title="★6.3 多路访问链路和协议"></a>★6.3 多路访问链路和协议</h3><p>多路访问协议</p><ul><li>信道划分协议（Channel Partition Protocol）</li><li>随机接入协议（Random Access Protocol）</li><li>轮流协议（Taking-turns Protocol）</li></ul><p>信道划分协议</p><ul><li>时分多路复用（TDM）</li><li>频分多路复用（FDM）</li><li>码分多址（CDMA）对每个节点分配一个不同的编码，接收方根据编码来接收，不同节点能同时传输（由于有混码问题，现在不再使用，【不重要】）</li></ul><p>随机接入协议</p><ul><li>时隙ALOHA：有一个新帧要发送的时候，在下一个时隙传输整个帧；若无碰撞，成功发出；若有碰撞，在之后以概率p在之后的每个时隙中重传该帧直到成功传出。（节点只在时隙起点开始传输帧，节点同步，每个节点知道时隙什么时候开始）</li><li>ALOHA：没有引入时隙，规则同上。有一个新帧要发送的时候，立刻发送；若有碰撞，在该碰撞帧传递完后，立即以概率p重传以概率(1-p)等待这段时间，之后也是类似的。</li><li>载波侦听多路访问（CSMA，Carrier Sense Multile Access）：【载波侦听】传输前先听信道，若有节点正在发送，就等它们传输完再等一小会儿自己再传输（还会发生碰撞，为什么？信道传播时延）</li><li>具有碰撞检测的载波侦听多路访问（CSMA&#x2F;CD）：【载波侦听】跟上面一样+【碰撞检测】当检测到另一个节点正在传输干扰帧时，停止传输并随机等待一定时间（二进制指数后退binary exponential backoff算法：在该帧连续经历了n次碰撞后，等概率地从{0，1，……,2^n-1}中选择一个值作为K值。以太网中，K*512比特时间为在开始“侦听-当空闲时传输”前的等待时间）</li><li>CSMA&#x2F;CD效率；近似公式：效率&#x3D;1&#x2F;（1+5d[prop]&#x2F;d[trans]），d[prop]为信号能量在仍任意两个适配器之间传播所需的最大时间，d[trans]表示传输一个最大长度的以太网帧的时间</li></ul><p>轮流协议</p><ul><li>轮询协议：主节点通知每个节点它可以传输的帧的最多数量（缺点：引入轮询时延，若主节点有故障整个网络瘫痪）</li><li>令牌传递协议：没有主节点，不同节点之间传递一个被称为“令牌”的特殊帧（缺点，任意节点出问题使令牌没有正确传递，网络都会瘫痪）</li></ul><p>DOCSIS：用于电缆因特网接入的链路层协议【不重要】</p><h3 id="★6-4-交换局域网LANS（LocalNetwork）"><a href="#★6-4-交换局域网LANS（LocalNetwork）" class="headerlink" title="★6.4 交换局域网LANS（LocalNetwork）"></a>★6.4 交换局域网LANS（LocalNetwork）</h3><p>链路层地址，又称：LAN地址，物理地址，MAC地址</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><ul><li>主机和路由器（的适配器）具有MAC地址</li><li>MAC地址是唯一的（由IEEE管理）</li><li>MAC广播地址：FF-FF-FF-FF-FF-FF</li></ul><h4 id="ARP（Address-Relsolution-Protocol）"><a href="#ARP（Address-Relsolution-Protocol）" class="headerlink" title="ARP（Address Relsolution Protocol）"></a>ARP（Address Relsolution Protocol）</h4><ul><li>作用：将IP地址转换为MAC地址</li><li>区别：DNS为在因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址</li><li>ARP表（保存IP地址和MAC地址，有TTL，通常为20mins）</li><li>ARP是跨越链路层和网络层的协议</li></ul><p>在子网内发送：</p><ul><li>若ARP表中有对应IP的MAC地址，让适配器直接发送即可。</li><li>若ARP表没有对应IP的MAC地址，向适配器传递ARP查询分组，适配器用广播MAC地址FF-FF-FF-FF-FF-FF发送使用链路层帧封装好的ARP分组；接收到的每个适配器都会检查自己的MAC地址是不是要找的，如果是，使用标准帧回应。</li></ul><p>发送到子网外：</p><ul><li>路由器的每个接口都有一个IP地址，一个ARP模块和一个适配器</li><li>源主机A向该子网的网关路由器B发送数据包</li><li>若主机A没有该路由器B的MAC，使用ARP寻址</li><li>网关路由器B向目标子网发送数据包</li><li>若网关路由器B没有目标主机C的MAC，使用ARP寻址</li></ul><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><ul><li>集线器（物理设备）&lt;&gt;交换机</li><li>集线器作用于各比特，在一个接口上收到一个比特时，将能量强度放大，然后将该比特向其他所有接口传输出去（相当于一次只能接通一条线路）</li><li>以太网帧结构：数据字段（46-1500字节，超过1500字节需要分片），目的地址（6字节），源地址（6字节），类型字段（2字节：IP?ARP?……），CRC（循环冗余检测，4字节），前同步码（8字节：用于唤醒适配器并且同步时钟）</li><li>以太网技术向网络层：提供无连接服务（不握手），提供不可靠服务（不回ACK也不否认）</li></ul><h4 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><ul><li>作用：接收入链路层帧并转发到出链路</li><li>对于子网中的主机和路由器来说是透明的</li><li>过滤：决定某帧是转发到某个接口还是丢弃</li><li>转发：决定某帧应该被导向某个接口</li></ul><p>对于帧的处理</p><ul><li>对于从x接口到达的帧：</li><li>若没有其目的MAC对应的表项，向除到来接口x外所有口广播该帧</li><li>若有其目的MAC对应的表项且接口为x，丢弃该帧</li><li>若有其目的MAC对应的表项且接口为y≠x，向接口y的输出缓存转发该帧</li></ul><p>交换机表的更新</p><ul><li>交换机表：</li><li>表项为MAC地址，接口，时间</li><li>具有自学习能力：初始为空，对于T时间从x接口接收到的MAC地址为M的入帧，在交换机表中加入一条（M,x,T），在老化期后若再没收到，就删除该表项</li><li>交换机为“即插即用设备”，全双工（每个接口都能同时收发）</li></ul><p>链路层交换机&lt;&gt;路由器</p><ul><li>交换机即插即用，路由器需要人为配置IP地址</li><li>路由器对分组处理时间更长</li><li>路由器通常不会发生路由器循环，即使有冗余路径</li><li>路由器对第二层的广播风暴提供了保护</li></ul><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><p>之前的局域网存在缺陷：缺乏流量隔离，每个最小单位太多时导致交换机的无效使用，管理用户困难</p><p>VLAN（Virtual LAN）允许用一个单一物理局域网的基础设施定义多个虚拟局域网</p><p>VLAN干线连接（每个交换机上有一个特殊的端口用来连接一个交换机，一种特殊的帧802.1Q用于跨越VLAN干线）</p><h3 id="【】6-5-链路虚拟化：网络作为链路层"><a href="#【】6-5-链路虚拟化：网络作为链路层" class="headerlink" title="【】6.5 链路虚拟化：网络作为链路层"></a>【】6.5 链路虚拟化：网络作为链路层</h3><p>PARP</p><p>MPLS</p><h3 id="【】6-6-数据中心网络"><a href="#【】6-6-数据中心网络" class="headerlink" title="【】6.6 数据中心网络"></a>【】6.6 数据中心网络</h3><h3 id="★6-7-回顾：Web页面请求的历程"><a href="#★6-7-回顾：Web页面请求的历程" class="headerlink" title="★6.7 回顾：Web页面请求的历程"></a>★6.7 回顾：Web页面请求的历程</h3><p>【书P326-330】</p><p>DHCP(UDP)→DHCP服务器返回分配的IP地址，默认网关路由器IP地址，DNS服务器IP地址</p><p>→ARP→查询默认网关路由器MAC地址</p><p>→DNS(UDP)→查询<a href="http://www.hnu.edu.cn的ip地址(路由器根据自治区内ospf知道dns服务器该如何转发)/">www.hnu.edu.cn的IP地址（路由器根据自治区内OSPF知道DNS服务器该如何转发）</a></p><p>→TCP三次握手，HTTP GET</p><h2 id="7-无线网络和移动网络"><a href="#7-无线网络和移动网络" class="headerlink" title="7 无线网络和移动网络"></a>7 无线网络和移动网络</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1  概述"></a>7.1  概述</h3><p>无线主机，无线通信链路（两个主要特性：覆盖区域，链路速率）</p><p>基站（蜂窝塔，接入点等），无线主机与基站“相关联”：该主机位于该基站的无线通信覆盖范围内，该主机使用该基站中继它与更大网络之间的数据</p><p>基础设施模式（通过基站相连），自组织网络（无基础设施）</p><p>基于一个无线跳&#x2F;多个无线跳分组：</p><ul><li>单跳，基于基础设施：802.11，4G LTE数据网络</li><li>单跳，无基础设施：蓝牙网络，具有自组织模式的802.11</li><li>多跳，基于基础设施：无线传感网络，无线网状网络</li><li>多跳，无基础设施：移动自组织网络</li></ul><h3 id="7-2-无线链路和网络特征"><a href="#7-2-无线链路和网络特征" class="headerlink" title="7.2 无线链路和网络特征"></a>7.2 无线链路和网络特征</h3><p>★有线链路与无线链路的区别：</p><ul><li>递减的信号强度（路径损耗）</li><li>来自其它源的干扰（同一个频段发射的电波源互相干扰）</li><li>多径传播（电磁波受到物体和地面的反射，使得信号变模糊）</li><li>隐藏终端问题：A和C都向B通信，但由于物理阻隔，A和C彼此不知道对方的存在</li></ul><p>对于CDMA编码的讨论【略】</p><h3 id="7-3-WiFi：802-11-无线-LAN"><a href="#7-3-WiFi：802-11-无线-LAN" class="headerlink" title="7.3 WiFi：802.11 无线 LAN"></a>7.3 WiFi：802.11 无线 LAN</h3><p>802.11结构：</p><ul><li>基本服务集（BSS,Basic Service Set），一个BSS包含一个或多个无线站点和中央基站</li><li>接入点（AP,Acess Point）</li></ul><p>信道与关联</p><ul><li>AP被安装时，会分配一个服务器标识符（SSID,Service Set Identifier）和一个信道号</li><li>每个AP周期性地发送信标帧（包括该AP的SSID和MAC地址）</li><li>我的无线站点扫描信道并连接可用的AP用于关联</li><li>扫描方式可以有被动扫描和主动扫描（广播探测帧）</li><li>确定想关联的AP后，我的无线主机向该AP发送一个关联请求帧，该AP使用关联响应帧回应</li><li>关联后，我的主机通过关联的AP向子网发送DHCP发现报文，以获取在该AP子网中的一个IP地址</li></ul><p>802.11 MAC协议</p><p>CSMA&#x2F;CA（collision avoidance）带碰撞避免的CSMA</p><p>★802.11与以太网的区别</p><ul><li>802.11使用碰撞避免而非碰撞检测（接收信号的强度远远小于发送强度，无法同时发送&#x2F;接收信号，隐藏终端问题和衰减问题，没法做到碰撞检测）</li><li>由于误比特率高，802.11使用链路层确认&#x2F;重传（ARQ）方案</li></ul><p>链路层确认：</p><p>目的站点收到一个帧后，等待一小段时间（短帧间间隔SIFS），发挥一个确认帧，若发送站点一定时间内未收到确认帧，就假定错误并重传该帧，若多次错误就抛弃该帧。</p><p>CSMA&#x2F;CA：</p><ul><li>站点最初监听到信道空闲，在短时间（分布式间隔帧DIFS）后发送该帧</li><li>否则，该站点选取一个随机回退值，并在侦听信道空闲时递减该值，若信道忙，该值不变。</li><li>当计数减为0时，该站点发送整个数据帧并等待确认</li><li>若收到确认，则该帧成功发送。若未收到确认，重新进入选取回退值的阶段，并在一个更大的范围内选择回退值</li></ul><p>处理隐藏终端：RTS和CTS</p><ul><li>请求发送控制帧RTS</li><li>允许发送控制帧CTS</li><li>发送方先向AP发RTS并预约传输DATA帧和收回ACK帧需要的时间</li><li>AP广播CTS，回应发送方并授权许可，同时该CTS还能指示其它站点在预约期内不要发送</li></ul><p>使用802.11作为一个点对点链路</p><ul><li>定向天线</li></ul><p>7.3.3 IEEE 802.11帧</p><p>有4个地址（我们关注3个）</p><ul><li>地址2：传输该帧的站点的MAC地址</li><li>地址1：要接受该帧的无线站点的MAC地址</li><li>地址3：AP接入的路由器接口的MAC地址</li><li>（前两个负责无线通信，最后一个确认路由器MAC）</li></ul><p>7.3.4 在相同的IP子网中的移动性</p><ul><li>我的无线站点在远离AP1后解除与AP1的关联，并与AP2关联。</li><li>怎么让交换机知道？在新关联形成后，让AP2以我的无线站点的源地址向交换机发送以太网广播帧</li></ul><p>LTE：long term evolution</p><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p>架构</p><ul><li>分层架构(internet)、集中&#x2F;分布式、端到端、C&#x2F;S、B&#x2F;S、P2P</li></ul><p>原则 - principles</p><ul><li>端到端：保持一个极简的网络核心，将复杂留在端</li><li>传输层：不可靠网络层上的可靠通信、连接建立&#x2F;拆除和握手、拥塞和流量控制以及多路复用</li><li>网络层：确定两个路由器之间的“良好”路径、互连大量异构网络以及管理现代网络的复杂性、控制平面&#x2F;数据平面</li><li>链路层：共享多路访问信道，处理&#x2F;避免冲突，数据包转发与寻址</li><li>分层之间的连接：DNS，DHCP，ARP</li><li>性能指标：时延，吞吐率</li><li>这些原则具有较长“保质期”—在今天的网络标准和协议过时之后，它们所体现的原则仍然很重要和相关。</li><li>掌握与这些原则相关的基本问题和解决方法，以后能够快速了解几乎任何网络技术。</li></ul><p>发展与竞争</p><ul><li>技术演进：HTTP1.0-&gt;3.0,TCP算法，IPV4-&gt;IPV6，以太网（10M-&gt;100G），无线网（2G-&gt;6G,wifi-&gt;wifi7）</li><li>产业兴衰：伴随网络发展，传统业务比如有线电视，语音电话，短信不断衰落;互联网-&gt;移动互联网-&gt;产业互联网</li></ul><p>争论与妥协</p><ul><li>电路交换-包交换，集中-分布式，端到端-NAT，IPV4-IPV6，非二层交换、硬件-软件，符号主义-连接主义，</li></ul><p>矛盾与演进</p><ul><li>对立统一（中心化&#x2F;去中心化）、在应用中螺旋上升</li></ul><h2 id="备考"><a href="#备考" class="headerlink" title="备考"></a>备考</h2><p>网路层路由，路由器怎么工作，路由协议，路由算法，路由器转发动作</p><p>数据平面和控制平面分离，不考</p><p>IPv4地址分配，NAT★P225，</p><p>ICMP不考</p><p>OSPF BGP</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo自建一个github托管的静态网页</title>
      <link href="/2023/08/25/HEXO%E8%87%AA%E5%BB%BA%E7%BD%91%E7%AB%99/"/>
      <url>/2023/08/25/HEXO%E8%87%AA%E5%BB%BA%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Hexo自建一个github托管的静态网页"><a href="#基于Hexo自建一个github托管的静态网页" class="headerlink" title="基于Hexo自建一个github托管的静态网页"></a>基于Hexo自建一个github托管的静态网页</h1><h2 id="建立github密钥"><a href="#建立github密钥" class="headerlink" title="建立github密钥"></a>建立github密钥</h2><pre class="line-numbers language-none"><code class="language-none">git config --global user.name wolfvoidgit config --global user.email 1055320990@qq.com三个回车，根据提示内容找到密钥储存地址，复制密钥在github上的ssh部分添加ssh git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>经历如下过程，出现如下结果</p><pre class="line-numbers language-none"><code class="language-none">y@LAPTOP-S8GDLRKI MINGW64 ~&#x2F;Desktop$ ssh git@github.comThe authenticity of host &#39;github.com (20.205.243.166)&#39; can&#39;t be established.ED25519 key fingerprint is 密码.This key is not known by any other names.Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yesWarning: Permanently added &#39;github.com&#39; (ED25519) to the list of known hosts.PTY allocation request failed on channel 0Hi wolfvoid! You&#39;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.y@LAPTOP-S8GDLRKI MINGW64 ~&#x2F;Desktop$ ssh git@github.comPTY allocation request failed on channel 0Hi wolfvoid! You&#39;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二次表示匹配成功</p><h2 id="确保node和npm已安装"><a href="#确保node和npm已安装" class="headerlink" title="确保node和npm已安装"></a>确保node和npm已安装</h2><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>命令行如下</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-cli hexo init My_blogcd My_bloghexo new test_my_sitehexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在本地localhost:4000可见初始网页</p><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><pre class="line-numbers language-none"><code class="language-none">npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客命令简写hexo n &quot;我的博客&quot; &#x3D;&#x3D; hexo new &quot;我的博客&quot; #新建文章hexo g &#x3D;&#x3D; hexo generate #生成hexo s &#x3D;&#x3D; hexo server #启动服务预览hexo d &#x3D;&#x3D; hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h2><p>blog根目录里的_config.yml文件称为站点配置文件</p><p>themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件</p><p>打开站点的配置文件_config.yml，翻到最后修改为：</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;wolfvoid&#x2F;wolfvoid.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里应该是有问题的，后面会修改</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --savehexo clean hexo g hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>报错如下</p><pre class="line-numbers language-none"><code class="language-none">(base) PS E:\My_blog\My_blog&gt; npm install hexo-deployer-git --savenpm ERR! Cannot read properties of null (reading &#39;matches&#39;)npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\y\AppData\Local\npm-cache\_logs\2023-08-24T17_51_02_435Z-debug-0.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因：我的node版本太高了，反正就是不符合要求</p><p>补救方法：安装适合版本的node。为了方便管理，直接安装nvm</p><h2 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h2><p><a href="https://www.rstk.cn/news/1475977.html?action=onClick">https://www.rstk.cn/news/1475977.html?action=onClick</a></p><p>注意在E:\nvm\nvm\settings.txt中替换镜像源为</p><pre class="line-numbers language-none"><code class="language-none">node_mirror:https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;npm_mirror:https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意路径为</p><p><img src="C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20230825151837550.png" alt="image-20230825151837550"></p><p>出现安装nvm后node和npm无法正常显示的问题</p><p><a href="https://blog.csdn.net/taylorzun/article/details/105471841">https://blog.csdn.net/taylorzun/article/details/105471841</a></p><h2 id="★基本搭建结束符★"><a href="#★基本搭建结束符★" class="headerlink" title="★基本搭建结束符★"></a>★基本搭建结束符★</h2><p>至此网站基本的工作完成了，主题为landscape，太low了，我想要更换主题</p><h2 id="闪烁之狐主题"><a href="#闪烁之狐主题" class="headerlink" title="闪烁之狐主题"></a>闪烁之狐主题</h2><p>hexo-theme-matery的示例网站：<a href="http://blinkfox.com/">http://blinkfox.com/</a></p><p>介绍网站<a href="https://zhuanlan.zhihu.com/p/35668237">https://zhuanlan.zhihu.com/p/35668237</a></p><p>★详见“闪烁之狐”主题的README</p><p>根据该README文件完成了新建所有页的操作</p><p>并完成了插件构建 </p><h2 id="解决更换主题后无法显示的问题"><a href="#解决更换主题后无法显示的问题" class="headerlink" title="解决更换主题后无法显示的问题"></a>解决更换主题后无法显示的问题</h2><p>hexo更换主题后出现问题：WARN No layout: index.html</p><p><a href="https://blog.csdn.net/weixin_44460555/article/details/111866191">https://blog.csdn.net/weixin_44460555/article/details/111866191</a></p><p>主要来说就是下载的包名字是hexo-theme-matery-master，而设置里面是用的hexo-theme-matery，它找不到了。把它对应起来就好了。</p><h2 id="解决无法连接github的问题"><a href="#解决无法连接github的问题" class="headerlink" title="解决无法连接github的问题"></a>解决无法连接github的问题</h2><p>解决无法连接github的 Connection was reset问题</p><pre class="line-numbers language-none"><code class="language-none">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;wolfvoid&#x2F;wolfvoid.github.io.git&#x2F;&#39;: Recv failure: Connection was resetFATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.htmlError: Spawn failed    at ChildProcess.&lt;anonymous&gt; (E:\My_blog\blog\node_modules\hexo-util\lib\spawn.js:51:21)    at ChildProcess.emit (node:events:390:28)    at ChildProcess.cp.emit (E:\My_blog\blog\node_modules\cross-spawn\lib\enoent.js:34:29)    at Process.ChildProcess._handle.onexit (node:internal&#x2F;child_process:290:12)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：</p><p>_config.yml文件修改为</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: git@github.com:wolfvoid&#x2F;wolfvoid.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何向github仓库上传文件"><a href="#如何向github仓库上传文件" class="headerlink" title="如何向github仓库上传文件"></a>如何向github仓库上传文件</h2><p>（使用github作为图床）</p><pre class="line-numbers language-none"><code class="language-none">git init #把这个文件夹变成gitgit status #查看文件夹里的文件的情况git add xxxx #添加东西git commit -m &#39;我提交了xxx&#39; #注释建立github密钥联系建立GitHub上的仓库git remote add origin git@github.com:wolfvoid&#x2F;pictures.git#若初次上传git push -u origin master若已经有过东西git pull --rebase origin mastergit push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用上述方法出错如下</p><pre class="line-numbers language-none"><code class="language-none">$ git push origin mastererror: src refspec master does not match anyerror: failed to push some refs to &#39;github.com:wolfvoid&#x2F;pictures.git&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>错误原因是git上的master和github上的main不符合（有病吧）</p><p><a href="https://blog.csdn.net/gongdamrgao/article/details/115032436?spm=1001.2014.3001.5502">https://blog.csdn.net/gongdamrgao/article/details/115032436?spm=1001.2014.3001.5502</a></p><p>操作流程：</p><pre class="line-numbers language-none"><code class="language-none">git clone git@github.com:wolfvoid&#x2F;pictures.git #先把远程仓库扒下来git add xxxx #添加东西git commit -m &#39;我提交了xxx&#39; #注释git push origin main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样应该就没问题了</p>]]></content>
      
      
      <categories>
          
          <category> webpage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMP并行编程</title>
      <link href="/2023/08/25/OpenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/08/25/OpenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenMP并行编程"><a href="#OpenMP并行编程" class="headerlink" title="OpenMP并行编程"></a>OpenMP并行编程</h1><p>在codeblocks上配置OpenMP</p><p>本质：</p><p>编译时添加 -fopenmp命令</p><p>链接时添加 -lgomp -lpthread</p><p>【vscode本机】</p><p>使用终端编译</p><p> g++ -fopenmp -lgomp -lpthread parallel.cpp</p><p>使用以下命令编译即可直接得到结果</p><pre class="line-numbers language-none"><code class="language-none">g++ -fopenmp -lgomp -lpthread parallel.cpp -o process.exe ; .\process.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><pre class="line-numbers language-none"><code class="language-none">#include&lt;omp.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;#pragma omp parallel&#123;cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置并行线程个数</p><pre class="line-numbers language-none"><code class="language-none">#pragma omp parallel num_threads(5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">omp_set_num_threads(2);#pragma omp parallel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>循环</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;omp.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;omp_set_num_threads(2);#pragma omp parallel&#123;#pragma omp forfor(int i&#x3D;0;i&lt;4;i++) cout &lt;&lt; omp_get_thread_num() &lt;&lt; endl;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用schedule子句进行for循环任务调度的管理"><a href="#用schedule子句进行for循环任务调度的管理" class="headerlink" title="用schedule子句进行for循环任务调度的管理"></a>用schedule子句进行for循环任务调度的管理</h2><p>schedule子句形式</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">schedule(type, size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>type参数有四种：1.static, 2.dynamic, 3.guided, 4.runtime</p><p>size参数是整形数据：表示循环迭代次数划分的单位。</p><ul><li><p><strong>static参数</strong></p><p>静态调度，不用size参数时分配给每个程序的都是n&#x2F;t次连续迭代，n为迭代次数，t为并行的线程数目。</p></li><li><p><strong>dynamic参数</strong></p><p>动态调度模式是先到先得的方式进行任务分配，不用size参数的时候，先把任务干完的线程先取下一个任务，以此类推，而不是一开始就分配固定的任务数。使用size参数的时候，分配的任务以size为单位，一次性分配size个。虽然很智能，在任务难度不均衡的时候适合用dynamic，否则会引起过多的任务动态申请的开销。</p></li><li><p><strong>guided参数</strong></p><p>刚开始每个线程会分配到比较大的迭代块，后来分配到的迭代块逐渐递减，没有指定size就会降到1，否则降到size。</p></li><li><p><strong>runtime</strong></p><p>基本不会用到，需要了解的可以自行了解。</p></li></ul><h2 id="sections制导指令"><a href="#sections制导指令" class="headerlink" title="sections制导指令"></a>sections制导指令</h2><p>用sections把不同的区域交给不同的线程去执行</p><p>用法：</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;omp.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;omp_set_num_threads(3);#pragma omp parallel sections&#123;#pragma omp section&#123;cout &lt;&lt;omp_get_thread_num();&#125;#pragma omp section&#123;cout &lt;&lt; omp_get_thread_num();&#125;#pragma omp section&#123;cout &lt;&lt; omp_get_thread_num();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="single制导指令"><a href="#single制导指令" class="headerlink" title="single制导指令"></a>single制导指令</h2><p>single制导指令所包含的代码段只有一个线程执行，别的线程跳过该代码，如果没有nowait子句，那么其他线程将会在single制导指令结束的隐式同步点等待。有nowait子句其他线程将跳过等待往下执行。</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;omp_set_num_threads(4);#pragma omp parallel&#123;#pragma omp single&#123;cout &lt;&lt; &quot;single thread&#x3D;&quot; &lt;&lt; omp_get_thread_num()&lt;&lt;endl;&#125;cout &lt;&lt; omp_get_thread_num() &lt;&lt; endl;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
